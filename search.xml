<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java/arithmetic/2</title>
      <link href="/2020/06/24/java/arithmetic/2/"/>
      <url>/2020/06/24/java/arithmetic/2/</url>
      
        <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 题目：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</span></span><br><span class="line"><span class="comment">     * 题解：</span></span><br><span class="line"><span class="comment">     * https://blog.csdn.net/Zolewit/article/details/88863970</span></span><br><span class="line"><span class="comment">     * https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/</span></span><br><span class="line"><span class="comment">     * https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(largestRectangleArea1(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>&#125;));</span><br><span class="line">        System.out.println(largestRectangleArea2(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法一</span></span><br><span class="line"><span class="comment">     * 固定中间一个找两边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heights</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea1</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heights.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最大面积</span></span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i;</span><br><span class="line">            <span class="keyword">int</span> currentHeight = heights[i];</span><br><span class="line">            <span class="comment">// left &gt; 0 防止为第一个数据；寻找左边最后一个大于currentHeight的下标</span></span><br><span class="line">            <span class="keyword">while</span> (left &gt; <span class="number">0</span> &amp;&amp; heights[left - <span class="number">1</span>] &gt;= currentHeight) &#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> right = i;</span><br><span class="line">            <span class="comment">// right &lt; heights.length - 1 防止为最后一个数据；寻找右边最后一个大于currentHeight的下标</span></span><br><span class="line">            <span class="keyword">while</span> (right &lt; heights.length - <span class="number">1</span> &amp;&amp; heights[right + <span class="number">1</span>] &gt;= currentHeight) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxArea = Math.max(maxArea, (right - left + <span class="number">1</span>) * currentHeight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法二</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heights</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea2</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] newHeights = <span class="keyword">new</span> <span class="keyword">int</span>[heights.length + <span class="number">2</span>];</span><br><span class="line">        System.arraycopy(heights, <span class="number">0</span>, newHeights, <span class="number">1</span>, heights.length);</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;(heights.length);</span><br><span class="line">        deque.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; newHeights.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (newHeights[i] &lt; newHeights[deque.getLast()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> height = newHeights[deque.pollLast()];</span><br><span class="line">                <span class="keyword">int</span> width = i - deque.peekLast() - <span class="number">1</span>;</span><br><span class="line">                maxArea = Math.max(maxArea, height * width);</span><br><span class="line">            &#125;</span><br><span class="line">            deque.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>这个题目的第二种解法真的太妙了，有亿点东西，我在idea中一步步调试才弄明白</strong></p><p><img src="https://image.cclblog.cn/blog/20200624221318.png" alt=""></p></blockquote><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. 滑动窗口最大值</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 题目：https://leetcode-cn.com/problems/sliding-window-maximum/</span></span><br><span class="line"><span class="comment">     * 题解：https://leetcode.com/problems/sliding-window-maximum/discuss/65884/Java-O(n)-solution-using-deque-with-explanation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Arrays.toString(maxSlidingWindow1(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, <span class="number">3</span>)));</span><br><span class="line">        System.out.println(Arrays.toString(maxSlidingWindow2(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, <span class="number">3</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法一：遍历每个滑动窗口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow1(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums.length - k + 1 : 滑动窗口个数</span></span><br><span class="line">        <span class="keyword">int</span>[] rnums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + k; j++) &#123;</span><br><span class="line">                max = Math.max(max, nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            rnums[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rnums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法二：双端队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span> - k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 每当新数进来时，如果发现队列头部的数的下标，是窗口最左边数的下标，则扔掉</span></span><br><span class="line">            <span class="keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.peekFirst() == i - k) &#123;</span><br><span class="line">                deque.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把队列尾部所有比新数小的都扔掉，保证队列是降序的</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加入新数</span></span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">            <span class="comment">// 队列头部就是该窗口内第一大的</span></span><br><span class="line">            <span class="keyword">if</span> ((i + <span class="number">1</span>) &gt;= k) &#123;</span><br><span class="line">                res[i + <span class="number">1</span> - k] = nums[deque.peek()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数组题集</title>
      <link href="/2020/06/23/java/arithmetic/1/"/>
      <url>/2020/06/23/java/arithmetic/1/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：https://leetcode-cn.com/problems/container-with-most-water/</span></span><br><span class="line"><span class="comment"> * 题解：https://leetcode-cn.com/problems/container-with-most-water/solution/container-with-most-water-shuang-zhi-zhen-fa-yi-do/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] test = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    System.out.println(maxArea2(test));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴力解法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> height</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea1</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">            maxArea = Math.max(maxArea, Math.min(height[i], height[j]) * (j - i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双指针法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> height</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea2</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = height.length - <span class="number">1</span>, maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        maxArea = height[i] &gt; height[j] ?</span><br><span class="line">                Math.max(maxArea, (j - i) * height[j--]) :</span><br><span class="line">                Math.max(maxArea, (j - i) * height[i++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：https://leetcode-cn.com/problems/move-zeroes/</span></span><br><span class="line"><span class="comment"> * 题解：https://leetcode-cn.com/problems/move-zeroes/solution/dong-hua-yan-shi-283yi-dong-ling-by-wang_ni_ma/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] test = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    moveZeroes1(test);</span><br><span class="line">    moveZeroes2(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 纪录0出现的个数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历数组将非0元素前提</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            nums[count++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 count-nums.length 全部置为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = count; i &lt; nums.length; i++) &#123;</span><br><span class="line">        nums[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(nums));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快慢指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) &#123;</span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">                nums[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Syste.out.println(Arrays.toString(nums));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 题目：https://leetcode-cn.com/problems/climbing-stairs/</span></span><br><span class="line"><span class="comment">    * 题解：https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(climbStairs(<span class="number">3</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           p = q;</span><br><span class="line">           q = r;</span><br><span class="line">           r = p + q;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> r;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 题目：https://leetcode-cn.com/problems/two-sum/</span></span><br><span class="line"><span class="comment">    * 解析：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(Arrays.toString(twoSum1(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>&#125;, <span class="number">6</span>)));</span><br><span class="line">       System.out.println(Arrays.toString(twoSum2(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>&#125;, <span class="number">6</span>)));</span><br><span class="line">       System.out.println(Arrays.toString(twoSum3(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>&#125;, <span class="number">6</span>)));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 暴力求解</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum1(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="comment">// 双重for循环遍历，将所有的可能全部列举，一一与target比较</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 两遍哈希表</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       Map&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="comment">// 遍历数组将数组中的值-下标保存到hashMap中</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           hashMap.put(nums[i], i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 遍历数组，如果hashMap中存在target - nums[i] 这个值&amp;&amp;该值的下标不等于i（防止数组中正好target - nums[i]为其本身，例如6 - 3 = 3），</span></span><br><span class="line">       <span class="comment">// 那么就立即返回结果</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (hashMap.containsKey(target - nums[i]) &amp;&amp; hashMap.get(target - nums[i]) != i) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, hashMap.get(target - nums[i])&#125;;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 一遍哈希表</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum3(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       Map&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="comment">// 一边将元素保存到hashMap中，一边同时进行检查，如果找到符合的条件立即返回</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (hashMap.containsKey(target - nums[i]) &amp;&amp; hashMap.get(target - nums[i]) != i) &#123;</span><br><span class="line">               <span class="comment">// 之所以&#123;hashMap.get(target - nums[i]), i&#125;而不是&#123;i, hashMap.get(target - nums[i])&#125;</span></span><br><span class="line">               <span class="comment">// 是因为hashMap最后的那个元素，i永远比hashMap.get(target - nums[i])大</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;hashMap.get(target - nums[i]), i&#125;;</span><br><span class="line">           &#125;</span><br><span class="line">           hashMap.put(nums[i], i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：https://leetcode-cn.com/problems/3sum/</span></span><br><span class="line"><span class="comment"> * 题解：https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(threeSum(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>&#125;));</span><br><span class="line">    System.out.println(threeSum(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    ArrayList&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">// 数组长度小于三，无意义</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 最小的都大于0，肯定不存在结果 a + b + c = 0;</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i&gt;0 防止i=0的时候 i-1=-1；去重，前一个值等于后一个值已经计算过，不能重复计算</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// l 指向i的前一个位置</span></span><br><span class="line">        <span class="keyword">int</span> l = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// r 指向数组的最后一个位置</span></span><br><span class="line">        <span class="keyword">int</span> r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// l 指针不能大于r</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">// 计算这三个数的值</span></span><br><span class="line">            <span class="keyword">int</span> result = nums[i] + nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 等于0添加到列表中</span></span><br><span class="line">                list.add(Arrays.asList(nums[i], nums[l], nums[r]));</span><br><span class="line">                <span class="comment">// 去重，防止存在重复元素，导致结果重复</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>]) &#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 去重，同理上</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) &#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 左指针++</span></span><br><span class="line">                l++;</span><br><span class="line">                <span class="comment">// 右指针--</span></span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// a + b + c &gt; 0 说明这个 c太大 要减小 自然 r-- 指向c的前一个位置 （注意这是排过序的数组）</span></span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 同理上</span></span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>这个题目真的需要自己去思考，debug调试一下，我写的注释仅仅是我个人理解。</strong></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题集（第一周）</title>
      <link href="/2020/06/22/java/question/1/"/>
      <url>/2020/06/22/java/question/1/</url>
      
        <content type="html"><![CDATA[<h1 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h1><h2 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h2><p><strong>对于JVM内存配置参数：</strong></p><blockquote><p><strong>-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3</strong></p></blockquote><p><strong>,其最小内存值和Survivor区总大小分别是（）</strong></p><ul><li><strong>A：</strong>5120m，1024m</li><li><strong>B：</strong>5120m，2048m</li><li><strong>C：</strong>10240m，1024m</li><li><strong>D：</strong>10240m，2048m</li></ul><blockquote><p><strong>解析：</strong></p><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p>-Xmx：最大堆大小</p><p>-Xms：初始堆大小</p><p>-Xmn:年轻代大小</p><p>-XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值</p><p>年轻代5120m， Eden：Survivor=3，Survivor区大小=1024m（Survivor区有两个，即将年轻代分为5份，每个Survivor区占一份），总大小为2048m。</p><p>-Xms初始堆大小即最小内存值为10240m</p></blockquote><p><strong>（多选）关于OutOfMemoryError，下面说法正确的是（）？</strong></p><ul><li>java.lang.OutOfMemoryError: PermGen space 增加-XX:MaxPermSize这个参数的值的话，这个问题通常会得到解决。</li><li>java.lang.OutOfMemoryError: Requested array size exceeds VM limit当你正准备创建一个超过虚拟机允许的大小的数组时，这条错误将会出现</li><li>java.lang.OutOfMemoryError: Java heap space 一般情况下解决这个问题最快的方法就是通过-Xmx参数来增加堆的大小</li><li>java.lang.OutOfMemoryError: nativeGetNewTLA这个异常只有在jRockit虚拟机时才会碰到</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ABC</span></span><p><strong>解析：</strong></p><p>A：属于运行时常量池导致的溢出，设置-XX：MaxPermSize可以解决这个问题，</p><p>B：属于堆空间不足导致的错误，解决方式和C相同，</p><p>C：属于java堆内存问题，一般的手段是通过内存映像分析工具，对Dump出来的堆转储存快照进行分析，重点是确认内存中的对象是否是有必要的，也就是要判断是出现了内存泄漏，还是出现了内存溢出。如果是内存泄露，通过工具检查泄露对象打GC Roots的引用链信息，可以准确的确定出泄露代码的位置，不存在泄露，就应该检查虚拟机的堆参数，如果可以继续调大，可以设置-Xmx解决问题</p><p>D：java.lang.OutOfMemoryError: nativeGetNewTLA指当虚拟机不能分配新的线程本地空间(Thread Local Area）的时候错误信息，此错误是线程申请一个新的TLA时产生的，这个异常一般只会发生在jRockit虚拟机，只有过于绝对。</p></blockquote><p><strong>下面有关java classloader说法错误的是（）?</strong></p><ul><li><strong>A：</strong> Java默认提供的三个ClassLoader是BootStrap ClassLoader，Extension ClassLoader，App ClassLoader、</li><li><strong>B：</strong>ClassLoader使用的是双亲委托模型来搜索类的</li><li><strong>C：</strong>VM在判定两个class是否相同时，只用判断类名相同即可，和类加载器无关</li><li><strong>D：</strong>ClassLoader就是用来动态加载class文件到内存当中用的</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p>比较两个类是否相等，只有这两个类是由同一个类加载器加载才有意义。否则，即使这两个类是来源于同一个Class文件，只要加载它们的类加载器不同，那么这两个类必定不相等。</p><p>补充：</p><p><strong>1.</strong> <strong>什么是类加载器？</strong></p><p>把类加载的过程放到Java虚拟机外部去实现，让应用程序决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。  </p><p><strong>2.</strong> <strong>有哪些类加载器，分别加载哪些类</strong></p><p>类加载器按照层次，从顶层到底层，分为以下三种：<br>(1)启动类加载器 : 它用来加载 Java 的核心库，比如String、System这些类<br>(2)扩展类加载器 : 它用来加载 Java 的扩展库。</p><p>(3) 应用程序类加载器 : 负责加载用户类路径上所指定的类库，一般来说，Java 应用的类都是由它来完成加载的。</p><p><strong>3.</strong> <strong>双亲委派模型</strong></p><p>我们应用程序都是由以上三种类加载器互相配合进行加载的，还可以加入自己定义的类加载器。称为 <strong>类加载器的双亲委派模型</strong> ，这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用 <strong>组合关系</strong> 来复用父加载器的。</p><p><strong>4.</strong> <strong>双亲委托模型的工作原理</strong></p><p>是当一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法加载这个加载请求的时候，子加载器才会尝试自己去加载。</p><p><strong>5.</strong> <strong>使用双亲委派模型好处？（原因）</strong></p><p>第一：可以避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载。</p><p>第二：考虑到安全因素，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时被加载，所以用户自定义类是无法加载一个自定义的类装载器。</p></blockquote><p><strong>（多选）关于Java中的ClassLoader下面的哪些描述是错误的：(   )</strong></p><ul><li><strong>A：</strong>默认情况下，Java应用启动过程涉及三个ClassLoader: Boostrap, Extension, System</li><li><strong>B：</strong>一般的情况不同ClassLoader装载的类是不相同的，但接口类例外，对于同一接口所有类装载器装载所获得的类是相同的</li><li><strong>C：</strong>类装载器需要保证类装载过程的线程安全</li><li><strong>D：</strong>ClassLoader的loadClass在装载一个类时，如果该类不存在它将返回null</li><li><strong>E：</strong>ClassLoader的父子结构中，默认装载采用了父优先</li><li><strong>F：</strong>所有ClassLoader装载的类都来自CLASSPATH环境指定的路径</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BDF</span></span><p><strong>解析：</strong></p><p><strong>A.Java系统提供3种类加载器：启动类加载器（Bootstrap ClassLoader）  扩展类加载器（Extension ClassLoader） 应用程序类加载器（Application ClassLoader）. A正确</strong></p><p><strong>B.《深入理解Java虚拟机》P228：对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类必定不相等。</strong>接口类是一种特殊类，因此对于同一接口不同的类装载器装载所获得的类是不相同的。<strong>B错误</strong></p><p><strong>C.类只需加载一次就行，因此要保证类加载过程线程安全，防止类加载多次。C正确</strong></p><p><strong>D.</strong> <strong>Java程序的类加载器采用双亲委派模型，实现双亲委派的代码集中在java.lang.ClassLoader的loadClass()方法中，此方法实现的大致逻辑是：先检查是否已经被加载，若没有加载则调用父类加载器的loadClass()方法，若父类加载器为空则默认使用启动类加载器作为父类加载器。如果父类加载失败，抛出ClassNotFoundException异常。D错误</strong></p><p><strong>E.双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。E正确</strong></p><p><strong>F.应用程序类加载器（Application ClassLoader）负责加载</strong>用户类路径（ClassPath）上所指定的类库，不是所有的ClassLoader都加载此路径。F错误</p></blockquote><p><strong>以下代码执行的结果显示是多少（）？</strong></p><ul><li><strong>A：</strong>505000</li><li><strong>B：</strong>0</li><li><strong>C：</strong>运行时错误</li><li><strong>D：</strong>5050</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>count = count++  原理是 temp = count； count = count+1 ； count = temp；   因此count始终是0 这仅限于java 与c是不一样的</p><p>count=count++就是先把局部变量表中count的值0放入操作数栈中，然后直接对局部变量表中的count加1，然后再把操作数栈中的0出栈赋值给局部变量表中的count，最终局部变量表中的count值仍为0</p></blockquote><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1=<span class="number">1</span>,b2=<span class="number">2</span>,b3,b6; </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span> b4=<span class="number">4</span>,b5=<span class="number">6</span>; </span><br><span class="line">b6=b4+b5; </span><br><span class="line">b3=(b1+b2); </span><br><span class="line">System.out.println(b3+b6);</span><br></pre></td></tr></table></figure><p><strong>关于上面代码片段叙述正确的是（）</strong></p><ul><li><strong>A：</strong>输出结果：13</li><li><strong>B：</strong>语句：b6=b4+b5编译出错</li><li><strong>C：</strong>语句：b3=b1+b2编译出错</li><li><strong>D：</strong>运行期抛出异常</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p>被final修饰的变量是常量，这里的b6=b4+b5可以看成是b6=10；在编译时就已经变为b6=10了</p><p>而b1和b2是byte类型，java中进行计算时候将他们提升为int类型，再进行计算，b1+b2计算后已经是int类型，赋值给b3，b3是byte类型，类型不匹配，编译不会通过，需要进行强制转换。</p><p>Java中的byte，short，char进行计算时都会提升为int类型。</p></blockquote><p><strong>下面有关java基本类型的默认值和取值范围，说法错误的是？</strong></p><ul><li><strong>A：</strong>字节型的类型默认值是0，取值范围是-2^7—2^7-1</li><li><strong>B：</strong>boolean类型默认值是false，取值范围是true\false</li><li><strong>C：</strong>字符型类型默认是0，取值范围是-2^15 —2^15-1</li><li><strong>D：</strong>long类型默认是0，取值范围是-2^63—2^63-1</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><table><thead><tr><th></th><th>More Actions  默认值</th><th>存储需求（字节）</th><th>取值范围</th><th>示例</th></tr></thead><tbody><tr><td>byte</td><td>0</td><td>1</td><td>-2^7—2^7-1</td><td>byte b=10;</td></tr><tr><td>char</td><td>‘ \u0000′</td><td>2</td><td>0—2^16-1</td><td>char c=’c’ ;</td></tr><tr><td>short</td><td>0</td><td>2</td><td>-2^15—2^15-1</td><td>short s=10;</td></tr><tr><td>int</td><td>0</td><td>4</td><td>-2^31—2^31-1</td><td>int i=10;</td></tr><tr><td>long</td><td>0</td><td>8</td><td>-2^63—2^63-1</td><td>long o=10L;</td></tr><tr><td>float</td><td>0.0f</td><td>4</td><td>-2^31—2^31-1</td><td>float f=10.0F</td></tr><tr><td>double</td><td>0.0d</td><td>8</td><td>-2^63—2^63-1</td><td>double d=10.0;</td></tr><tr><td>boolean</td><td>false</td><td>1</td><td>true\false</td><td>boolean flag=true;</td></tr></tbody></table></blockquote><p><strong>java有8种基本类型，请问byte、int、long、char、float、double、boolean各占多少个字节？</strong></p><ul><li><strong>A：</strong>1 2 8 2 4 8 1</li><li><strong>B：</strong>1 4 8 2 4 8 1</li><li><strong>C：</strong>1 4 4 2 4 4 2</li><li><strong>D：</strong>1 4 4 2 4 8 2</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span></blockquote><p><strong>对于abstract声明的类，下面说法正确的是</strong></p><ul><li><strong>A：</strong>可以实例化</li><li><strong>B：</strong>不可以被继承</li><li><strong>C：</strong>子类为abstract</li><li><strong>D：</strong>只能被继承</li><li><strong>E：</strong>可以被抽象类继承</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：E</span></span><p><strong>解析：</strong></p><p>A：抽象类不能实例化，因为有抽象方法未实现</p><p>B：可以被继承。派生类可以实现抽象方法</p><p>C：子类可以是抽象的，也可以非抽象的</p><p>D：只能被继承说法太肯定，不正确</p><p>E：可以被抽象类继承，也可以被非抽象类继承</p></blockquote><p><strong>（多选）final、finally和finalize的区别中，下述说法正确的有？</strong></p><ul><li><strong>A：</strong>final用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。</li><li><strong>B：</strong>finally是异常处理语句结构的一部分，表示总是执行。</li><li><strong>C：</strong>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源的回收，例如关闭文件等。</li><li><strong>D：</strong>引用变量被final修饰之后，不能再指向其他对象，它指向的对象的内容也是不可变的。</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AB</span></span><p><strong>解析：</strong></p><p>A，D考的一个知识点，final修饰变量，变量的引用（也就是指向的地址）不可变，但是引用的内容可以变（地址中的内容可变）。</p><p>B，finally表示总是执行。但是其实finally也有不执行的时候，但是这个题不要扣字眼。</p><ol><li><p>在try中调用System.exit(0)，强制退出了程序，finally块不执行。</p></li><li><p>在进入try块前，出现了异常，finally块不执行。</p></li></ol><p>C，finalize方法，这个选项错就错在，<strong>这个方法一个对象只能执行一次，只能在第一次进入被回收的队列，而且对象所属于的类重写了finalize方法才会被执行。</strong>第二次进入回收队列的时候，不会再执行其finalize方法，而是直接被二次标记，在下一次GC的时候被GC。</p></blockquote><p><strong>（多选）以下关于final关键字说法错误的是（）</strong></p><ul><li><strong>A：</strong>final是java中的修饰符，可以修饰类、接口、抽象类、方法和属性</li><li><strong>B：</strong>final修饰的类肯定不能被继承</li><li><strong>C：</strong>final修饰的方法不能被重载</li><li><strong>D：</strong>final修饰的变量不允许被再次赋值</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AC</span></span><p><strong>解析：</strong></p><p>1.final修饰变量，则等同于常量</p><p>2.final修饰方法中的参数，称为最终参数。</p><p>3.final修饰类，则类不能被继承</p><p>4.final修饰方法，则方法不能被重写。</p><p>5.final 不能修饰抽象类</p><p>6.final修饰的方法可以被重载 但不能被重写</p></blockquote><p><strong>（多选）下面属于java包装类的是？</strong></p><ul><li><strong>A：</strong>String</li><li><strong>B：</strong>Long</li><li><strong>C：</strong>Character</li><li><strong>D：</strong>Short</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BCD</span></span><p><strong>解析：</strong></p><p>包装类是针对 <strong>基本数据类型</strong> 的。</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table></blockquote><p><strong>（多选）在java中重写方法应遵循规则的包括（）</strong></p><ul><li><strong>A：</strong>访问修饰符的限制一定要大于被重写方法的访问修饰符</li><li><strong>B：</strong>可以有不同的访问修饰符</li><li><strong>C：</strong>参数列表必须完全与被重写的方法相同</li><li><strong>D：</strong>必须具有不同的参数列表</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BC</span></span><p><strong>解析：</strong></p><p>A：错在访问修饰符还可以相等。</p><p><strong>方法重写的规则：</strong></p><hr><ul><li>​    1）参数列表必须完全与被重写方法的相同；     </li><li>​    2）<strong>返回类型必须完全与被重写方法的返回类型相同；（备注:这条信息是标准的重写方法的规则,但是在java1.5 版本之前返回类型必须一样,1.5(包含) 版本之后java放宽了限制,返回类型必须小于或者等于父类方法的返回类型 才有了子类返回类型小于等于父类方法返回类型。</strong>。    </li><li>​       3）访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。     </li><li>​    4）父类的成员方法只能被它的子类重写。     </li><li>​    5）声明为final的方法不能被重写。     </li><li>​    6）声明为static的方法不能被重写，但是能够被再次声明。     </li><li>​    7）子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。     </li><li>​    8）子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。     </li><li>​       9）重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。     </li><li>​    10）构造方法不能被重写。     </li><li>​    11）如果不能继承一个方法，则不能重写这个方法。</li></ul></blockquote><p><strong>以下代码段执行后的输出结果为()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = -<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y = -<span class="number">12</span>;</span><br><span class="line">System.out.println(y % x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A：-1</li><li>B：2</li><li>C：1</li><li>D：-2</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p>取模运算，结果的符号和被除数符号一致，切记切记</p></blockquote><p><strong>（多选）以下关于final关键字说法错误的是</strong></p><ul><li><strong>A：</strong>final是java中的修饰符，可以修饰类、接口、抽象类、方法和属性</li><li><strong>B：</strong>final修饰的类肯定不能被继承</li><li><strong>C：</strong>final修饰的方法不能被重载</li><li><strong>D：</strong>final修饰的变量不允许被再次赋值</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AC</span></span><p><strong>解析：</strong></p><ul><li><p>final修饰类、方法、属性！不能修饰抽象类，因为抽象类一般都是需要被继承的，final修饰后就不能继承了。</p></li><li><p>final修饰的方法不能被重写而不是重载！ </p></li><li><p>final修饰属性，此属性就是一个常量，不能被再次赋值！ </p></li><li><p>final也不能修饰接口，接口可以只能被public&amp;abstract修饰</p></li><li><p>final如果修饰的是基本类型的变量，那么这个变量就表示为一个常数，只能赋值一次，要么在定义时赋值，要么在初始化时赋值；final修饰应用类型的变量是，变量不能再次被赋值意思是变量的地址（引用）不可以被改变，当变量所指向的内容可以被改变。</p></li></ul></blockquote><p><strong>静态内部类不可以直接访问外围类的非静态数据，而非静态内部类可以直接访问外围类的数据，包括私有数据。（ ）</strong></p><ul><li><strong>A：</strong>正确</li><li><strong>B：</strong>错误</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><ol><li><p><strong>静态内部类：</strong></p><ol><li>静态内部类本身可以访问外部的静态资源，包括静态私有资源。但是不能访问非静态资源，可以不依赖外部类实例而实例化。</li></ol></li><li><p><strong>成员内部类：</strong></p><ol><li>成员内部类本身可以访问外部的所有资源，但是自身不能定义静态资源，因为其实例化本身就还依赖着外部类。</li></ol></li><li><p><strong>局部内部类：</strong></p><ol><li>局部内部类就像一个局部方法，不能被访问修饰符修饰，也不能被static修饰。</li><li>局部内部类只能访问所在代码块或者方法中被定义为final的局部变量。</li></ol></li><li><p><strong>匿名内部类：</strong></p><ol><li>没有类名的内部类，不能使用class，extends和implements，没有构造方法。</li></ol><p>​    2.  多用于GUI中的事件处理。</p><p>​    3.  不能定义静态资源</p><p>​    4.  只能创建一个匿名内部类实例。</p><p>​    5. 一个匿名内部类一定是在new后面的，这个匿名类必须继承一个父类或者实现一个接口。</p><p>​    6. 匿名内部类是局部内部类的特殊形式，所以局部内部类的所有限制对匿名内部类也有效。</p></li></ol></blockquote><p><strong>有如下4条语句：()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i01=<span class="number">59</span>;</span><br><span class="line"><span class="keyword">int</span> i02=<span class="number">59</span>;</span><br><span class="line">Integer i03=Integer.valueOf(<span class="number">59</span>);</span><br><span class="line">Integer i04=<span class="keyword">new</span> Integer(<span class="number">59</span>);</span><br></pre></td></tr></table></figure><p><strong>以下输出结果为false的是:</strong></p><ul><li>System.out.println(i01==i02);</li><li>System.out.println(i01==i03);</li><li>System.out.println(i03==i04);</li><li>System.out.println(i02==i04);</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><ul><li>无论如何，Integer与new Integer不会相等。不会经历拆箱过程，</li><li>两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false；java在编译Integer i2 = 128的时候,被翻译成-&gt; Integer i2 = Integer.valueOf(128);而valueOf()函数会对-128到127之间的数进行缓存</li></ul><blockquote><p>Integer.valueOf方法中也有判断，如果传递的整型变量&gt;= -128并且小于127时会返回IntegerCache类中一个静态数组中的某一个对象， 否则会返回一个新的Integer对象,代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li>两个都是new出来的,都为false</li><li>int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比</li></ul></blockquote><p><strong>定义有StringBuffer s1=new StringBuffer(10);s1.append(“1234”)则s1.length()和s1.capacity()分别是多少?</strong></p><ul><li><strong>A：</strong>4   10</li><li><strong>B：</strong>4   4</li><li><strong>C：</strong>10  10</li><li><strong>D：</strong>10  4</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>StringBuffer s = new StringBuffer(x);  x为初始化容量长度</p><p>s.append(“Y”); “Y”表示长度为y的字符串</p><p>length始终返回当前长度即y；</p><p>对于s.capacity()：</p><p>1.当y&lt;x时，值为x</p><p>以下情况，容器容量需要扩展</p><p>2.当x&lt;y&lt;2<em>x+2时，值为 2</em>x+2</p><p>3.当y&gt;2x+2时，值为y</p></blockquote><p><strong>（多选）有关静态初始化块说法正确的是？</strong></p><ul><li><strong>A：</strong>无法直接调用静态初始化块</li><li><strong>B：</strong>在创建第一个实例前或引用任何静态成员之前，将自动调用静态初始化块来初始化</li><li><strong>C：</strong>静态初始化块既没有访问修饰符，也没有参数</li><li><strong>D：</strong>在程序中，用户可以控制合适执行静态初始化块</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ABC</span></span><p><strong>解析：</strong></p><p><strong>java对象初始化顺序</strong><br>先说结论：</p><ol><li>父类静态代码块，父类静态成员变量（同级，按代码顺序执行）</li><li>子类静态代码块，子类静态成员变量（同级，按代码顺序执行）</li><li>父类普通代码块，父类普通成员变量（同级，按代码顺序执行）</li><li>父类构造方法</li><li>子类普通代码块，子类普通成员变量（同级，按代码顺序执行）</li><li>子类构造方法</li></ol><p>注意点：</p><ol><li>静态内容只在类加载时执行一次，之后不再执行。</li><li>默认调用父类的无参构造方法，可以在子类构造方法中利用super指定调用父类的哪个构造方法。</li></ol></blockquote><p><strong>执行如下程序代码</strong></p><p>char chr = 127;</p><p>int sum = 200;</p><p>chr += 1;</p><p>sum += chr;</p><p>后，sum的值是   ; （     ）</p><p>备注：同时考虑c/c++和Java的情况的话</p><ul><li><strong>A：</strong>72</li><li><strong>B：</strong>99</li><li><strong>C：</strong>328</li><li><strong>D：</strong>327</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span> <p><strong>解析：</strong></p><p>java中只有byte, boolean是一个字节, char是两个字节, 所以对于java来说127不会发生溢出, 输出328</p><p>但是对于c/c++语言来说, char是一个字节, 会发生溢出, 对127加一发生溢出,  0111 1111 –&gt; 1000 0000, 1000 0000为补码-128, 所以结果为200-128=72</p></blockquote><p><strong>下列关于包（package）的描述，正确的是（）</strong></p><ul><li><strong>A：</strong>包（package）是Java中描述操作系统对多个源代码文件组织的一种方式。</li><li><strong>B：</strong>import语句将所对应的Java源文件拷贝到此处执行。</li><li><strong>C：</strong>包（package）是Eclipse组织Java项目特有的一种方式。</li><li><strong>D：</strong>定义在同一个包（package）内的类可以不经过import而直接相互使用。</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span>        <p><strong>解析：</strong></p><p>1、为了更好地组织类，Java提供了包机制。包是类的容器，用于分隔类名空间。如果没有指定包名，所有的示例都属于一个默认的无名包。Java中的包一般均包含相关的类，java是跨平台的，所以java中的包和操作系统没有任何关系，java的包是用来组织文件的一种虚拟文件系统。A错</p><p>2、import语句并没有将对应的java源文件拷贝到此处仅仅是引入，告诉编译器有使用外部文件，编译的时候要去读取这个外部文件。B错<br>3、Java提供的包机制与IDE没有关系。C错<br>4、定义在同一个包（package）内的类可以不经过import而直接相互使用。        </p></blockquote><p><strong>（多选）哪个是不正确的字符常量？</strong></p><ul><li><strong>A：</strong>”\n”</li><li><strong>B：</strong>”1”</li><li><strong>C：</strong>”a”</li><li><strong>D：</strong>”\101”</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ABCD</span></span><p>解析：文字游戏注意是<strong>字符常量（’’）</strong>而不是<strong>字符串常量（””）</strong></p></blockquote><p><strong>（多选）以下关于JAVA语言异常处理描述正确的有？</strong></p><ul><li><strong>A：</strong>throw关键字可以在方法上声明该方法要抛出的异常。</li><li><strong>B：</strong>throws用于抛出异常对象。</li><li><strong>C：</strong>try是用于检测被包住的语句块是否出现异常，如果有异常，则抛出异常，并执行catch语句。</li><li><strong>D：</strong>finally语句块是不管有没有出现异常都要执行的内容。<br>在try块中不可以抛出异常</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：CD</span></span><p><strong>解析：</strong></p><p>Java语言中的异常处理包括声明异常、抛出异常、捕获异常和处理异常四个环节。</p><ul><li><p>throws关键字可以在方法上声明该方法要抛出的异常，然后在方法内部通过throw抛出异常对象。<strong>A选项应该为throws B选项应该为throw</strong>。</p></li><li><p>C选项不严谨，这个异常不是用try抛出来的，而是用了try能检测到底层抛出的异常，然后进行处理。这里应该用“<strong>捕获</strong>”这个异常才对。</p><p>这个“如果有异常，则抛出异常”。在捕获异常的时候使用throw，才会抛出这个异常，否则只是捕获到，而不是抛出。这个是需要显式写出来的。</p><p>但是答案中存在，忽略这个细节。AB错误太明显。</p></li></ul></blockquote><p><strong>下列语句正确的是：</strong></p><ul><li><strong>A：</strong>形式参数可被字段修饰符修饰</li><li><strong>B：</strong>形式参数不可以是对象</li><li><strong>C：</strong>形式参数为方法被调用时真正被传递的参数</li><li><strong>D：</strong>形式参数可被视为local variable</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p><img src="https://image.cclblog.cn/blog/20200623100219.png" alt=""></p></blockquote><p><strong>关于C++/JAVA类中static 成员和对象成员的说法正确的是？</strong></p><ul><li><strong>A：</strong>static 成员变量在对象构造时生成</li><li><strong>B：</strong>static 成员函数在对象成员函数中无法调用</li><li><strong>C：</strong>虚成员函数不可能是static 成员函数</li><li><strong>D：</strong>static 成员函数不能访问static 成员变量</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><ul><li>static为成员变量或函数，在类初始化是加载完成，可以被成员函数调用或访问</li><li>static成员函数既可以通过类名直接调用，也可以通过对象名进行调用</li><li>虚函数是C++中的，虚函数不可能是static的</li><li>static成员函数可以访问static成员变量</li></ul></blockquote><p><strong>给定以下JAVA代码，这段代码运行后输出的结果是（）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aMethod</span><span class="params">(<span class="keyword">int</span> i)</span><span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"exception in a Method"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">"finally"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            aMethod(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.printf(<span class="string">"exception in main"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>exception in main finished</li><li><strong>B：</strong>finally finished</li><li><strong>C：</strong>exception in main finally</li><li><strong>D：</strong>finally exception in main finished</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>题目中是i/10 不是 10/i 绝对不会报异常</p><p>1、finally块一定会执行，无论是否try…catch。</p><p>2、finally前有return，会先执行return语句，并保存下来，再执行finally块，最后return。</p><p>3、finally前有return、finally块中也有return，先执行前面的return，保存下来，再执行finally的return，覆盖之前的结果，并返回。</p></blockquote><p><strong>What is the result?</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.print(c);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] argv )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( foo(<span class="string">'A'</span>); foo(<span class="string">'B'</span>) &amp;&amp; (i &lt; <span class="number">2</span>); foo(<span class="string">'C'</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            i++ ;</span><br><span class="line">            foo(<span class="string">'D'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>ABDCBDCB</li><li><strong>B：</strong>ABCDABCD</li><li><strong>C：</strong>Compilation fails.</li><li><strong>D：</strong>An exception is thrown at runtime.</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>for(条件1;条件2;条件3) {</p><p>​    //语句</p><p>}</p><p>执行顺序是条件1-&gt;条件2-&gt;语句-&gt;条件3-&gt;条件2-&gt;语句-&gt;条件3-&gt;条件2……..</p><p>如果条件2为true，则一直执行。如果条件2位false，则for循环结束21. </p></blockquote><p><strong>Which lines of the following will produce an error?</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="keyword">byte</span> a1 = <span class="number">2</span>, a2 = <span class="number">4</span>, a3;</span><br><span class="line"><span class="number">2</span>. <span class="keyword">short</span> s = <span class="number">16</span>;</span><br><span class="line"><span class="number">3</span>. a2 = s;</span><br><span class="line"><span class="number">4</span>. a3 = a1 * a2;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>Line 3 and Line 4</li><li><strong>B：</strong>Line 1 only</li><li><strong>C：</strong>Line 3 only</li><li><strong>D：</strong>Line 4 only</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>short类型转为byte类型出错</p><p>a1*a2结果为int类型，转为byte类型出错</p><p><strong>java中如果碰到char、byte和short参与运算时，会自动将这些值转换为int类型然后再进行运算。这里a1和a2就自动转为int类型了，结果也为Int类型。把一个int类型赋值给byte需要转型。</strong></p></blockquote><p><strong>What is displayed when the following is executed;</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1=-<span class="number">0.5</span>;</span><br><span class="line">System.out.println(<span class="string">"Ceil d1="</span>+Math.ceil(d1));</span><br><span class="line">System.out.println(<span class="string">"floor d1="</span>+Math.floor(d1));</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>Ceil d1=-0.0<br>floor d1=-1.0</li><li><strong>B：</strong>Ceil d1=0.0<br>floor d1=-1.0</li><li><strong>C：</strong>Ceil d1=-0.0<br>floor d1=-0.0</li><li><strong>D：</strong>Ceil d1=0.0<br>floor d1=0.0</li><li><strong>E：</strong>Ceil d1=0<br>floor d1=-1</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p><strong>ceil：天花板数，向上取整。</strong></p><p><strong>floor：地板数，向下取整</strong></p><p>这里主要是有一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Math.ceil(d1) `</span><br></pre></td></tr></table></figure><p>ceil 方法上有这么一段注释：If the argument value is less than zero but greater than -1.0, then the result is negative zero</p><p>如果参数小于0且大于-1.0，结果为 -0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Math.floor(d1)`</span><br></pre></td></tr></table></figure><p>ceil 和 floor 方法 上都有一句话：If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as  the argument，意思为：如果参数是 NaN、无穷、正 0、负 0，那么结果与参数相同，</p><p>如果是 -0.0，那么其结果是 -0.0</p></blockquote><p><strong>java中将ISO8859-1字符串转成GB2312编码，语句为 ？</strong>  </p><ul><li><strong>A：</strong>new String(“ISO8859-1”.getBytes(“ISO8859-1”),”GB2312”)</li><li><strong>B：</strong>new String(String.getBytes(“GB2312”）, ISO8859-1)</li><li><strong>C：</strong>new String(String.getBytes(“ISO8859-1”))</li><li><strong>D：</strong>new String(String.getBytes(“GB2312”))</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>注意这里”ISO8859-1”是一个普通字符串，不要被迷惑了</p><p>new String(“这是要转换的字符串”.getBytes(“ISO-8859-1”), “GB2312”);</p></blockquote><p><strong>（多选）已知String a=”a”,String b=”b”,String c=a+b,String d=new String(“ab”) 以下操作结果为true的是</strong></p><ul><li><strong>A：</strong>(a+b).equals(c)</li><li><strong>B：</strong>a+b==c</li><li><strong>C：</strong>c==d</li><li><strong>D：</strong>c.equals(d)</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AD</span></span><p><strong>解析：</strong></p><p>1.== 和 equals():</p><p>(1)“==” 用于比较基本数据类型时比较的是值，用于比较引用类型时比较的是引用指向的地址。</p><p>(2)Object 中的equals() 与 “==” 的作用相同，但String类重写了equals()方法，比较的是对象中的内容。</p><p>2.String对象的两种创建方式:</p><p>(1)第一种方式: String str1 = “aaa”;  是在常量池中获取对象(“aaa” 属于字符串字面量，因此编译时期会在常量池中创建一个字符串对象，如果常量池中已经存在该字符串对象则直接引用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>3.String类型的常量池比较特殊。它的主要使用方法有两种</p><p>(1)直接使用双引号声明出来的String对象会直接存储在常量池中。</p><p>(2)如果不是用双引号声明的String对象,可以使用 String 提供的 intern 方法。 String.intern() 是一个 Native 方法，它的作用是： 如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用； 如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"AAA"</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 = <span class="string">"AAA"</span>;</span><br><span class="line">System.out.println(s2);<span class="comment">//AAA</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false，因为一个是堆内存中的String对象一个是常量池中的String对象，</span></span><br><span class="line">System.out.println(s2 == s3);<span class="comment">//true， s1,s2指向常量池中的”AAA“</span></span><br></pre></td></tr></table></figure><p>4字符串拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"a"</span>;</span><br><span class="line">String b = <span class="string">"b"</span>;</span><br><span class="line">  </span><br><span class="line">String str1 = <span class="string">"a"</span> + <span class="string">"b"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">String str2 = a + b; <span class="comment">//在堆上创建的新的对象     </span></span><br><span class="line">String str3 = <span class="string">"ab"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//true </span></span><br><span class="line">System.out.println(str2 == str3);<span class="comment">//false</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>对于java类型变量char c,short s,float f,double d,表达式c*s+f+d的结果类型为（）</strong></p><ul><li><strong>A：</strong>float</li><li><strong>B：</strong>char</li><li><strong>C：</strong>short</li><li><strong>D：</strong>double</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p><strong>基本数据类型的运算，会自动向上转型。boolean不可以和其他基本数据类型相互转换。</strong></p><p><strong>byte-&gt;short,char -&gt; int -&gt; long</strong>      </p><p><strong>float -&gt; double</strong></p><p><strong>int -&gt; float</strong></p><p><strong>long -&gt; double</strong></p><p><img src="https://image.cclblog.cn/blog/20200622161949.png" alt=""></p></blockquote><p><strong>在运行时，由java解释器自动引入，而不用import语句引入的包是()。</strong></p><ul><li><strong>A：</strong>java.lang</li><li><strong>B：</strong>java.system</li><li><strong>C：</strong>java.io</li><li><strong>D：</strong>java.util</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>java.lang包是java语言的核心包，lang是language的缩写</p><p>java.lang包定义了一些基本的类型，包括Integer,String之类的，是java程序必备的包，有解释器自动引入，无需手动导入</p></blockquote><p><strong>由3 个“1”和 5 个“0”组成的 8 位二进制补码，能表示的最小整数（）</strong></p><ul><li><strong>A：</strong>-126</li><li><strong>B：</strong>-125</li><li><strong>C：</strong>-32</li><li><strong>D：</strong>-3</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>既然求最小整数，那肯定先想到负数，则最高位（符号位）一定为1，原码中肯定是1所在的位数越高，值越小，而补码是由原码取反加1（符号位不变）得到的，则在补码中1所在的位数一定要越低，即补码为1000 0011；由补码求得原码：1111 1101=-(64+32+16+8+4+1)=-125;</p></blockquote><p><strong>关于访问权限，说法正确的是？ ( )</strong></p><ul><li><strong>A：</strong>类A和类B在同一包中，类B有个protected的方法testB，类A不是类B的子类（或子类的子类），类A可以访问类B的方法testB</li><li><strong>B：</strong>类A和类B在同一包中，类B有个protected的方法testB，类A不是类B的子类（或子类的子类），类A不可以访问类B的方法testB</li><li><strong>C：</strong>访问权限大小范围：public &gt; 包权限 &gt; protected &gt; private</li><li><strong>D：</strong>访问权限大小范围：public &gt; 包权限 &gt; private &gt; protected</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p><img src="https://image.cclblog.cn/blog/20200622110227.jpg" alt=""></p></blockquote><p><strong>以下程序程序运行后的输出结果是（）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">12</span>,n=<span class="number">34</span>;</span><br><span class="line">    System.out.printf(<span class="string">"%d%d"</span>,m++,++n);</span><br><span class="line">    System.out.printf(<span class="string">"%d%d\n"</span>,n++,++m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>12353514</li><li><strong>B：</strong>12353513</li><li><strong>C：</strong>12343514</li><li><strong>D：</strong>12343513</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p><strong>不要忘记前面已经自加过后，变量的值已经改变了（明白了这个肯定就没问题了）</strong></p><p>​          第一个输出：m++值：12，m的值：13</p><p>​                              ++n值：35，n的值：35</p><p>​          第一个输出：n++值：35，n的值：36</p><p>​                              ++m值：14，n的值：14</p><p>​          故最终输出：12353514</p></blockquote><p><strong>在jdk1.8之前，下列哪一种叙述是正确的（ ）</strong></p><ul><li><strong>A：</strong>abstract修饰符可修饰字段、方法和类</li><li><strong>B：</strong>抽象方法的body部分必须用一对大括号{ }包住</li><li><strong>C：</strong>声明抽象方法，大括号可有可无</li><li><strong>D：</strong>声明抽象方法不可写出大括号</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style=""> 查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p>A:abstract修饰方法和类</p><p>B、C:抽象方法没有方法体，有没有方法体看有没有大括号。</p></blockquote><p><strong>以下不是修饰符final的作用的是( )。</strong></p><ul><li><strong>A：</strong>修饰常量</li><li><strong>B：</strong>修饰不可被继承的类</li><li><strong>C：</strong>修饰不可变类</li><li><strong>D：</strong>修饰不可覆盖的方法</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p>final的作用：</p><p>​    1. 修饰变量，变量的引用地址不可变，但是地址中的内容可以变。</p><p>​    2. 修饰方法，方法不可被重写，但是还是可以重载</p><p>​    3. 修饰类，类不可继承。</p><p><strong>不可变类：</strong>说的是一个类一旦被实例化，就不可改变自身的状态。常见的比如String和基本数据类型的包装类，对于这种不可变类，一旦在进行引用传递的时候，形参一开始就和实际参数指向的不是一个地址，所以在方法中对形参的改变，并不会影响实际参数。</p></blockquote><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><p><strong>在一个基于分布式的游戏服务器系统中，不同的服务器之间，哪种通信方式是不可行的（）？</strong></p><ul><li><strong>A：</strong>管道</li><li><strong>B：</strong>消息队列</li><li><strong>C：</strong>高速缓存数据库</li><li><strong>D：</strong>套接字</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p><strong>管道( pipe )：</strong>管道是一种半双工的通信方式，数据只能单向流动，<strong>而且只能在具有亲缘关系的进程间使用</strong>。进程的亲缘关系通常是指父子进程关系。</p><p><strong>既然是不同的服务器之间进行通信，怎么可能会是具有亲缘关系的进程呢？</strong></p></blockquote><p><strong>以下哪个式子有可能在某个进制下成立（）？</strong></p><ul><li><strong>A：</strong>13  * 14=204</li><li><strong>B：</strong>12 * 34=568</li><li><strong>C：</strong>14*14=140</li><li><strong>D：</strong>1+1=3</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>A:  假设为x进制</p><p>13用10进制表示为 1 * x^1 + 3 * x ^ 0 =  x + 3</p><p>同理 14 ：x + 4 </p><p>204：2x^2 + 4</p><p>(x + 3)(x + 4 ) = 2x^2 + 4</p><p>解得 x1 = 8 x2 = -1</p><p>BCD同理可计算</p></blockquote><p><strong>以下JAVA程序代码的输出是</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="number">17</span>^<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>12</li><li><strong>B：</strong>22</li><li><strong>C：</strong>20</li><li><strong>D：</strong>1419857</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p>位异运算符号。</p><p>运算规则是：两个数转为二进制，然后从高位开始比较，如果相同则为0，不相同则为1。</p><p>17：0001 0001 </p><p>5：  0000 0101</p><p>结果：0001 0100 转10进制：20</p></blockquote><p><strong>变量a是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF;变量b是一个64位有符号的整数，初始值用16进制表示为：0x8000000000000000。则a+b的结果用10进制表示为多少？</strong></p><ul><li><strong>A：</strong>1</li><li><strong>B：</strong>-1</li><li><strong>C：</strong>2^63+2^62+…+2^2+2^1+2^0</li><li><strong>D：</strong>–(2^63+2^62+…+2^2+2^1+2^0)</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>0x7FFFFFFFFFFFFFFF +  0x8000000000000000 =  0xFFFFFFFFFFFFFFFF</p><p>（1）a+b的16进制表示为：OxFFFFFFFFFFFFFFF（16位F），转为2进制为111……111（64位1，每个F-&gt;4位2进制）。</p><p>（2）有符号数：是针对二进制来讲的。用最高位作为符号位，“0”代表“+”，“1”代表“-”。所以a+b的结果是一个负数。</p><p>（3）计算机中负数是以补码的形式保存的，将补码转换成原码的计算方式如下：</p><p>​        ①. 对于正数，原码与补码相同。</p><p>​        ②.对于负数：</p><p>​                （1）<strong>符号位保持不变</strong>，按位取反，末位加1，即得到原码。</p><p>​                （2）<strong>符号位保持不变</strong>，先-1，然后其他位按位取反            </p><p>​                    这两种方法都可以    </p><p>（4）a + b = 111……111（64位1）</p><p>​          取反：100……000（1位1，后面63位0）</p><p>​          加一：100……00（中间62位0）</p><p>​      结果10进制：-1。</p></blockquote><p><strong>存根（Stub）与以下哪种技术有关</strong> </p><ul><li><strong>A：</strong>交换</li><li><strong>B：</strong>动态链接</li><li><strong>C：</strong>动态加载</li><li><strong>D：</strong>磁盘调度</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>存根类是一个类，它实现了一个接口，它的作用是：如果一个接口有很多方法，如果要实现这个接口，就要实现所有的方法。但是一个类从业务来说，可能只需要其中一两个方法。如果直接去实现这个接口，除了实现所需的方法，还要实现其他所有的无关方法。而如果通过继承存根类就实现接口，就免去了这种麻烦。<br>RMI 采用stubs 和 skeletons 来进行远程对象(remote object)的通讯。stub 充当远程对象的客户端<strong>，有着和远程对象相同的远程接口，远程对象的调用实际是通过调用该对象的客户端</strong>对象stub来完成的。<br>每个远程对象都包含一个<strong>对象stub，当运行在本地Java虚拟机上的程序调用运行在远程Java虚拟机上的对象方法时，它首先在本地创建该对象的</strong>对象stub, 然后调用对象上匹配的方法。每一个远程对象同时也包含一个skeleton对象，skeleton运行在远程对象所在的虚拟机上，接受来自stub对象的调用。这种方式符合等到程序要运行时将目标文件动态进行链接的思想</p></blockquote><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><strong>（多选）关于java集合下列说法不正确的有哪些（）</strong></p><ul><li><strong>A：</strong>HashSet 它是线程安全的，不允许存储相同的对象</li><li><strong>B：</strong>ConcurrentHashMap 它是线程安全的，其中存储的键对象可以重复，值对象不能重复</li><li><strong>C：</strong>Collection接口是List接口和Set接口的父接口，通常情况下不被直接使用</li><li><strong>D：</strong>ArrayList线程安全的，允许存放重复对象</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ABD</span></span><p><strong>解析：</strong></p><p><strong>注意：常见并非全部</strong></p><p><strong>线程安全(Thread-safe)的集合对象：</strong></p><ul><li>Vector 线程安全：</li><li>HashTable 线程安全：</li><li>StringBuffer 线程安全：</li></ul><p><strong>非线程安全的集合对象：</strong></p><ul><li>ArrayList ：</li><li>LinkedList：</li><li>HashMap：</li><li>HashSet：</li><li>TreeMap：</li><li>TreeSet：</li><li>StringBulider：</li></ul></blockquote><p><strong>list是一个ArrayList的对象，哪个选项的代码填到//todo delete处，可以在Iterator遍历的过程中正确并安全的删除一个list中保存的对象？（）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = list.iterator();</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">    Object obj = it.next();</span><br><span class="line">    <span class="keyword">if</span> (needDelete(obj))  <span class="comment">//needDelete返回boolean，决定是否要删除</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//todo delete</span></span><br><span class="line">    &#125;</span><br><span class="line">    index ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>it.remove();</li><li><strong>B：</strong>list.remove(obj);</li><li><strong>C：</strong>list.remove(index);</li><li><strong>D：</strong>list.remove(obj,index);</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>源码是这么描述的：<strong>ArrayList</strong> 继承了 <strong>AbstractList，</strong> 其中<strong>AbstractList</strong> 中有个<strong>modCount</strong> 代表了集合修改的次数。在<strong>ArrayList的iterator方法中会判断</strong> <strong>expectedModCount与</strong> <strong>modCount是否相等，如果相等继续执行，不相等报错，只有iterator的remove方在调用自身的remove之后让</strong> <strong>expectedModCount与modCount再相等，所以是安全的。</strong></p></blockquote><p><strong>（多选）Hashtable 和 HashMap 的区别是：</strong></p><ul><li><strong>A：</strong>Hashtable 是一个哈希表，该类继承了 AbstractMap，实现了 Map 接口</li><li><strong>B：</strong>HashMap 是内部基于哈希表实现，该类继承AbstractMap，实现Map接口</li><li><strong>C：</strong>Hashtable 线程安全的，而 HashMap 是线程不安全的</li><li><strong>D：</strong>Properties 类 继承了 Hashtable 类，而 Hashtable 类则继承Dictionary 类</li><li><strong>E：</strong>HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BCDE</span></span><p><strong>解析：</strong></p><p><strong>Hashtable</strong>：</p><p>（1）Hashtable 是一个散列表，它存储的内容是键值对(key-value)映射。</p><p>（2）Hashtable 的函数都是同步的，这意味着它是<strong>线程安全</strong>的。它的key、value都不可以为null。</p><p>（3）HashTable直接使用对象的hashCode。</p><p><strong>HashMap：</strong></p><p>（1）由<strong>数组+链表</strong>(jdk1.8以前)组成的，基于<strong>哈希表的Map</strong>实现，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</p><p>（2）不是线程安全的，HashMap可以接受为null的键(key)和值(value)。</p><p>（3）HashMap重新计算hash值</p><p><strong>Hashtable,HashMap,Properties</strong>继承关系如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Properties</span> <span class="keyword">extends</span> <span class="title">Hashtable</span>&lt;<span class="title">Object</span>,<span class="title">Object</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Objecct</span><br><span class="line">java.util.Dictionary&lt;K,V&gt;</span><br><span class="line"> java.util.Hashtable&lt;Object,Object&gt;</span><br><span class="line">   java.util.Properties </span><br></pre></td></tr></table></figure></blockquote><p><strong>(多选)对</strong> <strong>Map</strong> <strong>的用法，正确的有：</strong></p><ul><li><strong>A：</strong>new java.util.Map().put(“key” , “value”) ;</li><li><strong>B：</strong>new java.util.SortedMap().put(“key” , “value”) ;</li><li><strong>C：</strong>new java.util.HashMap().put( null , null ) ;</li><li><strong>D：</strong>new java.util.TreeMap().put( 0 , null ) ;</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：CD</span></span><p><strong>解析：</strong></p><p>选C、D。考察的是<strong>Map接口</strong>实现类的<strong>创建对象</strong>以及对象类型包含的<strong>方法</strong>。</p><p>A选项<strong>Map属于接口类型</strong>，不可以new的方式创建对象。所以A错误。</p><p>B选项<strong>SortedMap属于接口类型</strong>，不可以new的方式创建对象。所以B错误。</p><p>C选项<strong>HashMap</strong>基于哈希表实现Map接口的类，<strong>并允许null的值和null键</strong>。</p><p>D选项<strong>TreeMap</strong>通过红黑树实现Map接口的类，key不可以为null，会报<strong>NullPointerException</strong>异常,value可以为null。</p></blockquote><p><strong>（多选）以下哪些继承自 Collection 接口（）</strong></p><ul><li><strong>A：</strong>List</li><li><strong>B：</strong>Set</li><li><strong>C：</strong>Map</li><li><strong>D：</strong>Array</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AB</span></span><p><strong>解析：</strong></p><p>├List</p><p>​    │├LinkedList</p><p>​    │├ArrayList</p><p>​    │└Vector</p><p>​        │└Stack</p><p>└Set</p><p>Map</p><p>​    ├Hashtable</p><p>​    ├HashMap</p><p>​    └WeakHashMap</p></blockquote><p><strong>（多选）下面哪些类实现或继承了 Collection 接口？</strong></p><ul><li>A：HashMap</li><li>B：ArrayList</li><li>C：Vector</li><li>D：Iterator</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BC</span></span><p><strong>解析：</strong></p><p><img src="https://image.cclblog.cn/blog/20200623094232.png" alt=""></p></blockquote><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><strong>（多选）在Java线程状态转换时，下列转换不可能发生的有（）？</strong></p><ul><li><strong>A：</strong>初始态-&gt;运行态</li><li><strong>B：</strong>就绪态-&gt;运行态</li><li><strong>C：</strong>阻塞态-&gt;运行态</li><li><strong>D：</strong>运行态-&gt;就绪态</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AC</span></span><p><strong>解析：</strong></p><p><img src="https://image.cclblog.cn/blog/20200624171403.jpg" alt=""></p></blockquote><p><strong>（多选）Java.Thread的方法resume()负责重新开始被以下哪个方法中断的线程的执行（）。</strong></p><ul><li><strong>A：</strong>stop</li><li><strong>B：</strong>sleep</li><li><strong>C：</strong>wait</li><li><strong>D：</strong>suspend</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p>resume与suspended一起使用<br>wait与notify/notifyAll一起使用<br>sleep会让线程暂时不执行</p><p><strong>Thread类的suspend（）和resume（）方法都已经被声明已废弃了</strong></p></blockquote><p><strong>下列程序的运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            pong();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.run();</span><br><span class="line">    System.out.print(<span class="string">"ping"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"pong"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>pingpong</li><li><strong>B：</strong>pongping</li><li><strong>C：</strong>pingpong和pongping都有可能</li><li><strong>D：</strong>都不输出</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>这里需要注意Thread的start和run方法</p><p>用start方法才能真正启动线程，此时线程会处于就绪状态，一旦得到时间片，则会调用线程的run方法进入运行状态。</p><p>而run方法只是普通方法，如果直接调用run方法，程序只会按照顺序执行主线程这一个线程。</p></blockquote><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p><strong>BufferedReader的父类是以下哪个？</strong></p><ul><li><strong>A：</strong>FilterReader</li><li><strong>B：</strong>InputStreamReader</li><li><strong>C：</strong>PipedReader</li><li><strong>D：</strong>Reader</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p><img src="https://image.cclblog.cn/blog/20200625205640.png" alt=""></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 题集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 题集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java习题整理</title>
      <link href="/2020/06/22/java/theme/question/"/>
      <url>/2020/06/22/java/theme/question/</url>
      
        <content type="html"><![CDATA[<ol><li><a href="/2020/06/22/java/question/1/">6-22</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> JAVA </category>
          
          <category> 题集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> JAVA </tag>
            
            <tag> 题集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法区</title>
      <link href="/2020/06/20/java/jvm/2-7/"/>
      <url>/2020/06/20/java/jvm/2-7/</url>
      
        <content type="html"><![CDATA[<h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法区</title>
      <link href="/2020/06/19/java/jvm/2-6/"/>
      <url>/2020/06/19/java/jvm/2-6/</url>
      
        <content type="html"><![CDATA[<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><ul><li>方法区（Method Area）和Java堆一样，是各个线程共享的内存区域。</li><li>《Java虚拟机规范》当中把方法区描述为堆的一个逻辑部分，但是它有一个别名叫<strong>“非堆”</strong>，目的是与Java堆区分开来。</li><li>jdk7以前，把方法区称为永久代。jdk8开始，使用元空间取代了永久代。</li></ul><blockquote><p>jdk7把原本存放在永久代的字符串常量池，静态变量等移到了堆中，直到jdk8才用元空间（Metaspace）替代了永久代，元空间在本地内存中。之所以放入本地内存我感觉就是加大了方法区的内存，避免了很多由于类加载过多导致的OOM。</p></blockquote><ul><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，就会导致OOM。</li><li>方法区同样存在垃圾收集。</li></ul><blockquote><p>这个垃圾收集的条件很苛刻也就为什么说是永久代一样，永久存在了，后续说明。</p></blockquote><h2 id="方法区大小设置"><a href="#方法区大小设置" class="headerlink" title="方法区大小设置"></a>方法区大小设置</h2><p><strong>jdk7以前：</strong></p><ul><li><p>-XX:PermSize来设置永久代初始内存大小 默认20.75M</p></li><li><p>-XX:MaxPermiSize来设置永久代最大可分配空间。32位机器默认64M，64位机器82M</p></li></ul><blockquote><p>JVM加载的类信息容量超出最大值会报OutOfMemoryError:PermGen space</p></blockquote><p><strong>jdk8以后：</strong></p><ul><li>-XX:MetspaceSize和-XX:MaxMetaspaceSize设置元数据区大小。</li></ul><blockquote><p>windows下，-XX:MetspaceSize 默认为21M，-XX:MaxMetaspaceSize默认为<strong>-1</strong>就是没有限制。(这个-1我参考网上的都说的-1，但是我看自己的程序的默认参数不是-1。反正这个了解就好，没必要去记这个)</p><p>内存溢出错误<strong>java.lang.OutOfMemoryError:Metaspace</strong></p></blockquote><p><img src="https://image.cclblog.cn/blog/20200619153032.png" alt=""></p><h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><p>方法区保存着被加载过的每一个类的信息，这些信息由类加载器在加载类的时候，从类的源文件抽取出来。</p><blockquote><p>方法区保存的起始就是每个类的一个模板，Class的元数据。</p></blockquote><p><strong>这些信息有：</strong></p><p><img src="https://image.cclblog.cn/blog/20200619202435.png" alt=""></p><blockquote><p><strong>这些信息没有一个统一的标准，网上说什么的都有，这是我自己综合整理，我感觉这个比较全面。仅供参考啊</strong></p></blockquote><h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>对于每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p><ul><li>类的完整有效名称（包名.类名）</li></ul><blockquote><p>比如java.lang.String</p></blockquote><ul><li><p>类的直接父类的完整有效名</p></li><li><p>类型直接实现接口的有序列表</p></li></ul><blockquote><p>一个类实现的接口可能有多个，多以存放在有序列表中。</p></blockquote><ul><li>类的修饰符</li></ul><blockquote><p>比如public abstract</p></blockquote><hr><blockquote><p>这个就像是查户口一样，看一下你家的详细地址（类的完整有效名称），你的父亲是谁（父类完整有效名称），你的工作（你实现的哪些接口），还有你是什么人（类的修饰符）。</p></blockquote><h3 id="字段信息"><a href="#字段信息" class="headerlink" title="字段信息"></a>字段信息</h3><ul><li>字段修饰符（public、protect、private、default）</li><li>字段声明的顺序</li><li>字段的类型</li><li>字段的名称</li></ul><h3 id="方法信息"><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h3><ul><li>方法名称</li><li>方法的返回类型（包括void）</li><li>方法参数的类型、数目和顺序</li><li>方法的修饰符（public、private、protected、static、final、synchronized、native、abstract）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外）</li></ul><blockquote><p>前面从未说过异常表这次详细分析</p><p>包括异常处理的<strong>开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获异常类的常量池索引</strong></p></blockquote><p><img src="https://image.cclblog.cn/blog/20200619164030.png" alt=""></p><h3 id="类的常量池-运行时常量池"><a href="#类的常量池-运行时常量池" class="headerlink" title="类的常量池/运行时常量池"></a>类的常量池/运行时常量池</h3><p><img src="https://image.cclblog.cn/blog/20200619173204.png" alt=""></p><h4 id="类常量池-静态常量池"><a href="#类常量池-静态常量池" class="headerlink" title="类常量池(静态常量池)"></a>类常量池(静态常量池)</h4><p><img src="https://image.cclblog.cn/blog/20200619180101.png" alt=""></p><ul><li>class常量池用于存储编译器生成的各种<strong>字面量</strong>和<strong>符号引用</strong>。 </li></ul><p><img src="https://image.cclblog.cn/blog/20200619201759.png" alt=""></p><blockquote><p>红色的这几个我仅仅了解，无法说清楚，待我日后补充，其它的三种是网上常见的，并且只有这三种，基本上都是这样，我是参考《深入理解Java虚拟机》第三版 p218。</p></blockquote><ul><li>每个class文件都有一个class常量池。</li></ul><h4 id="运行时常量池-动态常量池"><a href="#运行时常量池-动态常量池" class="headerlink" title="运行时常量池(动态常量池)"></a>运行时常量池(动态常量池)</h4><ul><li>方法区的一部分</li><li>常量池表是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。</li><li>运行时常量池包含多种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里变为了真实地址。</li></ul><blockquote><p>实际上在解析阶段只有能确定唯一版本的方法才能将符号引用直接替换为直接引用，这里也就是前面的章节说过的非虚方法。</p><p>Byte，Short，Integer，Long，Character，Boolean这5中包装类默认创建了数值[-128,127]的相应类型的缓存数据，但是超过此范围仍然回去创建新的对象。这也就是包装类比较是否相等要使用equals()。（Double，Float没有实现常量池技术）</p></blockquote><ul><li>运行时常量池相对于Class文件常量池的另外一个特征就是具备动态性。</li></ul><blockquote><p>String.intern()方法 </p></blockquote><h3 id="非final修饰的类变量"><a href="#非final修饰的类变量" class="headerlink" title="非final修饰的类变量"></a>非final修饰的类变量</h3><ul><li>静态变量和类是关联在一起的，随着类的加载而加载。</li><li>类变量被类的所有实例共享，即使没有类实例时也可以访问。</li></ul><blockquote><p><strong>final型变量的值是在编译期就被确定了，因此被保存在常量池中。</strong></p></blockquote><h3 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h3><ul><li><p>jvm必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么jvm会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。</p></li><li><p>jvm在动态链接的时候需要这个信息。当解析一个类型到另一个类型的引用的时候，jvm需要保证这两个类型的类加载器是相同的。这对jvm区分名字空间的方式是至关重要的。</p></li><li><p>比较两个类是否相等也需要比较类加载器是否是相同的。</p></li><li><p>垃圾收集的时候也需要参考这个类的加载器是否不再使用！</p></li></ul><h3 id="对Class类的引用"><a href="#对Class类的引用" class="headerlink" title="对Class类的引用"></a>对Class类的引用</h3><p>jvm为每个加载的类都创建一个java.lang.Class的实例（<strong>存储在堆上</strong>）。而jvm必须以某种方式把Class的这个实例和存储在方法区中的类型数据联系起来， 因此，类的元数据里面保存了一个Class对象的引用；</p><h3 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h3><blockquote><p><strong>引用：</strong></p><p>为了提高访问效率，必须仔细的设计存储在方法区中的数据信息结构。除了以上讨论的结构，jvm的实现者还可以添加一些其他的数据结构，如方法表。jvm对每个加载的非虚拟类的类型信息中都添加了一个方法表，方法表是一组对类实例方法的直接引用(包括从父类继承的方法。jvm可以通过方法表快速激活实例方法。(译者：这里的方法表与C++中的虚拟函数表一样，但java方法全都 是virtual的，自然也不用虚拟二字了。正像java宣称没有 指针了，其实java里全是指针。更安全只是加了更完备的检查机制，但这都是以牺牲效率为代价的,个人认为java的设计者 始终是把安全放在效率之上的，所有java才更适合于网络开发)</p></blockquote><h2 id="栈、堆、方法区的交互"><a href="#栈、堆、方法区的交互" class="headerlink" title="栈、堆、方法区的交互"></a>栈、堆、方法区的交互</h2><p><img src="https://image.cclblog.cn/blog/20200619211848.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础知识点</title>
      <link href="/2020/06/18/java/theme/javase/"/>
      <url>/2020/06/18/java/theme/javase/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA基础知识点"><a href="#JAVA基础知识点" class="headerlink" title="JAVA基础知识点"></a>JAVA基础知识点</h1><ol><li><a href="/java/javase/2020/06/16/1">重载和重写</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机栈</title>
      <link href="/2020/06/17/java/jvm/2-3/"/>
      <url>/2020/06/17/java/jvm/2-3/</url>
      
        <content type="html"><![CDATA[<h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><ul><li>本地方法栈与虚拟机栈所发挥的作用是非常相似的，区别就是虚拟机栈执行Java方法，本地方法栈为本地（Native）方法服务。</li></ul><blockquote><p>native方法是Java通过JNI（java native interface）直接调用本地C/C++库，这个就相当于C/C++暴露给Java的一个接口，Java 通过调用这个接口从而调用到 C/C++ 方法。</p></blockquote><ul><li>本地方法栈线程私有的。</li><li>本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。</li><li>它的具体做法就是本地方法栈登记native方法，在执行引擎执行时候加载本地方法库。</li></ul><blockquote><p>当调用的是 native 方法时，虚拟机会保持 Java 虚拟机栈不变，也不会向 Java 虚拟机栈中压入新的栈帧，虚拟机只是简单地动态连接并直接调用指定的 native 方法</p></blockquote><ul><li><strong>Hotspot虚拟机中，直接将本地方法栈和虚拟机栈合二为一。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆</title>
      <link href="/2020/06/17/java/jvm/2-5/"/>
      <url>/2020/06/17/java/jvm/2-5/</url>
      
        <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><ul><li>Java堆是虚拟机所管理内存最大的一块区域，并且一个JVM实例只有一个堆，堆是Java内存管理的核心区域。</li><li>Java堆是被所有线程共享的，但是Java堆中还可以划分线程私有的缓冲区（Thread Local Allocation Buffer， TLAB），用来提高对象分配时的效率。</li><li><strong>Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</strong></li><li>Java的程序中，“几乎”所有的对象实例都在这里分配内存。</li></ul><blockquote><p>这里有特殊情况 逃逸分析技术的日渐强大 <strong>栈上分配、标量替换</strong>（后续说明）导致了”几乎”这一情况的发生</p></blockquote><ul><li>方法结束后，堆中的对象不会马上移除，仅仅在垃圾收集的时候才会被移除。</li><li>堆是垃圾收集的重点对象。</li></ul><p><img src="https://image.cclblog.cn/blog/20200617172417.png" alt=""></p><h2 id="堆空间内部结构"><a href="#堆空间内部结构" class="headerlink" title="堆空间内部结构"></a>堆空间内部结构</h2><p><img src="https://image.cclblog.cn/blog/20200617174629.png" alt=""></p><blockquote><p>我认为之所以这种分代设置都是为了方便垃圾收集，基于分代思想，一个应用程序中对象的声明周期不尽相同，每次垃圾回收肯定不能堆空间全部扫描，这样效率太低了，所以才有了对象分代这个思想，不是为了分代而分代，而是为了程序更好的性能，就像不是为了多线程而去盲目使用多线程，而是根据实际情况来使用，一切都要考虑实际情况。</p></blockquote><p><strong>这里不讨论永久代（元空间）！</strong></p><h3 id="年轻代、老年代"><a href="#年轻代、老年代" class="headerlink" title="年轻代、老年代"></a>年轻代、老年代</h3><blockquote><p>存储在JVM中的Java对象有两类：</p><ol><li>一类是生命周期特别短，就像是你写的普通方法中声明的局部变量，大部分都是这样的情况，这类对象创建和消亡都十分迅速。</li><li>另一类对象的声明周期十分的长，这样的对象一般存放在老年代。</li></ol></blockquote><ul><li>几乎所有的Java对象都是在Eden区被new出来的。</li><li>绝大部分的Java对象的销毁都是在新生代进行的。</li><li>“-Xmn参数可以设置新生代最大内存大小”</li></ul><h2 id="设置堆内存大小"><a href="#设置堆内存大小" class="headerlink" title="设置堆内存大小"></a>设置堆内存大小</h2><ul><li>堆的大小在JVM启动时就已经设定好了，可以通过选项“-Xmx”和“-Xms”来进行设置。</li></ul><blockquote><p>“-Xms”用于表示堆区的起始内存，等价于-XX:InittalHeapSize</p><p>“-Xmx”用于表示堆区的最大内存，等价于-XX:MaxHeapSize</p></blockquote><ul><li><p>堆中的内存大小超过“-Xmx“指定的最大内存的时候，就会抛出OutOfMemoryError异常。</p></li><li><p><strong>一般会将-Xms和-Xmx两个参数配置相同的值，目的是为了能够在java垃圾回收机制清理完堆区后不需要重新计算堆区的大小，从而提高性能。</strong></p></li><li><p>默认情况下，初始内存大小：物理电脑内存大小/64；最大内存大小：物理电脑内存大小/4；</p></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Test&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Test());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/blog/20200617181558.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200617181719.png" alt=""></p><blockquote><p>这个结果很明显了正常情况下程序肯定不会OOM -Xms -Xmx 改变了堆的大小，导致这一情况发生。</p></blockquote><h2 id="对象分配的过程"><a href="#对象分配的过程" class="headerlink" title="对象分配的过程"></a>对象分配的过程</h2><ol><li>new的对象先放到Eden区，如果超大对象直接分配到老年代。</li><li>当Eden区空间填满时，创建新的对象，就会触发JVM的垃圾回收机制，对新生区进行垃圾回收（Minor GC），然后在加载新的对象放到Eden区。</li><li>将Eden区中剩余的对象移动到幸存者0区。</li><li>如果再次触发垃圾回收机制，幸存的对象（包括幸存者0区的对象）会全部放入幸存者1区。如此反复</li><li>当一个对象经历15次这样的操作后，历经磨难，就会进入养老区。</li></ol><blockquote><p>15次只是JVM一个默认值，-XX:MaxTenuringThreshold= 这个参数可以设置 15次在Hotspot虚拟机中是最大值。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200617182949.png" alt=""></p><blockquote><p>上面的描述实际上很不全面，你有可能会想：</p><p><strong>进行垃圾回收之后Eden还是空间不足怎么办？</strong></p><p><strong>垃圾回收后将存活的对象移动到其中的一个幸存区的时候内存不够怎么办？</strong></p><p><strong>新对象难道必须经过15次洗礼才能进入到老年区养老吗？</strong></p><p>利用具体的流程图来解释</p></blockquote><p><strong>具体的流程图：</strong></p><p><img src="https://image.cclblog.cn/blog/20200617203602.png" alt=""></p><blockquote><p>这个图算是比较详细的，解释了上面的几个问题。</p></blockquote><h2 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h2><p>JVM在进行GC的时候，肯定不是这三个区域一块回收，要是这样分代有什么意义。大部分回收的是新生代。</p><hr><p>Minor GC/Young GC：只是新生代的垃圾收集。</p><p>Major GC/Old GC：只是老年代的垃圾收集</p><blockquote><p>只有CMS GC会有单独收集老年代的行为。其它的情况就是Full GC。</p><p>还有一种混合收集（Mined GC）只有G1会有这种行为，G1这个垃圾收集器组成很特殊。</p></blockquote><p>Full GC：收集整个java堆和方法区的垃圾。</p><h3 id="GC触发机制"><a href="#GC触发机制" class="headerlink" title="GC触发机制"></a>GC触发机制</h3><h4 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h4><ol><li>当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor区满不会触发GC。Survivor区只能等待Eden区被动清理。这个清理会清理整个新生代。</li><li>Minor GC十分频繁（这里的频繁是相对来说的），回收速度非常快。</li><li>Minor GC会导致STW，暂停用户线程，等待垃圾回收结束，用户线程才恢复运行。</li></ol><h4 id="Major-GC、Full-GC"><a href="#Major-GC、Full-GC" class="headerlink" title="Major GC、Full GC"></a>Major GC、Full GC</h4><ol><li>出现Major GC，一般会伴随至少一次的Minor GC（大部分垃圾收集器都是这样Parallel Scavenge这个比较特殊）。</li><li>如果Major GC后内存还不足，那就完蛋，直接OOM。</li><li>Major GC 很慢，STW时间很长（相对Minor GC）。</li></ol><h2 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>对象的创建在堆中十分频繁，因为堆是线程共享的，在并发的环境下在堆区中划分内存空间是线程不安全的，为了避免多个线程操作同一地址，需要使用加锁的机制，这导致了分配速度有所影响，但是TLAB是堆中开辟的每个线程私有的，就缓解了这个问题。</p><blockquote><p>上面之所以说的缓解是因为并不是全部的对象都是这种方式分配内存的，也不可能这样，这个TLAB的空间非常小，仅仅为Eden空间的1%，-XX:TLABWasteTargetPercent可以设置，虽然只是缓解，但是这也是JVM分配内存的一个首选方式。</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p><strong>TLAB是JVM为每个线程分配的一个私有缓存区域，这个区域在Eden空间内。</strong></p></li><li><p>TLAB快速分配内存，这种内存分配方式称为<strong>快速分配策略。</strong></p></li><li><p>-XX:UseTLAB 设置是否开启TLAB。</p></li><li><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p></li></ul><blockquote><p>分配内存的方式在垃圾那章节说明！</p></blockquote><h2 id="堆空间各种参数总结"><a href="#堆空间各种参数总结" class="headerlink" title="堆空间各种参数总结"></a>堆空间各种参数总结</h2><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>-XX: +PrintFlageInitial</td><td>查看所有的参数的默认初始值</td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>设置新生代对象最大年龄</td></tr><tr><td><strong>-Xms</strong></td><td>初始堆空间内存（默认本机物理内存1/64）</td></tr><tr><td><strong>-Xmx</strong></td><td>最大堆空间内存（默认本机物理内存1/4）</td></tr><tr><td>-Xmn</td><td>设置新生代大小</td></tr><tr><td>-XX:NewRatio</td><td>配置新生代与老年代在堆结构的占比</td></tr><tr><td>-XX:SurvivorRatio</td><td>设置新生代中Eden和s0/s1空间比例</td></tr><tr><td><strong>-XX:+PringGCDetails</strong></td><td>输出详细的GC处理日志</td></tr><tr><td>-XX:HandlePromotionFailure</td><td>是否设置空间分配担保（具体百度这个参数我仅仅了解）</td></tr></tbody></table><h3 id="jinfo查看默认参数"><a href="#jinfo查看默认参数" class="headerlink" title="jinfo查看默认参数"></a>jinfo查看默认参数</h3><p><img src="https://image.cclblog.cn/blog/20200617222501.png" alt=""></p><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>这个博客写的不错：我确实对这个理解不够，不做总结。</p><p><a href="https://www.jianshu.com/p/580f17760f6e" target="_blank" rel="noopener">https://www.jianshu.com/p/580f17760f6e</a> </p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><blockquote><p>平常写代码的时候能使用局部变量的，就不要使用在方法外定义。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC</title>
      <link href="/2020/06/17/java/theme/juc/"/>
      <url>/2020/06/17/java/theme/juc/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>总结中。。。</p>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> JAVA </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> JAVA </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分派</title>
      <link href="/2020/06/16/java/jvm/2-2-1/"/>
      <url>/2020/06/16/java/jvm/2-2-1/</url>
      
        <content type="html"><![CDATA[<h1 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h1><h2 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h2><ul><li><p>所有依赖<strong>静态类型</strong>来决定方法执行版本的<strong>分派</strong>动作，都成为静态分派。</p></li><li><p>静态分配的最典型应用表现就是<strong>方法重载。</strong></p></li><li><p>静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。</p></li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Magpie</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(Bird bird)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是鸟！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(Sparrow human)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是鸟中的麻雀！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(Magpie human)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是鸟中的喜鹊！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bird sparrow = <span class="keyword">new</span> Sparrow();</span><br><span class="line">        Bird magpie = <span class="keyword">new</span> Magpie();</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.talk(sparrow);</span><br><span class="line">        test.talk(magpie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><blockquote><p>我是鸟！<br>我是鸟！</p></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><img src="https://image.cclblog.cn/blog/20200616205136.png" alt=""></p><blockquote><p>理解这个要明白<strong>重载是根据<code>静态类型</code>而不是<code>实际类型</code>来判断选择哪个方法的。</strong></p><p>Bird sparrow = new Sparrow();</p><p>这个Bird 称为变量的 <strong>“静态类型”</strong>，而Sparrow 则是 变量的 <strong>“实际类型”</strong>。变量本身的静态类型是不会发生变化的，在编译期是可知的，上图也说明了这一点，程序还未运行便知道要调用的方法。实际类型变化的结果是在运行期间才可以确定的。编译器在编译程序的时候并不知道一个对象的实际类型是什么。</p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void String(Object param) &#123;</span><br><span class="line">        System.out.println(&quot;object&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test(int param) &#123;</span><br><span class="line">        System.out.println(&quot;int&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test.test(&#39;a&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个代码输出什么？</strong></p><p><img src="https://image.cclblog.cn/blog/20200616210755.png" alt=""></p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><blockquote><p>这说明了重载的版本并不是唯一的，但是往往必须确定一个<strong>“相对更加合适的”</strong>版本。</p><p>‘a’是char类型，就去寻找char类型的重载方法，如果此方法不存在，他就会自动进行类型转换’a’也可以代表数字97。所以他就会去执行int类型的重载方法了。</p></blockquote><h2 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h2><ul><li>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</li></ul><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是鸟！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是鸟中的麻雀！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Magpie</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是鸟中的喜鹊！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bird sparrow = <span class="keyword">new</span> Sparrow();</span><br><span class="line">        Bird magpie = <span class="keyword">new</span> Magpie();</span><br><span class="line">        sparrow.talk();</span><br><span class="line">        magpie.talk();</span><br><span class="line">        sparrow = <span class="keyword">new</span> Magpie();</span><br><span class="line">        sparrow.talk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><blockquote><p>我是鸟中的麻雀！<br>我是鸟中的喜鹊！<br>我是鸟中的喜鹊！</p></blockquote><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><blockquote><p>显然重写不是根据静态类型确定调用哪个方法的，而是根据实际类型。子类重写了父类的方法不同的子类必然产生的动作不同，这肯定就不能依靠静态类型来确定了。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200616212607.png" alt=""></p><p><strong>分析main()方法中的字节码:</strong></p><p><img src="https://image.cclblog.cn/blog/20200616214243.png" alt=""></p><h4 id="invokevirtual"><a href="#invokevirtual" class="headerlink" title="invokevirtual"></a>invokevirtual</h4><p>运行时解析过程</p><ol><li><strong>找到操作数栈顶的第一个元素所指向的对象的实际类型，记做C</strong></li><li><strong>如果在类型C中找到与常量中描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；</strong>不通过则返回java.lang.IllegalAccessError异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstartMethodError异常。</li></ol><blockquote><p>这个说的很明白了，第1步不就找到实际类型吗！！<strong>这个过程就是Java语言中方法重写的本质。</strong></p></blockquote><p>既然这种多态性的根源是和invokevirtual这个指令有关，那么这个只能对方法生效对字段是无效的，因为字段并不使用这个指令，<strong>字段永远没有多态这个特性至少目前还没有(jdk14)</strong>。</p><h2 id="彻底理解多态"><a href="#彻底理解多态" class="headerlink" title="彻底理解多态"></a>彻底理解多态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> B().getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span> <span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">            setValue(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value= value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                value ++;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.setValue(value);</span><br><span class="line">                System.out.println(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(<span class="number">5</span>);</span><br><span class="line">            setValue(getValue()- <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.setValue(<span class="number">2</span> * value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看输出结果  </a><span class="hide-content">答案：22 34 17</span></span><p><strong>解析：</strong></p><p>​    <strong>执行对象实例化过程中遵循多态特性，调用的方法都是将要实例化的子类中的重写方法，只有明确调用了super.xxx关键词或者是子类中没有该方法时，才会去调用父类相同的同名方法。</strong></p><ol><li>new B()构造一个B类的实例</li><li>B的构造函数中super(5)中显示调用父类A的构造函数</li><li>执行A (int v) =&gt; setValue(v)</li><li>虽然构造函数是A类的构造函数，但此刻正在初始化的对象是B的一个实例，<strong>因此这里调用的实际是B类的setValue方法</strong>，于是调用B类中的setValue方法，而B类中setValue方法显示调用父类的setValue方法，将B实例的value值设置为2 x 5 = <strong>10</strong>。</li><li>至此super(5)这条语句执行完成，紧接着执行setValue(getValue() - 3)</li><li>由于B类中没有重写getValue方法，因此调用父类A的getValue方法。</li><li>value++ 此时B的成员变量value=11，<strong>11这个返回值会先暂存起来</strong>，return value，跳过，先执行finally中的方法。</li><li>this.setValue(value)；调用的是B类的setValue方法，因为此刻正在初始化的是B类的一个对象（运行时多态），然后super.setValue(11 * 2)这里显示调用A类的setValue方法，将B的value设置为了22</li><li>然后System.out.println(value) 因此第一个打印的值为22。</li><li>finally语句执行完毕，会把刚才暂存的11返回出去，也就是说这么经历了这些处理，getValue方法最终的返回值是11。</li><li>setValue(11 - 3) =&gt; setValue(8)</li><li>执行setValue(8)执行的肯定是B类的setValue方法，然后value就变成了16。</li><li>到此new B()构造完毕</li><li>然后执行new B().getValue()方法，B中不存在此方法，所以调用的是A类的此方法。</li><li>value++，B的成员变量value值为17，此时执行到return语句，先暂存，然后执行finally中语句，和之前原理一样，打印出34。</li><li>然后把value = 17返回出去，导致System.out.println(new B().getValue)就打印出17</li><li><strong>所以最终的打印结果就是22 34 17</strong></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重载与重写规则</title>
      <link href="/2020/06/16/java/javase/1/"/>
      <url>/2020/06/16/java/javase/1/</url>
      
        <content type="html"><![CDATA[<h1 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h1><ul><li><strong>被重载的方法必须改变参数列表(参数个数或类型不一样)；</strong></li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li><strong>无法以返回值类型作为重载函数的区分标准。</strong></li></ul><h1 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写(Override)"></a>重写(Override)</h1><ul><li><p><strong>参数列表必须完全与被重写方法的相同。</strong></p></li><li><p>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</p></li><li><p>访问权限不能比父类中被重写的方法的访问权限更低。</p><blockquote><p> 例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</p></blockquote></li><li><p>父类的成员方法只能被它的子类重写。</p></li><li><p>声明为 final 的方法不能被重写。</p></li><li><p>声明为 static 的方法不能被重写，但是能够被再次声明。</p></li><li><p>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</p></li><li><p>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</p></li><li><p>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</p></li><li><p>构造方法不能被重写。</p></li><li><p>如果不能继承一个方法，则不能重写这个方法。</p></li></ul><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><blockquote><p>重载：</p><ol><li>​    编译时的多态</li><li>​    重载发生在同一个类中</li><li>​    函数名相同，参数列表不同(参数的类型，顺序，个数 和参数名没有关系)  和方法的返回值类型无关   (因为编译器 并不知道 调用哪一个函数)</li><li>可以抛出不同的异常，可以有不同修饰符</li></ol><p>重写：</p><ol><li>​    运行时的多态</li><li>​    重载发生在子类与父类中</li><li>​    遵循两同两小一大 </li></ol><p>​            两同：</p><p>​                        函数名<strong>相同</strong></p><p>​                        参数列表<strong>相同</strong></p><p>​            两小：</p><p>​                        子类被重写方法的返回值类型<strong>小于</strong>父类被重写方法的返回值</p><p>​                        子类被重写方法抛出异常的类型<strong>小于</strong>父类被重写方法抛出异常的类型</p><p>​            一大：</p><p>​                        <strong>子类被重写方法的访问权限大于等于父类被重写方法的访问权限</strong></p><p>​        4.构造方法不能被重写，声明为 final 的方法不能被重写，声明为 static 的方法不能被重写（隐藏），但是能够被再次声明，父类的私有方法，子类可以继承 但是子类不能访问，子类不能重写父类的私有方法。</p></blockquote><table><thead><tr><th align="left">区别点</th><th align="left">重载方法</th><th align="left">重写方法</th></tr></thead><tbody><tr><td align="left">参数列表</td><td align="left">必须修改</td><td align="left">一定不能修改</td></tr><tr><td align="left">返回类型</td><td align="left">可以修改</td><td align="left">一定不能修改</td></tr><tr><td align="left">异常</td><td align="left">可以修改</td><td align="left">可以减少或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td align="left">访问</td><td align="left">可以修改</td><td align="left">一定不能做更严格的限制（可以降低限制）</td></tr></tbody></table><blockquote><p><strong>重载是静态分配的表现，重写则是动态分派的表现。</strong></p></blockquote><p><a href="/java/jvm/2020/06/16/2-2-1"><strong>深入理解重载和重写</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序计数器</title>
      <link href="/2020/06/12/java/jvm/2-4/"/>
      <url>/2020/06/12/java/jvm/2-4/</url>
      
        <content type="html"><![CDATA[<h1 id="程序计数器（PC寄存器）"><a href="#程序计数器（PC寄存器）" class="headerlink" title="程序计数器（PC寄存器）"></a>程序计数器（PC寄存器）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>程序计数器是一个记录着当前线程所执行的字节码的行号指示器。</code></p><p>程序计数器（Program Counter Register）是一个非常小的空间，可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><p><strong>如果程序正在执行的是本地（Native）方法，这个计数器的值就为空（Undefined）。</strong>native方法是java通过JNI直接调用C/C++库，相当于C/C++暴露给java的一个接口，java调用这个接口就相当于C/C++去执行相应的代码，肯定不会产生相应的字节码，既然没有字节码，那程序计数器不就没得记录。</p></li><li><p><strong>线程私有，每个线程都存在一个程序计数器。</strong></p></li><li><p><strong>此内存区域是唯一一个不存在OOM情况的区域。</strong></p></li><li><p>占用内存非常小，可以忽略不计。</p></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后</p><p><img src="https://image.cclblog.cn/blog/20200612175746.png" alt=""></p><p>我是用的idea的Jclasslib插件进行反编译的，也可以使用javap来反编译。</p><p>这个类似于行号的就是字节码指令的地址，程序计数器中就是要记录这些地址。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li><strong>为什么使用程序计数器来记录当前线程的执行地址呢？（程序计数器的作用？）</strong></li></ol><blockquote><p>因为CPU需要不停的切换各个线程，这时候CPU切换回需要执行的线程后，就得知道接着从哪开始继续执行。</p><p>JVM的字节码解释器需要通过改变程序计数器的值来明确下一条应该执行什么样的字节码指令。</p></blockquote><ol start="2"><li><strong>程序计数器为什么被设定为线程私有？</strong></li></ol><blockquote><p>JVM的多线程是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的。也就是说，某个线程在执行过程中可能会因为时间片耗尽而被挂起，而另一个线程获取到时间片开始执行。当被挂起的线程重新获取到时间片的时候，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置，在JVM中，通过程序计数器来记录某个线程的字节码执行位置。因此，程序计数器是具备线程隔离的特性，也就是说，每个线程工作时都要有属于自己的独立计数器。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机栈</title>
      <link href="/2020/06/12/java/jvm/2-2/"/>
      <url>/2020/06/12/java/jvm/2-2/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>Java虚拟机栈线程私有，生命周期与线程相同。描述的是Java方法执行的线程内存模型。</p></li><li><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够内存会抛出OutOfMemoryError异常。</p></li></ul><blockquote><p>栈是运行时的单位，而堆是存储的单位。栈解决程序的运行问题，即程序如何执行，数据如何处理。堆解决的是数据的存储问题，即数据怎么放。</p><p>栈就好比你程序中的业务代码，而堆就是存储数据的数据库，数据一个程序是灵魂，如果数据不做处理、可视化，完全是死的数据，我认为是完全没有意义的。</p></blockquote><h3 id="设置栈的大小"><a href="#设置栈的大小" class="headerlink" title="设置栈的大小"></a>设置栈的大小</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码就会导致StackOverflowError异常。递归调用操作不当十分容易导致栈溢出。</p><p><img src="https://image.cclblog.cn/blog/20200613161704.png" alt=""></p><p>test2()这个方法执行了10271次才溢出，可以通过<code>-Xss</code>选项来设置线程的最大栈空间，这个栈空间的大小直接决定了函数的调用的最大深度。</p><p><img src="https://image.cclblog.cn/blog/20200613162335.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200613162909.png" alt=""></p><p>发现test2()方法只运行了541次，得出<code>-Xss</code>改变了栈空间的大小。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>栈是一种快速有效的分配方式，访问速度仅次于程序计数器。</li><li>对于栈来说不存在垃圾回收的问题。</li></ul><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p><strong>栈的存储单位就是栈桢。</strong></p><p>每个方法被执行的时候，java虚拟机都会同步创建一个栈桢用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法从被调用到执行完毕的过程，就对应着一个栈桢在虚拟机中从入栈到出栈的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个程序main()方法中调用test1()，test1()调用test2()，test2()调用test3()。</p></blockquote><p>将程序在test1()处打个断点，平时写代码调试的时候，经常接触栈栈桢，只是有可能不知道这是而已。</p><p><img src="https://image.cclblog.cn/blog/20200613164510.png" alt=""></p><p>然后步入接着执行程序</p><p><img src="https://image.cclblog.cn/blog/20200613164755.png" alt=""></p><p>继续步入执行</p><p><img src="https://image.cclblog.cn/blog/20200613165010.png" alt=""></p><p>test3()方法执行完毕后开始出栈。</p><p><img src="https://image.cclblog.cn/blog/20200613165154.png" alt=""></p><p>之后就是test2出栈test1出栈最后main出栈，程序执行结束。</p><p>这里如果调试的时候执行了下一步怎么返回上一步执行，退回去重新操作。idea提供了丢帧的操作。</p><p><img src="https://image.cclblog.cn/blog/20200613165543.png" alt=""></p><p>抛弃test1()后就回到main()这个栈桢了。</p><p><img src="https://image.cclblog.cn/blog/20200613172005.gif" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200613172046.gif" alt=""></p><blockquote><p>这个就像你写的程序一个方法中调用另一个方法，就相当于妈妈让你爸爸去买醋，然后你爸爸让你去买醋，你买回来后高速你爸爸我买回来了，然后就没你的事情了，然后你爸爸高速你妈妈，买回来了。。。当然你也可以直接告诉你妈妈，，但是程序不行啊。这就是一个入栈出栈的过程，如果你爸爸告诉你去买，你告诉你爸爸去买，无限循环，不就导致错误了吗。</p></blockquote><h2 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h2><ul><li>不同线程中包含的栈桢是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li><li>java方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用return命令；另外一种是抛出异常；</strong>不管使用哪种方式，都会导致栈帧被弹出。</li></ul><h2 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h2><ul><li><strong>局部变量表（*）</strong></li><li><strong>操作数栈（*）</strong></li><li>动态连接</li><li>方法返回地址</li><li>一些附加的信息</li></ul><p><img src="https://image.cclblog.cn/blog/20200613180052.png" alt=""></p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><ul><li><p>局部变量表(Local Variables Table)是一组变量值的存储空间，用于存放<strong>方法参数</strong>和<strong>方法内部定义的局部变量</strong>这些数据类型包括各大基本数据类型、对象引用（reference），以及returnAddress类型。</p><blockquote><p>基本数据类型无需多言，reference就是一个对象实例的引用。returnAddress是为了字节码指令jsr、jsr_w和ret服务的，指向一条字节码指令的地址，目前已经很少使用。</p></blockquote></li><li><p>由于局部变量表在栈帧之中，因此，如果函数的参数和局部变量很多，会使得局部变量表膨胀，因此，每一次函数调用，其局部变量表会占用更多的栈空间，最终导致函数的嵌套调用的次数减少。</p><blockquote><p><strong>栈大小固定，栈中存放栈帧，栈帧中有局部变量表，局部变量表存放局部变量，局部变量很多，占用空间就大，导致栈中可以存放的栈桢变少，自然函数嵌套的次数也就减少</strong></p></blockquote></li><li><p>局部变量表是建立在线程的栈上，是线程的私有数据，<strong>不存在数据安全问题。</strong></p></li><li><p><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，存储在方法的Code属性的maximum local variables数据项中。（后续会说明）在方法运行期间是不会改变局部变量表的大小的。</p></li></ul><blockquote><p>局部变量表中的容量的意思是你这个方法中有多少局部变量，和方法参数，这个肯定是确定的啊，在编译期间就确定的。你自己都能数一数一个方法中有多少变量和参数，更别说编译器了。</p></blockquote><ul><li>局部变量表中的变量只在当前方法中有效。当在方法执行的时候，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也随之销毁。</strong></li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">short</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> d = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">float</span> e = <span class="number">11.2F</span>;</span><br><span class="line">    <span class="keyword">double</span> f = <span class="number">1.1</span>;</span><br><span class="line">    <span class="keyword">char</span> g = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">boolean</span> i = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    String h = <span class="string">"aa"</span>;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析test1()方法的局部变量表：</strong></p><p><img src="https://image.cclblog.cn/blog/20200613220859.png" alt=""></p><p><strong>因为这是静态方法所以并不存在该对象的引用this，如果不是静态方法，index为0的位置就是隐藏的this。</strong></p><p><img src="https://image.cclblog.cn/blog/20200613222439.png" alt=""></p><h4 id="变量槽Slot"><a href="#变量槽Slot" class="headerlink" title="变量槽Slot"></a>变量槽Slot</h4><ul><li>局部变量表，最基本的存储单元是变量槽</li><li>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</li></ul><blockquote><p>byte、short、char在存储前会被转换为int，boolean也被转换为int，0为false，非0表示true。</p><p><strong>long和double占据两个变量槽。</strong></p></blockquote><ul><li>JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量的值。</li><li><strong>如果要访问局部变量表中的一个64bit（long、double）的局部变量值时，只需要使用前一个索引即可。这也是JVM规定必须的。</strong></li><li><strong>如果一个方法不是静态方法，那么该对象的引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。</strong></li><li><strong>变量槽（Slot）可以重复利用</strong></li></ul><h5 id="变量槽的重复利用"><a href="#变量槽的重复利用" class="headerlink" title="变量槽的重复利用"></a>变量槽的重复利用</h5><p>栈帧中的局部变量表中的槽位是可以重复利用的，如果一个局部变量出了它的作用域，那么在其作用域之后申明的局部变量就会复用过期局部变量的槽位，从而达到节省资源的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/blog/20200613224813.png" alt=""></p><blockquote><p>这个代码不是静态代码，所以肯定存在一个this这个对象的引用，为什么是2个槽位，而不是3个槽位，代码中b这个变量出了代码块后，这个变量槽就没必要存储它了，然后a也没必要在重开一个槽位，就相当于占用了b的槽位，把b替换了。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200613225335.png" alt=""></p><blockquote><p>这是你可能会想，如果a是long或者double类型的占用2个槽位，但是b只空出一个槽位，那该怎么算？如果这样的话，槽位就会变成3，而不是4，照样重用那个槽位，然后在添加上一个槽位就可以了。</p></blockquote><p> <img src="https://image.cclblog.cn/blog/20200614154741.png" alt=""></p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><ul><li><p>后入先出（Last In First Out）栈，也常被称作操作栈。</p></li><li><p>同局部变量表一样，操作数栈的最大深度也在编译的时候被写入Code属性的max_stacks数据项之中。</p></li><li><p>栈中的任何一个元素都是可以任意的Java数据类型。<strong>32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。</strong></p></li><li><p>操作数栈<strong>不是采用访问索引的方式来进行数据访问的</strong>，而是只能通过标准的入栈(push)和出栈(pop)操作来完成一次数据访问。</p></li><li><p>操作数栈中元素类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器必须严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。</p></li><li><p><strong>Java虚拟机的解释执行引擎被称为“基于栈的执行引擎”，里面的“栈”就是操作数栈。</strong></p></li></ul><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/blog/20200615162713.png" alt=""></p><p><strong>编译的时候局部变量表和操作数栈的大小和深度就是确定的。</strong></p><p><img src="https://image.cclblog.cn/blog/20200615164022.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164049.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164109.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164158.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164159.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164200.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164302.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164301.png" alt=""></p><h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><ul><li>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现<strong>动态连接。</strong></li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。比如：描述一个方法调用另外的其他方法时候，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态连接的作用就是为了将这些符号引用转换为调用方法的直接引用。</strong></li></ul><blockquote><p>具体描述在方法调用中说明。</p></blockquote><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><ul><li>方法调用阶段的唯一任务就是确定被调用方法到底是哪个方法。一切方法调用在Class文件里面存储的都只是<strong>符号引用</strong>，而不是<strong>方法在运行时内存布局中入口地址（这个就是直接引用）</strong>。</li><li>某些调用需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</li></ul><p><strong>例如</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"琦玉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main()方法中调用了test1()方法，它的字节码为</p><p><img src="https://image.cclblog.cn/blog/20200616155943.png" alt=""></p><p>在java虚拟机中支持以下5条方法调用字节码指令：</p><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td><strong>invokestatic</strong></td><td>用于调用静态方法</td></tr><tr><td><strong>invokespecial</strong></td><td>用于调用实例构造方法<code>&lt;init&gt;()</code>、私有方法和父类中的方法</td></tr><tr><td><strong>invokevirtual</strong></td><td>用于调用所有的<strong>虚方法</strong></td></tr><tr><td><strong>invokeInterface</strong></td><td>用于调用接口方法，会在运行时再确定一个实现该接口的对象</td></tr><tr><td><strong>invokedynamic</strong></td><td><strong>这个最为特殊，具体说明。</strong></td></tr></tbody></table><h4 id="虚方法、非虚方法"><a href="#虚方法、非虚方法" class="headerlink" title="虚方法、非虚方法"></a>虚方法、非虚方法</h4><ul><li>只要是能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，java语言里符合这个条件的方法有<strong>静态方法、私有方法、实例构造器、父类方法</strong>这4种，再加上被final修饰的方法（尽管它是使用invokevirtual指令调用），这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为<code>非虚方法</code>与之相反就是<strong>虚方法</strong>。</li></ul><blockquote><p>静态方法、私有方法、实例构造器、父类方法还有被final修饰的方法有一个共同的特点就是它们都不能通过继承或别的方式重写，之所以叫做非虚我认为就是十分确定的，你调用这些方法能特别肯定的，你的程序中只有一个地方有该方法，是十分确定的，不像有些方法可以重写，重载一样，你调用一个方法系统不知道调用哪个，必须等到程序真正运行调用的时候才能知道，虚无缥缈，所以就叫做虚方法了。</p></blockquote><h4 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h4><p><a href="/2020/06/12/2-2-1">通过分派彻底理解重载和重写</a></p><h4 id="invokedynamic"><a href="#invokedynamic" class="headerlink" title="invokedynamic"></a>invokedynamic</h4><ul><li><p>jdk7中增加的一个指令，<strong>这个指令是为了实现动态类型语言支持而做出的改进。</strong></p></li><li><p>每一处含有invokedynamic指令的位置都被称作“动态调用点”，虽然这个指令是jdk7引用的，但是并没有提供直接生成该指令的方法。<strong>直到java8中的Lambda表达式的出现，invokedynamic指令的生成，在java中才有了直接的生成方式。</strong></p></li></ul><p><strong>动态类型、静态类型语言</strong></p><p>动态语言的特征是它的类型检查的主体过程是在运行期间而不是编译期进行的（例如js、php、python等）相对的在编译期间就进行类型检查过程的语言，例如c++、java就是最常用的静态类型语言。</p><blockquote><p>a = 1; 这个语句在python中就可以执行，但是在java中就会报错，静态语言是对a变量的检查，而动态语言是对1这个值的检查，根据这个值来确定变量a的类型。一个运行时确定，一个编译期确定。</p></blockquote><p><strong>这两个类型的语言各自优点？</strong></p><blockquote><p><strong>静态语言：</strong>能够在编译期确定变量类型，十分严谨，利于系统的稳定性。</p><p><strong>动态语言：</strong>运行时才确定类型，十分灵活，并且静态类型花费很多代码才能实现的功能，动态语言可能很简洁就能实现，提高了开发的效率。</p></blockquote><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>当一个方法开始执行后只有两种方法可以退出这个方法：</p><ol><li>执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层方法的调用者，这种退出的方式为“正常调用完成”。</li></ol><blockquote><p>ireturn(返回值是boolean，byte，char，short和int时使用)、lreturn、freturn、dreturn、areturn（引用类型）、return（void类型）</p></blockquote><ol start="2"><li>方法在执行的过程中遇到了异常，并且这个异常并未在方法内进行处理，这种退出方法的方式称为“异常调用完成”。</li></ol><blockquote><p>一个方法使用异常完成出口的方式退出，是不会给它的上层调用者提供任何返回值的。</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p><strong>方法退出的过程就等同于当前栈帧出栈。这是需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</strong></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clinit()与init()</title>
      <link href="/2020/06/10/java/jvm/2-1-1/"/>
      <url>/2020/06/10/java/jvm/2-1-1/</url>
      
        <content type="html"><![CDATA[<h2 id="lt-clinit-gt-与-lt-init-gt"><a href="#lt-clinit-gt-与-lt-init-gt" class="headerlink" title="&lt;clinit&gt;()与&lt;init&gt;()"></a><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code></h2><h3 id="lt-clinit-gt"><a href="#lt-clinit-gt" class="headerlink" title="&lt;clinit&gt;()"></a><code>&lt;clinit&gt;()</code></h3><ul><li><code>&lt;clinit&gt;()</code>的执行时期为类初始化阶段，并且该方法只能被jvm使用，专门负责类变量的初始化工作。</li><li>Java 类加载的初始化过程中，编译器<strong>按语句在源文件中出现的顺序</strong>，依次自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并产生 <code>&lt;clinit&gt;()</code>方法。 如果类中没有静态语句和静态代码块，那可以不生成该方法。</li><li><code>&lt;clinit&gt;()</code> 不需要显式调用父类（接口除外，接口不需要调用父接口的初始化方法，只有使用到父接口中的静态变量时才需要调用）的初始化方法 <code>&lt;clinit&gt;()</code>，虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。</li></ul><p><strong>类何时进行初始化？（主动引用）</strong></p><blockquote><ol><li>使用new关键字实例化对象的时候；读取或设置一个类型的静态字段（被final修饰的除外，因为已在编译期将结果放入了常量池）；调用一个静态方法。</li><li>使用反射调用。</li><li>初始化类的时候，发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li><li><strong>当使用JDK7新加入的动态语言支持时。（后续在字节码章节详细讲解）</strong></li><li>当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果这个接口的实现类发生了初始化，那么该接口要在其之前被初始化。</li></ol><p><strong>以上的条件是当类或接口未初始化过，即是第一次初始化，才会执行。并且有且只有这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型都不会触发初始化，称为被动引用</strong></p></blockquote><p><strong>被动引用</strong></p><ol><li><p>通过子类引用父类的静态字段，不会导致子类初始化，只会触发父类的初始化。</p></li><li><p>通过数组定义来引用类。</p></li></ol><blockquote><p>假如有一个Student类</p><p>Student[] studentArray = new Student[10];</p><p>这种情况并不会导致Student类进行初始化。你并没有使用Student类中的任何，但是你声明数组，必然会导致和数组相关的类进行了初始化，[Lorg.fenixsoft.classloading.SuperClass 这个类发生了初始化，这是个与一维数组相关的类，具体不做详细介绍。</p></blockquote><ol start="3"><li>使用类中的被final修饰的静态常量。</li></ol><blockquote><p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p></blockquote><h3 id="lt-init-gt"><a href="#lt-init-gt" class="headerlink" title="&lt;init&gt;()"></a><code>&lt;init&gt;()</code></h3><ul><li><p>执行时期：对象的初始化阶段。</p></li><li><p>执行构造器，以及非静态初始化块中的代码。</p></li></ul><p><strong>实例化一个类的四种途径:</strong></p><ol><li>调用 new 操作符</li><li>调用 Class 或 java.lang.reflect.Constructor 对象的newInstance()方法(反射)</li><li>调用任何现有对象的clone()方法</li><li>通过 java.io.ObjectInputStream 类的 getObject() 方法反序列化</li></ol><h3 id="lt-clinit-gt-与-lt-init-gt-执行顺序案例"><a href="#lt-clinit-gt-与-lt-init-gt-执行顺序案例" class="headerlink" title="&lt;clinit&gt;()与&lt;init&gt;()执行顺序案例"></a><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code>执行顺序案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test instance; <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// &lt;clinit&gt;()</span></span><br><span class="line">        System.out.println(<span class="string">"static开始"</span>);</span><br><span class="line">        instance = <span class="keyword">new</span> Test();</span><br><span class="line">        System.out.println(<span class="string">"static结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// &lt;init&gt;()</span></span><br><span class="line">        System.out.println(<span class="string">"构造器开始"</span>);</span><br><span class="line">        System.out.println(<span class="string">"x="</span> + x + <span class="string">";y="</span> + y);</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        System.out.println(<span class="string">"x="</span> + x + <span class="string">";y="</span> + y);</span><br><span class="line">        System.out.println(<span class="string">"构造器结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">1</span>; <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> y; <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test.getInstance();</span><br><span class="line">        System.out.println(<span class="string">"x="</span> + x);</span><br><span class="line">        System.out.println(<span class="string">"y="</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><blockquote><p>static开始<br>构造器开始<br>x=0;y=0<br>x=1;y=1<br>构造器结束<br>static结束<br>x=1<br>y=1</p></blockquote><blockquote><p>从结果中可以看出静态代码块先执行，如果静态代码块中执行了其它方法，则先去执行，然后在回来继续执行，静态代码，这就说明了<code>&lt;clinit&gt;()</code>方法在<code>&lt;init&gt;()</code>之前执行。</p></blockquote><blockquote><p><code>&lt;clinit&gt;()</code>方法就是将一个类中的所有的静态代码块以及类变量整合到一块，注意这里是有顺序的执行，如果其中调用了其它非静态方法，就会执行完后接着执行，如果有父类的话当然执行父类的静态代码块以及类变量，就像下图一样，<strong>把父类和子类的这些静态代码块，类变量全部整合到一块，按照代码编写的顺序来执行。</strong></p><p><code>&lt;init&gt;()</code>也是如此，不过整合的是普通代码块和普通的成员变量了。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200610133639.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载子系统</title>
      <link href="/2020/06/09/java/jvm/2-1/"/>
      <url>/2020/06/09/java/jvm/2-1/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><h3 id="一个类的生命周期"><a href="#一个类的生命周期" class="headerlink" title="一个类的生命周期"></a>一个类的生命周期</h3><p><img src="https://image.cclblog.cn/blog/20200609204057.png" alt=""></p><p>其中加载，验证，准备，初始化，和卸载这五个阶段顺序是确定的，解析阶段则不一定，在某些情况下可以在初始化阶段之后再进行，这是为了支持java语言的运行时绑定特性。</p><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载阶段，java虚拟机需要完成：</p><ol><li><p>通过一个类的全限定名来获取定义此类的二进制字节流。</p></li><li><p>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构。</p></li><li><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p></li></ol><blockquote><p><strong>这个java.lang.Class对象，将相当于一个模具，假如你在家里面自制雪糕，必须有个模具吧，用这个模具来生产雪糕，假如你这个模具是塑料的。</strong></p><p><strong>1.中的字节流就相当于这个模具的第一道加工，把塑料的原料加工成塑料</strong></p><p><strong>2.中的就是相当于第二道加工，塑料模具基本成型，然后运输到方法区</strong></p><p><strong>3.就相当于这个模具上色美化等，真正的成为了一个可以使用的模具了，然后你就可以用它来制作雪糕，你制作的每个雪糕就是一个个对象，他们的形状是一样的，但是具体的内容即原料颜色等可能不一样，这也就是对象的具体内容可能不同</strong></p></blockquote><p><img src="https://image.cclblog.cn/blog/20200609204148.png" alt=""></p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ol><li><strong>文件格式验证</strong>，验证字节流是否符合Class文件格式规范。</li></ol><blockquote><p><strong>就是看看你这个文件是不是符合我要加载的，就相当于一个图片还有各种格式.jpg.png，不能你把随便一个文件的后缀名改成.class就加载你吧。</strong></p></blockquote><ol start="2"><li><strong>元数据验证</strong>，对字节码描述的信息进行验证，保证描述的信息符合，比如一个类是否继承了被final修饰的类，如果一个类不是抽象类，是否实现了其父类或接口中要求实现的方法等。</li></ol><blockquote><p><strong>就是看看程序中代码是否做了规定以外的事情，这个规定就好java的语言规范，就相当于一个人要遵守法律一样，就相当于查一下你有没有犯法，做了规定以外的事情。比如你不是我老婆，我和你睡在了一块？？？</strong></p></blockquote><ol start="3"><li><strong>字节码验证</strong>，验证程序语义是否为合法的，符合逻辑的。</li></ol><blockquote><p><strong>就是详细的检查程序代码是否是安全的，会不会对虚拟机造成威胁，这个阶段最为复杂，三言两语很难说清，要检查的东西有很多</strong></p></blockquote><ol start="4"><li><strong>符号引用验证</strong>，验证一个类是否缺少或者被禁止访问它依赖的某些外部类、方法等。</li></ol><blockquote><p><strong>就是我依赖的类，我能不能访问。比如买了一个苹果手机，看一下我能不能使用它，不能使用的话不就出问题了</strong></p></blockquote><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值阶段。</p><p>例如一个变量定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>那变量在准备阶段过后的初始值为0而不是123，真正把value赋值的操作是在类的初始化阶段才会被执行。</p><p>但是如果 value被声明为 <strong>final</strong>那么在准备阶段就会给value赋值为123</p><p><strong>例如</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test2 instance = Test2.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test2 test2 = <span class="keyword">new</span> Test2();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a="</span> + a);</span><br><span class="line">        System.out.println(<span class="string">"b="</span> + b);</span><br><span class="line">        <span class="keyword">return</span> test2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序的输出结果为 a=1 b=0 并不是a=1 b=1</strong></p><blockquote><p>分析：</p><ol><li>准备阶段，会将静态变量从上到下设置为默认值，a=0,test2=null,b=0</li><li>当调用一个类的静态变量或静态方法会导致该类初始化，并设置成实际的默认值</li><li>此时a还是0，因为它并没有默认值，然后test2 赋值，调用了Test2()构造方法，对a++,b++ ,此时a = 1 b = 1</li><li>然后给b赋值默认值0，这样就导致了覆盖了前面的1，导致最后b=0</li></ol><p>如果变成private static int b = 0;private static Test2 test2 = new Test2();那最后的结果就变成了a=1 b=1了，和代码的顺序有关。</p></blockquote><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。这个阶段很重要，需要了解Class文件的类文件结构。后续会详细讲解。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类的初始化是类加载过程的最后一个步骤，直到初始化阶段，Java虚拟机才真正开始执行类中编写的java程序代码。</p><p>这个阶段是为静态变量赋予正确的初始值，执行静态代码块，执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。</p><p><strong>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，可以赋值但是不能访问。例如：</strong></p><p><img src="https://image.cclblog.cn/blog/20200609204234.png" alt="">    </p><p><strong>java虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。这个说明父类中定义的静态语句块肯定优先于子类执行。例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a =  <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Test1.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果为2，这不就说明了Test父类中的静态代码块被执行了吗。</p><p><strong>如果一个类中没有静态语句块，也没有对变量的赋值操作，编译器就不会生成<code>&lt;clinit&gt;()</code>方法。</strong></p><p><strong>执行接口的<code>&lt;clint&gt;()</code>方法无需先执行父类的<code>&lt;clinit&gt;()</code>方法</strong>，因为当只有父接口中定义的变量被使用时，父接口才会被初始化。接口的实现类在初始化时也不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p><p><strong><code>&lt;clinit&gt;()</code>在多线程环境下是安全的，并且只会被执行一次</strong>，只会有一个线程去执行，其它线程阻塞，直到执行完该方法后，其它线程才能操作，否则一直阻塞，并且<code>&lt;clinit&gt;()</code>只会被多个线程执行一次，执行完后，其它线程将不会再次执行。</p><blockquote><p><strong>这就好比你的目的是制作一辆汽车（一个类的模板），你有必要去生产两个车壳子（其中的静态代码块，赋值操作）吗？程序中只需要一个类模板就行了，<code>&lt;clinit&gt;()</code>方法就相当于类模板的装饰，装饰这个类一开始有哪些属性，也就是出厂设置吧。其他你初始化赋值<code>&lt;init&gt;()</code>方法，就是你自定义的值了。你开多个线程，就相当于多个工厂，一旦其中一个工厂接下了这份活，你得赶紧通知其他的工厂不要做了，如果几个工厂都生产的话，你总不能只给一份钱吧（浪费系统资源）。</strong></p></blockquote><p>这就相当于生产一个汽车零件，你的目的只是制作一辆汽车，你完全没有必要去生产</p><h4 id="lt-clinit-gt-与-lt-init-gt-方法"><a href="#lt-clinit-gt-与-lt-init-gt-方法" class="headerlink" title="&lt;clinit&gt;()与&lt;init&gt;()方法"></a><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code>方法</h4><p>详情见 <strong><a href="/2020/06/10/java/jvm/2-1-1/"><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code>详解</a></strong></p><h3 id="类加载器ClassLoader"><a href="#类加载器ClassLoader" class="headerlink" title="类加载器ClassLoader"></a>类加载器ClassLoader</h3><p><img src="https://image.cclblog.cn/blog/20200611160308.png" alt=""></p><ul><li>启动类加载器（Bootstrap Class Loader）</li></ul><blockquote><ol><li>这个类加载器使用C/C++语言实现的，嵌套在JVM内部。所以java程序中是获取不到的。</li><li>负责加载放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，并且必须被java虚拟机识别（按照文件名识别，.jar），名字不符合即使放在此目录下也不能加载。</li><li>不继承自java.lang.ClassLoader，没有父加载器</li><li>出于安全考虑，只能加载包名为java、javax、sun等开头的类</li></ol></blockquote><ul><li>扩展类加载器（Extension Class Loader）</li></ul><blockquote><ol><li>这个类加载器是在sun.misc.Launcher$ExtClassLoader中以java代码的形式实现的。</li><li>负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li></ol></blockquote><ul><li>应用程序类加载器（Application Class Loader）</li></ul><blockquote><p>这个类加载器由sun.misc.Launcher$AppClassLoader来实现。它负责加载用户类路径上所有的类库。如果应用程序中没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p></blockquote><h4 id="自定义类加载器步骤"><a href="#自定义类加载器步骤" class="headerlink" title="自定义类加载器步骤"></a>自定义类加载器步骤</h4><ol><li>继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器。</li><li>jdk1.2之前，继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载，之后不在建议这样做，而是建议把自定义的类加载逻辑写在findClass()方法中。</li><li>在编写自定义类加载器时，如果需求简单，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，可以使自定义类加载器编写更加简洁。</li></ol><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><blockquote><p>JVM对class文件采用的是<strong>按需加载</strong>的方式，当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，JVM采用的是<strong>双亲委派机制</strong>。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200611134915.png" alt=""></p><p><strong>双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的类加载器中，只有当父加载器反馈自己无法完成这个加载请求时（它的搜索范围内没有找到所需的类）时，子加载器才会尝试自己去完成加载。</strong></p><blockquote><p>双亲委派机制就是：<code>自底向上检查类是否已经加载，自顶向下尝试是否可以加载类</code></p></blockquote><p><strong>类加载流程图：</strong></p><p><img src="https://image.cclblog.cn/blog/20200611143430.jfif" alt=""></p><p><strong>使用双亲委派机制的优势？（为什么要使用双亲委派机制？优点有哪些？）</strong></p><blockquote><ol><li>避免类的重复加载。</li><li>保护核心API被随意篡改。通过委托方式，不会去篡改核心<code>.class</code>，即使篡改也不会去加载，即使加载也不会是同一个<code>.class</code>对象了。不同的加载器加载同一个<code>.class</code>也不是同一个<code>Class</code>对象。这样保证了<code>Class</code>执行安全。</li></ol></blockquote><p><strong>弊端：</strong></p><blockquote><p>双亲委派模型是单向的，永远是子加载器请求父加载器，这就造成了上层的类加载器无法访问下层类加载器所加载的类。例如常见的JDBC就是这样，JDBC在java.sql.Driver中只定义了接口，具体的实现是由具体的数据库厂商来实现的，例如你使用msql，mysql肯定实现了Driver中的接口，但是它的jar在你的目录下，系统类加载器无法识别，你要是用mysql的话就会出现问题，自然就会出现解决的办法。线程上下文类加载器，和jdk6提供的java.util.ServiceLoader类具体不过多介绍。</p></blockquote><h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><p>当父加载器去委托子加载器去加载类的时候就破坏了这个双亲委派模型，双亲委派模型有三次被破坏，具体不做说明。</p><p>这两篇文章写得挺好。</p><p><a href="https://blog.csdn.net/awake_lqh/article/details/106171219" target="_blank" rel="noopener">双亲委派模型的破坏(JDBC例子)</a></p><p><a href="https://blog.csdn.net/sinat_34976604/article/details/86723663" target="_blank" rel="noopener">双亲委派模式破坏-JDBC</a></p><h4 id="jdk9下发生的变化（简）"><a href="#jdk9下发生的变化（简）" class="headerlink" title="jdk9下发生的变化（简）"></a>jdk9下发生的变化（简）</h4><p>jdk9对java进行了模块化，是一次重大的变化，这个模型也随之而变。</p><p><img src="https://image.cclblog.cn/blog/20200611152410.png" alt=""></p><ol><li>扩展类加载器被平台类加载器替代。</li><li>它们都不在派生自java.net.URLClassLoader，而是全部继承于jdk.internal.loader.BuiltinClassLoader。</li><li>这个双亲委派模型发生了变化。</li></ol><blockquote><p>jdk9相当于对java核心代码进行了重构，变成模块化，启动类加载器，平台类加载器，应用程序类加载器，都被明确规定了加载哪些模块的类，这样类的加载过程就变成了，在委派给父类加载器的时候首先看自己是否可以加载此类，这个变化可以说破坏了双亲委派的这个模型。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM简介</title>
      <link href="/2020/06/08/java/jvm/1-1/"/>
      <url>/2020/06/08/java/jvm/1-1/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM（Hotspot）"><a href="#JVM（Hotspot）" class="headerlink" title="JVM（Hotspot）"></a>JVM（Hotspot）</h2><p><img src="https://image.cclblog.cn/blog/20200612162656.png" alt=""></p><p><code>java虚拟机是运行在操作系统之上的，它与硬件没有直接的交互！！！</code></p><h3 id="程序运行的过程"><a href="#程序运行的过程" class="headerlink" title="程序运行的过程"></a>程序运行的过程</h3><p><img src="https://image.cclblog.cn/blog/20200611155155.png" alt=""></p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p><img src="https://image.cclblog.cn/blog/20200611160308.png" alt=""></p><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p><img src="https://image.cclblog.cn/blog/20200611161129.png" alt=""></p><ul><li>99%的垃圾回收操作都是在堆上，所谓的JVM调优实际上就是在对堆的一个调优！！！</li></ul><h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><p><img src="https://image.cclblog.cn/blog/20200611170207.png" alt=""></p><h3 id="JDK不同版本JVM变化"><a href="#JDK不同版本JVM变化" class="headerlink" title="JDK不同版本JVM变化"></a>JDK不同版本JVM变化</h3><ul><li><p>jdk6：存在永久代，静态变量存放在永久代。</p></li><li><p>jdk7：存在永久代，逐步去永久代；将<strong>字符串常量池</strong>和<strong>静态变量</strong>移动到了堆空间中。</p></li><li><p>jdk8：永久代，类型信息、字段、方法、常量保存在本地内存的元空间（Metaspace），字符串常量池、静态变量仍然在堆中。</p></li></ul><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol><li><p>为什么将字符串常量池移入到堆中？（为什么去永久代，改为元空间？）</p><blockquote><ol><li>字符串存在永久代中，容易出现性能问题和内存溢出，因为字符串应该是程序中非常常用的。</li><li>类及方法的信息等比较难确定大小，因此对于永久代的大小指定比较困难。</li><li>永久代会为GC带来不必要的复杂度，并且回收效率很低。</li><li>Oracle将HotSpot与JRockit合二为一，借鉴了后者虚拟机的优点。</li></ol></blockquote></li></ol><h3 id="其他虚拟机"><a href="#其他虚拟机" class="headerlink" title="其他虚拟机"></a>其他虚拟机</h3><p>BEA JRockit，IBM J9不做过多介绍。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2020/06/06/java/theme/jvm/"/>
      <url>/2020/06/06/java/theme/jvm/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><ol><li><strong><a href="/2020/06/08/java/jvm/1-1/">JVM简介</a></strong></li></ol><hr><h2 id="内存结构篇"><a href="#内存结构篇" class="headerlink" title="内存结构篇"></a>内存结构篇</h2><ol><li><strong><a href="/2020/06/09/java/jvm/2-1/">类加载子系统</a></strong> </li><li><a href="/2020/06/12/java/jvm/2-2/"><strong>虚拟机栈</strong></a></li><li><a href="/2020/06/17/java/jvm/2-3/">本地方法栈</a></li><li><strong><a href="/2020/06/12/java/jvm/2-4/">程序计数器</a></strong></li><li><strong><a href="/2020/06/17/java/jvm/2-5/">堆</a></strong></li><li><strong><a href="/2020/06/19/java/jvm/2-6/">方法区</a></strong></li><li><strong><a href="/2020/06/20/java/jvm/2-7/">执行引擎</a></strong></li><li>本地方法接口<strong>（略）</strong></li></ol><hr><h2 id="垃圾回收篇"><a href="#垃圾回收篇" class="headerlink" title="垃圾回收篇"></a>垃圾回收篇</h2><ol><li>垃圾收集器（×）</li><li>内存分配策略（×）</li></ol><h2 id="性能监控与调优篇"><a href="#性能监控与调优篇" class="headerlink" title="性能监控与调优篇"></a>性能监控与调优篇</h2><ol><li>性能监控（×）</li><li>性能调优（×）</li></ol><hr><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><ol><li>StringTable（×）</li><li>字节码（×）</li></ol><hr><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol><li>…（×）</li></ol><hr><p>​    <strong>要快速的学习JVM就要了解你写的一行代码假如Car car = new Car();这个到底在虚拟机中是怎么加载，分配内存等等，然后怎么被回收处理，等，综合性的学习才能学得更快记得更牢固，起初就是一个知识点知识点的学，堆、栈、方法区…就像一开始学是一个点，然后变成碎片，这些组合起来就是jvm的内存结构，慢慢的组成一个网（整个JVM网络），只要组成一个网络化的知识，我说的是并不是这个网络有多么牢固，要明白不求甚解这个道理，尤其是JVM，知识点互相穿插，并不是一个知识点你就能很透彻，有可能你学了别的知识点，然后再看前面恍然大悟，往往我就是这样。而是你有了个整体的认识，就像从上向下看，一目了然，我认为这就是大局观，一定要有这种观念，知识网络化，小到一个知识点，大到系统的一个架构，一切都是思想，一定要有这个思想，显然我在JVM这个上面功力明显不足，我现在还停留在碎片的阶段（2020-06-19），我并不能把这个JVM特别清楚详细的描述，更别说深入的了解，我只是在尝试深入了解，其中有的点我并不是很清楚，形成一个基本的网络时间肯定不会很长，然后慢慢巩固这个网络，不求甚解这个方法形成网络后，肯定不如你平常研究某个知识点掌握那么的牢固，这种情况下，往往是别人问你你了解，知道有这个知识点，但是只能说个支支吾吾大概，这时无需感觉很无奈，感觉自己白学了，首先有了一个知识网络，然后在逐个点的巩固，不断的巩固，总有一天，（其实我非常烦说这个“总有一天” 这到底是哪一天？但是这个确实需要你的用心的，如果你用心时间肯定不会很长，否则确实就是“总有一天了。。。”）这个网络必定会变得非常健壮。</strong></p><blockquote><p>JVM网络，java网络，框架网络等等整合组成整个体系，相信自己肯定有一天会发生质的变化，短期内可能并没有很好地效果，反而会感觉自己哪哪都掌握不牢！！质的变化，对计算机这个这个体系有自己的认识，并不仅仅局限于Java这门语言。</p></blockquote><p>​    学习了JVM这个之后，真后悔没早点学这个，这个真的不是很快就能学习的，不像框架一样基本学一学就用上了，这个需要自己用心去理解，比较偏理论和实践，自己永远不真正环境的调优，只是简单的自我尝试那些效果并不好，应该长期持续的学习并且实战演练，<strong>实战是进步最快的</strong>。我原本打算的是最后学一学的。。。哎然后才发现JVM这个太重要了，这个太有魅力了，真正的让你接触到了一点java代码到底怎么执行的，自己写代码也不少了，从来没有研究过，哎，自己始终在“上层”，混迹“上流社会”，学习了这个让我明白了每一行代码都干了什么（当然不能是每一行那么夸张，自己还没这个水平），让我对内存的分配，一个类的加载，从前我从来没注意过，因为平常写的那些代码怎么可能OOM（顶多研究递归报一个栈溢出），学习了JVM让我对java思想有了很大的进步，不仅是java，是编程的思想，面向对象的思想。</p><p>​    <strong>编程的道路真的是哪有什么岁月静好,不过是有人替你负重前行！就像自己用springboot、springcloud，自己写代码越来越简单，不能总是期待等着出现更好更简单使用的框架，改变自己，别等着别人来改变你！</strong></p><blockquote><p>个人理解，随笔记录，实际上还有很多点，自己的感悟，自己这大学期间的感悟，和生活中的感悟，在<a href="/2020/06/06/life/life/">感悟</a>中慢慢分享。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2020/06/06/java/theme/arithmetic/"/>
      <url>/2020/06/06/java/theme/arithmetic/</url>
      
        <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ol><li><a href="/2020/06/23/java/arithmetic/1/">数组、链表</a></li><li><a href="/2020/06/23/java/arithmetic/2/">栈、队列</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> JAVA </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> JAVA </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>感悟</title>
      <link href="/2020/06/06/life/life/"/>
      <url>/2020/06/06/life/life/</url>
      
        <content type="html"><![CDATA[<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol><li>初心！</li></ol>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> 感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
            <tag> 主题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
