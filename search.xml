<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>clinit()与init()</title>
      <link href="/2020/06/10/java/jvm/2-1-1/"/>
      <url>/2020/06/10/java/jvm/2-1-1/</url>
      
        <content type="html"><![CDATA[<h2 id="lt-clinit-gt-与-lt-init-gt"><a href="#lt-clinit-gt-与-lt-init-gt" class="headerlink" title="&lt;clinit&gt;()与&lt;init&gt;()"></a><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code></h2><h3 id="lt-clinit-gt"><a href="#lt-clinit-gt" class="headerlink" title="&lt;clinit&gt;()"></a><code>&lt;clinit&gt;()</code></h3><ul><li><code>&lt;clinit&gt;()</code>的执行时期为类初始化阶段，并且该方法只能被jvm使用，专门负责类变量的初始化工作。</li><li>Java 类加载的初始化过程中，编译器<strong>按语句在源文件中出现的顺序</strong>，依次自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并产生 <code>&lt;clinit&gt;()</code>方法。 如果类中没有静态语句和静态代码块，那可以不生成该方法。</li><li><code>&lt;clinit&gt;()</code> 不需要显式调用父类（接口除外，接口不需要调用父接口的初始化方法，只有使用到父接口中的静态变量时才需要调用）的初始化方法 <code>&lt;clinit&gt;()</code>，虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。</li></ul><p><strong>类何时进行初始化？（主动引用）</strong></p><blockquote><ol><li>使用new关键字实例化对象的时候；读取或设置一个类型的静态字段（被final修饰的除外，因为已在编译期将结果放入了常量池）；调用一个静态方法。</li><li>使用反射调用。</li><li>初始化类的时候，发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li><li><strong>当使用JDK7新加入的动态语言支持时。（后续在字节码章节详细讲解）</strong></li><li>当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果这个接口的实现类发生了初始化，那么该接口要在其之前被初始化。</li></ol><p><strong>以上的条件是当类或接口未初始化过，即是第一次初始化，才会执行。并且有且只有这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型都不会触发初始化，称为被动引用</strong></p></blockquote><p><strong>被动引用</strong></p><ol><li><p>通过子类引用父类的静态字段，不会导致子类初始化，只会触发父类的初始化。</p></li><li><p>通过数组定义来引用类。</p><blockquote><p>加入有一个Student类</p><p>Student[] studentArray = new Student[10];</p><p>这种情况并不会导致Student类进行初始化。你并没有使用Student类中的任何，但是你声明数组，必然会导致和数组相关的类进行了初始化，[Lorg.fenixsoft.classloading.SuperClass 这个类发生了初始化，这是个与一维数组相关的类，具体不做详细介绍。</p></blockquote></li><li><p>使用类中的被final修饰的静态常量。</p><blockquote><p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p></blockquote></li></ol><h3 id="lt-init-gt"><a href="#lt-init-gt" class="headerlink" title="&lt;init&gt;()"></a><code>&lt;init&gt;()</code></h3><ul><li><p>执行时期：对象的初始化阶段。</p></li><li><p>执行构造器，以及非静态初始化块中的代码。</p><p><strong>实例化一个类的四种途径:</strong></p><ol><li>调用 new 操作符</li><li>调用 Class 或 java.lang.reflect.Constructor 对象的newInstance()方法(反射)</li><li>调用任何现有对象的clone()方法</li><li>通过 java.io.ObjectInputStream 类的 getObject() 方法反序列化</li></ol></li></ul><h3 id="lt-clinit-gt-与-lt-init-gt-执行顺序案例"><a href="#lt-clinit-gt-与-lt-init-gt-执行顺序案例" class="headerlink" title="&lt;clinit&gt;()与&lt;init&gt;()执行顺序案例"></a><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code>执行顺序案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test instance; <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// &lt;clinit&gt;()</span></span><br><span class="line">        System.out.println(<span class="string">"static开始"</span>);</span><br><span class="line">        instance = <span class="keyword">new</span> Test();</span><br><span class="line">        System.out.println(<span class="string">"static结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// &lt;init&gt;()</span></span><br><span class="line">        System.out.println(<span class="string">"构造器开始"</span>);</span><br><span class="line">        System.out.println(<span class="string">"x="</span> + x + <span class="string">";y="</span> + y);</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        System.out.println(<span class="string">"x="</span> + x + <span class="string">";y="</span> + y);</span><br><span class="line">        System.out.println(<span class="string">"构造器结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">1</span>; <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> y; <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test.getInstance();</span><br><span class="line">        System.out.println(<span class="string">"x="</span> + x);</span><br><span class="line">        System.out.println(<span class="string">"y="</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><blockquote><p>static开始<br>构造器开始<br>x=0;y=0<br>x=1;y=1<br>构造器结束<br>static结束<br>x=1<br>y=1</p></blockquote><blockquote><p>从结果中可以看出静态代码块先执行，如果静态代码块中执行了其它方法，则先去执行，然后在回来继续执行，静态代码，这就说明了<code>&lt;clinit&gt;()</code>方法在<code>&lt;init&gt;()</code>之前执行。</p></blockquote><blockquote><p><code>&lt;clinit&gt;()</code>方法就是将一个类中的所有的静态代码块以及类变量整合到一块，注意这里是有顺序的执行，如果其中调用了其它非静态方法，就会执行完后接着执行，如果有父类的话当然执行父类的静态代码块以及类变量，就像下图一样，<strong>把父类和子类的这些静态代码块，类变量全部整合到一块，按照代码编写的顺序来执行。</strong></p><p><code>&lt;init&gt;()</code>也是如此，不过整合的是普通代码块和普通的成员变量了。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200610133639.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载子系统</title>
      <link href="/2020/06/09/java/jvm/2-1/"/>
      <url>/2020/06/09/java/jvm/2-1/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><h3 id="一个类的生命周期"><a href="#一个类的生命周期" class="headerlink" title="一个类的生命周期"></a>一个类的生命周期</h3><p><img src="https://image.cclblog.cn/blog/20200609204057.png" alt=""></p><p>其中加载，验证，准备，初始化，和卸载这五个阶段顺序是确定的，解析阶段则不一定，在某些情况下可以在初始化阶段之后再进行，这是为了支持java语言的运行时绑定特性。</p><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载阶段，java虚拟机需要完成：</p><ol><li><p>通过一个类的全限定名来获取定义此类的二进制字节流。</p></li><li><p>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构。</p></li><li><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p><blockquote><p><strong>这个java.lang.Class对象，将相当于一个模具，假如你在家里面自制雪糕，必须有个模具吧，用这个模具来生产雪糕，假如你这个模具是塑料的。</strong></p><p><strong>1.中的字节流就相当于这个模具的第一道加工，把塑料的原料加工成塑料</strong></p><p><strong>2.中的就是相当于第二道加工，塑料模具基本成型，然后运输到方法区</strong></p><p><strong>3.就相当于这个模具上色美化等，真正的成为了一个可以使用的模具了，然后你就可以用它来制作雪糕，你制作的每个雪糕就是一个个对象，他们的形状是一样的，但是具体的内容即原料颜色等可能不一样，这也就是对象的具体内容可能不同</strong></p></blockquote></li></ol><p><img src="https://image.cclblog.cn/blog/20200609204148.png" alt=""></p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ol><li><p><strong>文件格式验证</strong>，验证字节流是否符合Class文件格式规范。</p><blockquote><p><strong>就是看看你这个文件是不是符合我要加载的，就相当于一个图片还有各种格式.jpg.png，不能你把随便一个文件的后缀名改成.class就加载你吧。</strong></p></blockquote></li><li><p><strong>元数据验证</strong>，对字节码描述的信息进行验证，保证描述的信息符合，比如一个类是否继承了被final修饰的类，如果一个类不是抽象类，是否实现了其父类或接口中要求实现的方法等。</p><blockquote><p><strong>就是看看程序中代码是否做了规定以外的事情，这个规定就好java的语言规范，就相当于一个人要遵守法律一样，就相当于查一下你有没有犯法，做了规定以外的事情。比如你不是我老婆，我和你睡在了一块？？？</strong></p></blockquote></li><li><p><strong>字节码验证</strong>，验证程序语义是否为合法的，符合逻辑的。</p><blockquote><p><strong>就是详细的检查程序代码是否是安全的，会不会对虚拟机造成威胁，这个阶段最为复杂，三言两语很难说清，要检查的东西有很多</strong></p></blockquote></li><li><p><strong>符号引用验证</strong>，验证一个类是否缺少或者被禁止访问它依赖的某些外部类、方法等。</p><blockquote><p><strong>就是我依赖的类，我能不能访问，比如你是我老婆，我能不能和你睡在一块？？？不能这就不出问题了</strong></p></blockquote></li></ol><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值阶段。</p><p>例如一个变量定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>那变量在准备阶段过后的初始值为0而不是123，真正把value赋值的操作是在类的初始化阶段才会被执行。</p><p>但是如果 value被声明为 <strong>final</strong>那么在准备阶段就会给value赋值为123</p><p><strong>例如</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test2 instance = Test2.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test2 test2 = <span class="keyword">new</span> Test2();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a="</span> + a);</span><br><span class="line">        System.out.println(<span class="string">"b="</span> + b);</span><br><span class="line">        <span class="keyword">return</span> test2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序的输出结果为 a=1 b=0 并不是a=1 b=1</strong></p><blockquote><p>分析：</p><ol><li>准备阶段，会将静态变量从上到下设置为默认值，a=0,test2=null,b=0</li><li>当调用一个类的静态变量或静态方法会导致该类初始化，并设置成实际的默认值</li><li>此时a还是0，因为它并没有默认值，然后test2 赋值，调用了Test2()构造方法，对a++,b++ ,此时a = 1 b = 1</li><li>然后给b赋值默认值0，这样就导致了覆盖了前面的1，导致最后b=0</li></ol><p>如果变成private static int b = 0;private static Test2 test2 = new Test2();那最后的结果就变成了a=1 b=1了，和代码的顺序有关。</p></blockquote><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。这个阶段很重要，需要了解Class文件的类文件结构。后续会详细讲解。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类的初始化是类加载过程的最后一个步骤，直到初始化阶段，Java虚拟机才真正开始执行类中编写的java程序代码。</p><p>这个阶段是为静态变量赋予正确的初始值，执行静态代码块，执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。</p><p><strong>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，可以赋值但是不能访问。例如：</strong></p><p><img src="https://image.cclblog.cn/blog/20200609204234.png" alt="">    </p><p><strong>java虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。这个说明父类中定义的静态语句块肯定优先于子类执行。例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a =  <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Test1.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果为2，这不就说明了Test父类中的静态代码块被执行了吗。</p><p><strong>如果一个类中没有静态语句块，也没有对变量的赋值操作，编译器就不会生成<code>&lt;clinit&gt;()</code>方法。</strong></p><p><strong>执行接口的<code>&lt;clint&gt;()</code>方法无需先执行父类的<code>&lt;clinit&gt;()</code>方法</strong>，因为当只有父接口中定义的变量被使用时，父接口才会被初始化。接口的实现类在初始化时也不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p><p><strong><code>&lt;clinit&gt;()</code>在多线程环境下是安全的，并且只会被执行一次</strong>，只会有一个线程去执行，其它线程阻塞，直到执行完该方法后，其它线程才能操作，否则一直阻塞，并且<code>&lt;clinit&gt;()</code>只会被多个线程执行一次，执行完后，其它线程将不会再次执行。</p><blockquote><p><strong>这就好比你的目的是制作一辆汽车（一个类的模板），你有必要去生产两个车壳子（其中的静态代码块，赋值操作）吗？程序中只需要一个类模板就行了，<clinit>()方法就相当于类模板的装饰，装饰这个类一开始有哪些属性，也就是出厂设置吧。其他你初始化赋值<init>()方法，就是你自定义的值了。你开多个线程，就相当于多个工厂，一旦其中一个工厂接下了这份活，你得赶紧通知其他的工厂不要做了，如果几个工厂都生产的话，你总不能只给一份钱吧（浪费系统资源）。</strong></p></blockquote><p>这就相当于生产一个汽车零件，你的目的只是制作一辆汽车，你完全没有必要去生产</p><h4 id="lt-clinit-gt-与-lt-init-gt-方法"><a href="#lt-clinit-gt-与-lt-init-gt-方法" class="headerlink" title="&lt;clinit&gt;()与&lt;init&gt;()方法"></a><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code>方法</h4><p>详情见 <strong><a href="/2020/06/10/java/jvm/2-1-1/"><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code>详解</a></strong></p><h3 id="类加载器ClassLoader（jdk8）"><a href="#类加载器ClassLoader（jdk8）" class="headerlink" title="类加载器ClassLoader（jdk8）"></a>类加载器ClassLoader（jdk8）</h3><p><img src="https://image.cclblog.cn/blog/20200609204422.png" alt=""></p><ul><li><p>启动类加载器（Bootstrap Class Loader）</p><blockquote><ol><li>这个类加载器使用C/C++语言实现的，嵌套在JVM内部。所以java程序中是获取不到的。</li><li>负责加载放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，并且必须被java虚拟机识别（按照文件名识别，.jar），名字不符合即使放在此目录下也不能加载。</li><li>不继承自java.lang.ClassLoader，没有父加载器</li><li>出于安全考虑，只能加载包名为java、javax、sun等开头的类</li></ol></blockquote></li><li><p>扩展类加载器（Extension Class Loader）</p><blockquote><ol><li>这个类加载器是在sun.misc.Launcher$ExtClassLoader中以java代码的形式实现的。</li><li>负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li></ol></blockquote></li><li><p>应用程序类加载器（Application Class Loader）</p><blockquote><p>这个类加载器由sun.misc.Launcher$AppClassLoader来实现。它负责加载用户类路径上所有的类库。如果应用程序中没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p></blockquote></li></ul><h4 id="自定义类加载器步骤"><a href="#自定义类加载器步骤" class="headerlink" title="自定义类加载器步骤"></a>自定义类加载器步骤</h4><ol><li>继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器。</li><li>jdk1.2之前，继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载，之后不在建议这样做，而是建议把自定义的类加载逻辑写在findClass()方法中。</li><li>在编写自定义类加载器时，如果需求简单，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，可以使自定义类加载器编写更加简洁。</li></ol><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><blockquote><p>JVM对class文件采用的是<strong>按需加载</strong>的方式，当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，JVM采用的是<strong>双亲委派机制</strong>。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200611134915.png" alt=""></p><p><strong>双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的类加载器中，只有当父加载器反馈自己无法完成这个加载请求时（它的搜索范围内没有找到所需的类）时，子加载器才会尝试自己去完成加载。</strong></p><blockquote><p>双亲委派机制就是：<code>自底向上检查类是否已经加载，自顶向下尝试是否可以加载类</code></p></blockquote><p><strong>类加载流程图：</strong></p><p><img src="https://image.cclblog.cn/blog/20200611143430.jfif" alt=""></p><p><strong>使用双亲委派机制的优势？（为什么要使用双亲委派机制？优点有哪些？）</strong></p><blockquote><ol><li>避免类的重复加载。</li><li>保护核心API被随意篡改。通过委托方式，不会去篡改核心<code>.class</code>，即使篡改也不会去加载，即使加载也不会是同一个<code>.class</code>对象了。不同的加载器加载同一个<code>.class</code>也不是同一个<code>Class</code>对象。这样保证了<code>Class</code>执行安全。</li></ol></blockquote><p><strong>弊端：</strong></p><blockquote><p>双亲委派模型是单向的，永远是子加载器请求父加载器，这就造成了上层的类加载器无法访问下层类加载器所加载的类。例如常见的JDBC就是这样，JDBC在java.sql.Driver中只定义了接口，具体的实现是由具体的数据库厂商来实现的，例如你使用msql，mysql肯定实现了Driver中的接口，但是它的jar在你的目录下，系统类加载器无法识别，你要是用mysql的话就会出现问题，自然就会出现解决的办法。线程上下文类加载器，和jdk6提供的java.util.ServiceLoader类具体不过多介绍。</p></blockquote><h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><p>当父加载器去委托子加载器去加载类的时候就破坏了这个双亲委派模型，双亲委派模型有三次被破坏，具体不做说明。</p><p>这两篇文章写得挺好。</p><p><a href="https://blog.csdn.net/awake_lqh/article/details/106171219" target="_blank" rel="noopener"></a></p><p><a href="https://blog.csdn.net/sinat_34976604/article/details/86723663" target="_blank" rel="noopener"></a></p><h4 id="jdk9下发生的变化（简）"><a href="#jdk9下发生的变化（简）" class="headerlink" title="jdk9下发生的变化（简）"></a>jdk9下发生的变化（简）</h4><p>jdk9对java进行了模块化，是一次重大的变化，这个模型也随之而变。</p><p><img src="https://image.cclblog.cn/blog/20200611152410.png" alt=""></p><ol><li>扩展类加载器被平台类加载器替代。</li><li>它们都不在派生自java.net.URLClassLoader，而是全部继承于jdk.internal.loader.BuiltinClassLoader。</li><li>这个双亲委派模型发生了变化。</li></ol><blockquote><p>jdk9相当于对java核心代码进行了重构，变成模块化，启动类加载器，平台类加载器，应用程序类加载器，都被明确规定了加载哪些模块的类，这样类的加载过程就变成了，在委派给父类加载器的时候首先看自己是否可以加载此类，这个变化可以说破坏了双亲委派的这个模型。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM简介</title>
      <link href="/2020/06/08/java/jvm/1-1/"/>
      <url>/2020/06/08/java/jvm/1-1/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM（Hotspot）"><a href="#JVM（Hotspot）" class="headerlink" title="JVM（Hotspot）"></a>JVM（Hotspot）</h2><h3 id="程序运行的过程"><a href="#程序运行的过程" class="headerlink" title="程序运行的过程"></a>程序运行的过程</h3><p><img src="https://image.cclblog.cn/blog/20200611155155.png" alt=""></p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p><img src="https://image.cclblog.cn/blog/20200611160308.png" alt=""></p><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p><img src="https://image.cclblog.cn/blog/20200611161129.png" alt=""></p><h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><p><img src="https://image.cclblog.cn/blog/20200611170207.png" alt=""></p><h3 id="JDK不同版本JVM变化"><a href="#JDK不同版本JVM变化" class="headerlink" title="JDK不同版本JVM变化"></a>JDK不同版本JVM变化</h3><ul><li><p>jdk6：存在永久代，静态变量存放在永久代。</p></li><li><p>jdk7：存在永久代，逐步去永久代；将<strong>字符串常量池</strong>和<strong>静态变量</strong>移动到了堆空间中。</p></li><li><p>jdk8：永久代，类型信息、字段、方法、常量保存在本地内存的元空间（Metaspace），字符串常量池、静态变量仍然在堆中。</p></li></ul><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol><li><p>为什么将字符串常量池移入到堆中？（为什么去永久代，改为元空间？）</p><blockquote><ol><li>字符串存在永久代中，容易出现性能问题和内存溢出，因为字符串应该是程序中非常常用的。</li><li>类及方法的信息等比较难确定大小，因此对于永久代的大小指定比较困难。</li><li>永久代会为GC带来不必要的复杂度，并且回收效率很低。</li><li>Oracle将HotSpot与JRockit合二为一，借鉴了后者虚拟机的优点。</li></ol></blockquote></li></ol><h3 id="其他虚拟机"><a href="#其他虚拟机" class="headerlink" title="其他虚拟机"></a>其他虚拟机</h3><p>BEA JRockit，IBM J9不做过多介绍。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2020/06/06/java/jvm/jvm/"/>
      <url>/2020/06/06/java/jvm/jvm/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><ol><li><strong><a href="/2020/06/08/java/jvm/1-1/">JVM简介</a></strong></li></ol><hr><h2 id="内存结构篇"><a href="#内存结构篇" class="headerlink" title="内存结构篇"></a>内存结构篇</h2><ol><li><strong><a href="/2020/06/09/java/jvm/2-1/">类加载子系统</a></strong> </li><li>虚拟机栈（×）</li><li>本地方法栈（×）</li><li>程序计数器（×）</li><li>堆（×）</li><li>方法区（×）</li><li>执行引擎（×）</li><li>本地方法接口/本地方法库（×）</li></ol><hr><h2 id="垃圾回收篇"><a href="#垃圾回收篇" class="headerlink" title="垃圾回收篇"></a>垃圾回收篇</h2><ol><li>垃圾收集器（×）</li><li>内存分配策略（×）</li></ol><h2 id="性能监控与调优篇"><a href="#性能监控与调优篇" class="headerlink" title="性能监控与调优篇"></a>性能监控与调优篇</h2><ol><li>性能监控（×）</li><li>性能调优（×）</li></ol><hr><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><ol><li>StringTable（×）</li><li>字节码（×）</li></ol><hr><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol><li>…（×）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>感悟</title>
      <link href="/2020/06/06/life/life/"/>
      <url>/2020/06/06/life/life/</url>
      
        <content type="html"><![CDATA[<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol><li>算法/多线程/JVM/网络/MySql/Redis/</li><li>提高架构思想/思维</li></ol>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
            <tag> 主题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
