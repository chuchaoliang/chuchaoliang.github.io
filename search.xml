<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>方法区</title>
      <link href="/2020/06/19/java/jvm/2-6/"/>
      <url>/2020/06/19/java/jvm/2-6/</url>
      
        <content type="html"><![CDATA[<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><ul><li>方法区（Method Area）和Java堆一样，是各个线程共享的内存区域。</li><li>《Java虚拟机规范》当中把方法区描述为堆的一个逻辑部分，但是它有一个别名叫<strong>“非堆”</strong>，目的是与Java堆区分开来。</li><li>jdk7以前，把方法区称为永久代。jdk8开始，使用元空间取代了永久代。</li></ul><blockquote><p>jdk7把原本存放在永久代的字符串常量池，静态变量等移到了堆中，直到jdk8才用元空间（Metaspace）替代了永久代，元空间在本地内存中。之所以放入本地内存我感觉就是加大了方法区的内存，避免了很多由于类加载过多导致的OOM。</p></blockquote><ul><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，就会导致OOM。</li><li>方法区同样存在垃圾收集。</li></ul><blockquote><p>这个垃圾收集的条件很苛刻也就为什么说是永久代一样，永久存在了，后续说明。</p></blockquote><h2 id="方法区大小设置"><a href="#方法区大小设置" class="headerlink" title="方法区大小设置"></a>方法区大小设置</h2><p><strong>jdk7以前：</strong></p><ul><li><p>-XX:PermSize来设置永久代初始内存大小 默认20.75M</p></li><li><p>-XX:MaxPermiSize来设置永久代最大可分配空间。32位机器默认64M，64位机器82M</p></li></ul><blockquote><p>JVM加载的类信息容量超出最大值会报OutOfMemoryError:PermGen space</p></blockquote><p><strong>jdk8以后：</strong></p><ul><li>-XX:MetspaceSize和-XX:MaxMetaspaceSize设置元数据区大小。</li></ul><blockquote><p>windows下，-XX:MetspaceSize 默认为21M，-XX:MaxMetaspaceSize默认为<strong>-1</strong>就是没有限制。(这个-1我参考网上的都说的-1，但是我看自己的程序的默认参数不是-1。反正这个了解就好，没必要去记这个)</p><p>内存溢出错误<strong>java.lang.OutOfMemoryError:Metaspace</strong></p></blockquote><p><img src="https://image.cclblog.cn/blog/20200619153032.png" alt=""></p><h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><p>方法区保存着被加载过的每一个类的信息，这些信息由类加载器在加载类的时候，从类的源文件抽取出来。</p><blockquote><p>方法区保存的起始就是每个类的一个模板，Class的元数据。</p></blockquote><p><strong>这些信息有：</strong></p><p><img src="https://image.cclblog.cn/blog/20200619202435.png" alt=""></p><blockquote><p><strong>这些信息没有一个统一的标准，网上说什么的都有，这是我自己综合整理，我感觉这个比较全面。仅供参考啊</strong></p></blockquote><h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>对于每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p><ul><li>类的完整有效名称（包名.类名）</li></ul><blockquote><p>比如java.lang.String</p></blockquote><ul><li><p>类的直接父类的完整有效名</p></li><li><p>类型直接实现接口的有序列表</p></li></ul><blockquote><p>一个类实现的接口可能有多个，多以存放在有序列表中。</p></blockquote><ul><li>类的修饰符</li></ul><blockquote><p>比如public abstract</p></blockquote><hr><blockquote><p>这个就像是查户口一样，看一下你家的详细地址（类的完整有效名称），你的父亲是谁（父类完整有效名称），你的工作（你实现的哪些接口），还有你是什么人（类的修饰符）。</p></blockquote><h3 id="字段信息"><a href="#字段信息" class="headerlink" title="字段信息"></a>字段信息</h3><ul><li>字段修饰符（public、protect、private、default）</li><li>字段声明的顺序</li><li>字段的类型</li><li>字段的名称</li></ul><h3 id="方法信息"><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h3><ul><li>方法名称</li><li>方法的返回类型（包括void）</li><li>方法参数的类型、数目和顺序</li><li>方法的修饰符（public、private、protected、static、final、synchronized、native、abstract）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外）</li></ul><blockquote><p>前面从未说过异常表这次详细分析</p><p>包括异常处理的<strong>开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获异常类的常量池索引</strong></p></blockquote><p><img src="https://image.cclblog.cn/blog/20200619164030.png" alt=""></p><h3 id="类的常量池-运行时常量池"><a href="#类的常量池-运行时常量池" class="headerlink" title="类的常量池/运行时常量池"></a>类的常量池/运行时常量池</h3><p><img src="https://image.cclblog.cn/blog/20200619173204.png" alt=""></p><h4 id="类常量池-静态常量池"><a href="#类常量池-静态常量池" class="headerlink" title="类常量池(静态常量池)"></a>类常量池(静态常量池)</h4><p><img src="https://image.cclblog.cn/blog/20200619180101.png" alt=""></p><ul><li>class常量池用于存储编译器生成的各种<strong>字面量</strong>和<strong>符号引用</strong>。 </li></ul><p><img src="https://image.cclblog.cn/blog/20200619201759.png" alt=""></p><blockquote><p>红色的这几个我仅仅了解，无法说清楚，待我日后补充，其它的三种是网上常见的，并且只有这三种，基本上都是这样，我是参考《深入理解Java虚拟机》第三版 p218。</p></blockquote><ul><li>每个class文件都有一个class常量池。</li></ul><h4 id="运行时常量池-动态常量池"><a href="#运行时常量池-动态常量池" class="headerlink" title="运行时常量池(动态常量池)"></a>运行时常量池(动态常量池)</h4><ul><li>方法区的一部分</li><li>常量池表是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。</li><li>运行时常量池包含多种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里变为了真实地址。</li></ul><blockquote><p>实际上在解析阶段只有能确定唯一版本的方法才能将符号引用直接替换为直接引用，这里也就是前面的章节说过的非虚方法。</p><p>Byte，Short，Integer，Long，Character，Boolean这5中包装类默认创建了数值[-128,127]的相应类型的缓存数据，但是超过此范围仍然回去创建新的对象。这也就是包装类比较是否相等要使用equals()。（Double，Float没有实现常量池技术）</p></blockquote><ul><li>运行时常量池相对于Class文件常量池的另外一个特征就是具备动态性。</li></ul><blockquote><p>String.intern()方法 </p></blockquote><h3 id="非final修饰的类变量"><a href="#非final修饰的类变量" class="headerlink" title="非final修饰的类变量"></a>非final修饰的类变量</h3><ul><li>静态变量和类是关联在一起的，随着类的加载而加载。</li><li>类变量被类的所有实例共享，即使没有类实例时也可以访问。</li></ul><blockquote><p><strong>final型变量的值是在编译期就被确定了，因此被保存在常量池中。</strong></p></blockquote><h3 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h3><ul><li><p>jvm必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么jvm会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。</p></li><li><p>jvm在动态链接的时候需要这个信息。当解析一个类型到另一个类型的引用的时候，jvm需要保证这两个类型的类加载器是相同的。这对jvm区分名字空间的方式是至关重要的。</p></li><li><p>比较两个类是否相等也需要比较类加载器是否是相同的。</p></li><li><p>垃圾收集的时候也需要参考这个类的加载器是否不再使用！</p></li></ul><h3 id="对Class类的引用"><a href="#对Class类的引用" class="headerlink" title="对Class类的引用"></a>对Class类的引用</h3><p>jvm为每个加载的类都创建一个java.lang.Class的实例（<strong>存储在堆上</strong>）。而jvm必须以某种方式把Class的这个实例和存储在方法区中的类型数据联系起来， 因此，类的元数据里面保存了一个Class对象的引用；</p><h3 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h3><blockquote><p><strong>引用：</strong></p><p>为了提高访问效率，必须仔细的设计存储在方法区中的数据信息结构。除了以上讨论的结构，jvm的实现者还可以添加一些其他的数据结构，如方法表。jvm对每个加载的非虚拟类的类型信息中都添加了一个方法表，方法表是一组对类实例方法的直接引用(包括从父类继承的方法。jvm可以通过方法表快速激活实例方法。(译者：这里的方法表与C++中的虚拟函数表一样，但java方法全都 是virtual的，自然也不用虚拟二字了。正像java宣称没有 指针了，其实java里全是指针。更安全只是加了更完备的检查机制，但这都是以牺牲效率为代价的,个人认为java的设计者 始终是把安全放在效率之上的，所有java才更适合于网络开发)</p></blockquote><h2 id="栈、堆、方法区的交互"><a href="#栈、堆、方法区的交互" class="headerlink" title="栈、堆、方法区的交互"></a>栈、堆、方法区的交互</h2><p><img src="https://image.cclblog.cn/blog/20200619211848.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础知识点</title>
      <link href="/2020/06/18/java/javase/javaSE/"/>
      <url>/2020/06/18/java/javase/javaSE/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA基础知识点"><a href="#JAVA基础知识点" class="headerlink" title="JAVA基础知识点"></a>JAVA基础知识点</h1><p>编写中</p>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机栈</title>
      <link href="/2020/06/17/java/jvm/2-3/"/>
      <url>/2020/06/17/java/jvm/2-3/</url>
      
        <content type="html"><![CDATA[<h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><ul><li>本地方法栈与虚拟机栈所发挥的作用是非常相似的，区别就是虚拟机栈执行Java方法，本地方法栈为本地（Native）方法服务。</li></ul><blockquote><p>native方法是Java通过JNI（java native interface）直接调用本地C/C++库，这个就相当于C/C++暴露给Java的一个接口，Java 通过调用这个接口从而调用到 C/C++ 方法。</p></blockquote><ul><li>本地方法栈线程私有的。</li><li>本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。</li><li>它的具体做法就是本地方法栈登记native方法，在执行引擎执行时候加载本地方法库。</li></ul><blockquote><p>当调用的是 native 方法时，虚拟机会保持 Java 虚拟机栈不变，也不会向 Java 虚拟机栈中压入新的栈帧，虚拟机只是简单地动态连接并直接调用指定的 native 方法</p></blockquote><ul><li><strong>Hotspot虚拟机中，直接将本地方法栈和虚拟机栈合二为一。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆</title>
      <link href="/2020/06/17/java/jvm/2-5/"/>
      <url>/2020/06/17/java/jvm/2-5/</url>
      
        <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><ul><li>Java堆是虚拟机所管理内存最大的一块区域，并且一个JVM实例只有一个堆，堆是Java内存管理的核心区域。</li><li>Java堆是被所有线程共享的，但是Java堆中还可以划分线程私有的缓冲区（Thread Local Allocation Buffer， TLAB），用来提高对象分配时的效率。</li><li><strong>Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</strong></li><li>Java的程序中，“几乎”所有的对象实例都在这里分配内存。</li></ul><blockquote><p>这里有特殊情况 逃逸分析技术的日渐强大 <strong>栈上分配、标量替换</strong>（后续说明）导致了”几乎”这一情况的发生</p></blockquote><ul><li>方法结束后，堆中的对象不会马上移除，仅仅在垃圾收集的时候才会被移除。</li><li>堆是垃圾收集的重点对象。</li></ul><p><img src="https://image.cclblog.cn/blog/20200617172417.png" alt=""></p><h2 id="堆空间内部结构"><a href="#堆空间内部结构" class="headerlink" title="堆空间内部结构"></a>堆空间内部结构</h2><p><img src="https://image.cclblog.cn/blog/20200617174629.png" alt=""></p><blockquote><p>我认为之所以这种分代设置都是为了方便垃圾收集，基于分代思想，一个应用程序中对象的声明周期不尽相同，每次垃圾回收肯定不能堆空间全部扫描，这样效率太低了，所以才有了对象分代这个思想，不是为了分代而分代，而是为了程序更好的性能，就像不是为了多线程而去盲目使用多线程，而是根据实际情况来使用，一切都要考虑实际情况。</p></blockquote><p><strong>这里不讨论永久代（元空间）！</strong></p><h3 id="年轻代、老年代"><a href="#年轻代、老年代" class="headerlink" title="年轻代、老年代"></a>年轻代、老年代</h3><blockquote><p>存储在JVM中的Java对象有两类：</p><ol><li>一类是生命周期特别短，就像是你写的普通方法中声明的局部变量，大部分都是这样的情况，这类对象创建和消亡都十分迅速。</li><li>另一类对象的声明周期十分的长，这样的对象一般存放在老年代。</li></ol></blockquote><ul><li>几乎所有的Java对象都是在Eden区被new出来的。</li><li>绝大部分的Java对象的销毁都是在新生代进行的。</li><li>“-Xmn参数可以设置新生代最大内存大小”</li></ul><h2 id="设置堆内存大小"><a href="#设置堆内存大小" class="headerlink" title="设置堆内存大小"></a>设置堆内存大小</h2><ul><li>堆的大小在JVM启动时就已经设定好了，可以通过选项“-Xmx”和“-Xms”来进行设置。</li></ul><blockquote><p>“-Xms”用于表示堆区的起始内存，等价于-XX:InittalHeapSize</p><p>“-Xmx”用于表示堆区的最大内存，等价于-XX:MaxHeapSize</p></blockquote><ul><li><p>堆中的内存大小超过“-Xmx“指定的最大内存的时候，就会抛出OutOfMemoryError异常。</p></li><li><p><strong>一般会将-Xms和-Xmx两个参数配置相同的值，目的是为了能够在java垃圾回收机制清理完堆区后不需要重新计算堆区的大小，从而提高性能。</strong></p></li><li><p>默认情况下，初始内存大小：物理电脑内存大小/64；最大内存大小：物理电脑内存大小/4；</p></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Test&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Test());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/blog/20200617181558.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200617181719.png" alt=""></p><blockquote><p>这个结果很明显了正常情况下程序肯定不会OOM -Xms -Xmx 改变了堆的大小，导致这一情况发生。</p></blockquote><h2 id="对象分配的过程"><a href="#对象分配的过程" class="headerlink" title="对象分配的过程"></a>对象分配的过程</h2><ol><li>new的对象先放到Eden区，如果超大对象直接分配到老年代。</li><li>当Eden区空间填满时，创建新的对象，就会触发JVM的垃圾回收机制，对新生区进行垃圾回收（Minor GC），然后在加载新的对象放到Eden区。</li><li>将Eden区中剩余的对象移动到幸存者0区。</li><li>如果再次触发垃圾回收机制，幸存的对象（包括幸存者0区的对象）会全部放入幸存者1区。如此反复</li><li>当一个对象经历15次这样的操作后，历经磨难，就会进入养老区。</li></ol><blockquote><p>15次只是JVM一个默认值，-XX:MaxTenuringThreshold= 这个参数可以设置 15次在Hotspot虚拟机中是最大值。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200617182949.png" alt=""></p><blockquote><p>上面的描述实际上很不全面，你有可能会想：</p><p><strong>进行垃圾回收之后Eden还是空间不足怎么办？</strong></p><p><strong>垃圾回收后将存活的对象移动到其中的一个幸存区的时候内存不够怎么办？</strong></p><p><strong>新对象难道必须经过15次洗礼才能进入到老年区养老吗？</strong></p><p>利用具体的流程图来解释</p></blockquote><p><strong>具体的流程图：</strong></p><p><img src="https://image.cclblog.cn/blog/20200617203602.png" alt=""></p><blockquote><p>这个图算是比较详细的，解释了上面的几个问题。</p></blockquote><h2 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h2><p>JVM在进行GC的时候，肯定不是这三个区域一块回收，要是这样分代有什么意义。大部分回收的是新生代。</p><hr><p>Minor GC/Young GC：只是新生代的垃圾收集。</p><p>Major GC/Old GC：只是老年代的垃圾收集</p><blockquote><p>只有CMS GC会有单独收集老年代的行为。其它的情况就是Full GC。</p><p>还有一种混合收集（Mined GC）只有G1会有这种行为，G1这个垃圾收集器组成很特殊。</p></blockquote><p>Full GC：收集整个java堆和方法区的垃圾。</p><h3 id="GC触发机制"><a href="#GC触发机制" class="headerlink" title="GC触发机制"></a>GC触发机制</h3><h4 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h4><ol><li>当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor区满不会触发GC。Survivor区只能等待Eden区被动清理。这个清理会清理整个新生代。</li><li>Minor GC十分频繁（这里的频繁是相对来说的），回收速度非常快。</li><li>Minor GC会导致STW，暂停用户线程，等待垃圾回收结束，用户线程才恢复运行。</li></ol><h4 id="Major-GC、Full-GC"><a href="#Major-GC、Full-GC" class="headerlink" title="Major GC、Full GC"></a>Major GC、Full GC</h4><ol><li>出现Major GC，一般会伴随至少一次的Minor GC（大部分垃圾收集器都是这样Parallel Scavenge这个比较特殊）。</li><li>如果Major GC后内存还不足，那就完蛋，直接OOM。</li><li>Major GC 很慢，STW时间很长（相对Minor GC）。</li></ol><h2 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>对象的创建在堆中十分频繁，因为堆是线程共享的，在并发的环境下在堆区中划分内存空间是线程不安全的，为了避免多个线程操作同一地址，需要使用加锁的机制，这导致了分配速度有所影响，但是TLAB是堆中开辟的每个线程私有的，就缓解了这个问题。</p><blockquote><p>上面之所以说的缓解是因为并不是全部的对象都是这种方式分配内存的，也不可能这样，这个TLAB的空间非常小，仅仅为Eden空间的1%，-XX:TLABWasteTargetPercent可以设置，虽然只是缓解，但是这也是JVM分配内存的一个首选方式。</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p><strong>TLAB是JVM为每个线程分配的一个私有缓存区域，这个区域在Eden空间内。</strong></p></li><li><p>TLAB快速分配内存，这种内存分配方式称为<strong>快速分配策略。</strong></p></li><li><p>-XX:UseTLAB 设置是否开启TLAB。</p></li><li><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p></li></ul><blockquote><p>分配内存的方式在垃圾那章节说明！</p></blockquote><h2 id="堆空间各种参数总结"><a href="#堆空间各种参数总结" class="headerlink" title="堆空间各种参数总结"></a>堆空间各种参数总结</h2><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>-XX: +PrintFlageInitial</td><td>查看所有的参数的默认初始值</td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>设置新生代对象最大年龄</td></tr><tr><td><strong>-Xms</strong></td><td>初始堆空间内存（默认本机物理内存1/64）</td></tr><tr><td><strong>-Xmx</strong></td><td>最大堆空间内存（默认本机物理内存1/4）</td></tr><tr><td>-Xmn</td><td>设置新生代大小</td></tr><tr><td>-XX:NewRatio</td><td>配置新生代与老年代在堆结构的占比</td></tr><tr><td>-XX:SurvivorRatio</td><td>设置新生代中Eden和s0/s1空间比例</td></tr><tr><td><strong>-XX:+PringGCDetails</strong></td><td>输出详细的GC处理日志</td></tr><tr><td>-XX:HandlePromotionFailure</td><td>是否设置空间分配担保（具体百度这个参数我仅仅了解）</td></tr></tbody></table><h3 id="jinfo查看默认参数"><a href="#jinfo查看默认参数" class="headerlink" title="jinfo查看默认参数"></a>jinfo查看默认参数</h3><p><img src="https://image.cclblog.cn/blog/20200617222501.png" alt=""></p><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>这个博客写的不错：我确实对这个理解不够，不做总结。</p><p><a href="https://www.jianshu.com/p/580f17760f6e" target="_blank" rel="noopener">https://www.jianshu.com/p/580f17760f6e</a> </p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><blockquote><p>平常写代码的时候能使用局部变量的，就不要使用在方法外定义。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC</title>
      <link href="/2020/06/17/java/juc/juc/"/>
      <url>/2020/06/17/java/juc/juc/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>总结中。。。</p>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> JAVA </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> JAVA </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分派</title>
      <link href="/2020/06/16/java/jvm/2-2-1/"/>
      <url>/2020/06/16/java/jvm/2-2-1/</url>
      
        <content type="html"><![CDATA[<h1 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h1><h2 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h2><ul><li><p>所有依赖<strong>静态类型</strong>来决定方法执行版本的<strong>分派</strong>动作，都成为静态分派。</p></li><li><p>静态分配的最典型应用表现就是<strong>方法重载。</strong></p></li><li><p>静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。</p></li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Magpie</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(Bird bird)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是鸟！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(Sparrow human)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是鸟中的麻雀！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(Magpie human)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是鸟中的喜鹊！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bird sparrow = <span class="keyword">new</span> Sparrow();</span><br><span class="line">        Bird magpie = <span class="keyword">new</span> Magpie();</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.talk(sparrow);</span><br><span class="line">        test.talk(magpie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><blockquote><p>我是鸟！<br>我是鸟！</p></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><img src="https://image.cclblog.cn/blog/20200616205136.png" alt=""></p><blockquote><p>理解这个要明白<strong>重载是根据<code>静态类型</code>而不是<code>实际类型</code>来判断选择哪个方法的。</strong></p><p>Bird sparrow = new Sparrow();</p><p>这个Bird 称为变量的 <strong>“静态类型”</strong>，而Sparrow 则是 变量的 <strong>“实际类型”</strong>。变量本身的静态类型是不会发生变化的，在编译期是可知的，上图也说明了这一点，程序还未运行便知道要调用的方法。实际类型变化的结果是在运行期间才可以确定的。编译器在编译程序的时候并不知道一个对象的实际类型是什么。</p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void String(Object param) &#123;</span><br><span class="line">        System.out.println(&quot;object&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test(int param) &#123;</span><br><span class="line">        System.out.println(&quot;int&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test.test(&#39;a&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个代码输出什么？</strong></p><p><img src="https://image.cclblog.cn/blog/20200616210755.png" alt=""></p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><blockquote><p>这说明了重载的版本并不是唯一的，但是往往必须确定一个<strong>“相对更加合适的”</strong>版本。</p><p>‘a’是char类型，就去寻找char类型的重载方法，如果此方法不存在，他就会自动进行类型转换’a’也可以代表数字97。所以他就会去执行int类型的重载方法了。</p></blockquote><h2 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h2><ul><li>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</li></ul><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是鸟！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是鸟中的麻雀！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Magpie</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是鸟中的喜鹊！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bird sparrow = <span class="keyword">new</span> Sparrow();</span><br><span class="line">        Bird magpie = <span class="keyword">new</span> Magpie();</span><br><span class="line">        sparrow.talk();</span><br><span class="line">        magpie.talk();</span><br><span class="line">        sparrow = <span class="keyword">new</span> Magpie();</span><br><span class="line">        sparrow.talk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><blockquote><p>我是鸟中的麻雀！<br>我是鸟中的喜鹊！<br>我是鸟中的喜鹊！</p></blockquote><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><blockquote><p>显然重写不是根据静态类型确定调用哪个方法的，而是根据实际类型。子类重写了父类的方法不同的子类必然产生的动作不同，这肯定就不能依靠静态类型来确定了。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200616212607.png" alt=""></p><p><strong>分析main()方法中的字节码:</strong></p><p><img src="https://image.cclblog.cn/blog/20200616214243.png" alt=""></p><h4 id="invokevirtual"><a href="#invokevirtual" class="headerlink" title="invokevirtual"></a>invokevirtual</h4><p>运行时解析过程</p><ol><li><strong>找到操作数栈顶的第一个元素所指向的对象的实际类型，记做C</strong></li><li><strong>如果在类型C中找到与常量中描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；</strong>不通过则返回java.lang.IllegalAccessError异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstartMethodError异常。</li></ol><blockquote><p>这个说的很明白了，第1步不就找到实际类型吗！！<strong>这个过程就是Java语言中方法重写的本质。</strong></p></blockquote><p>既然这种多态性的根源是和invokevirtual这个指令有关，那么这个只能对方法生效对字段是无效的，因为字段并不使用这个指令，<strong>字段永远没有多态这个特性至少目前还没有(jdk14)</strong>。</p><h2 id="彻底理解多态"><a href="#彻底理解多态" class="headerlink" title="彻底理解多态"></a>彻底理解多态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> B().getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span> <span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">            setValue(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value= value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                value ++;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.setValue(value);</span><br><span class="line">                System.out.println(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(<span class="number">5</span>);</span><br><span class="line">            setValue(getValue()- <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.setValue(<span class="number">2</span> * value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><blockquote></blockquote><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序计数器</title>
      <link href="/2020/06/12/java/jvm/2-4/"/>
      <url>/2020/06/12/java/jvm/2-4/</url>
      
        <content type="html"><![CDATA[<h1 id="程序计数器（PC寄存器）"><a href="#程序计数器（PC寄存器）" class="headerlink" title="程序计数器（PC寄存器）"></a>程序计数器（PC寄存器）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>程序计数器是一个记录着当前线程所执行的字节码的行号指示器。</code></p><p>程序计数器（Program Counter Register）是一个非常小的空间，可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><p><strong>如果程序正在执行的是本地（Native）方法，这个计数器的值就为空（Undefined）。</strong>native方法是java通过JNI直接调用C/C++库，相当于C/C++暴露给java的一个接口，java调用这个接口就相当于C/C++去执行相应的代码，肯定不会产生相应的字节码，既然没有字节码，那程序计数器不就没得记录。</p></li><li><p><strong>线程私有，每个线程都存在一个程序计数器。</strong></p></li><li><p><strong>此内存区域是唯一一个不存在OOM情况的区域。</strong></p></li><li><p>占用内存非常小，可以忽略不计。</p></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后</p><p><img src="https://image.cclblog.cn/blog/20200612175746.png" alt=""></p><p>我是用的idea的Jclasslib插件进行反编译的，也可以使用javap来反编译。</p><p>这个类似于行号的就是字节码指令的地址，程序计数器中就是要记录这些地址。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li><strong>为什么使用程序计数器来记录当前线程的执行地址呢？（程序计数器的作用？）</strong></li></ol><blockquote><p>因为CPU需要不停的切换各个线程，这时候CPU切换回需要执行的线程后，就得知道接着从哪开始继续执行。</p><p>JVM的字节码解释器需要通过改变程序计数器的值来明确下一条应该执行什么样的字节码指令。</p></blockquote><ol start="2"><li><strong>程序计数器为什么被设定为线程私有？</strong></li></ol><blockquote><p>JVM的多线程是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的。也就是说，某个线程在执行过程中可能会因为时间片耗尽而被挂起，而另一个线程获取到时间片开始执行。当被挂起的线程重新获取到时间片的时候，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置，在JVM中，通过程序计数器来记录某个线程的字节码执行位置。因此，程序计数器是具备线程隔离的特性，也就是说，每个线程工作时都要有属于自己的独立计数器。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机栈</title>
      <link href="/2020/06/12/java/jvm/2-2/"/>
      <url>/2020/06/12/java/jvm/2-2/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>Java虚拟机栈线程私有，生命周期与线程相同。描述的是Java方法执行的线程内存模型。</p></li><li><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够内存会抛出OutOfMemoryError异常。</p></li></ul><blockquote><p>栈是运行时的单位，而堆是存储的单位。栈解决程序的运行问题，即程序如何执行，数据如何处理。堆解决的是数据的存储问题，即数据怎么放。</p><p>栈就好比你程序中的业务代码，而堆就是存储数据的数据库，数据一个程序是灵魂，如果数据不做处理、可视化，完全是死的数据，我认为是完全没有意义的。</p></blockquote><h3 id="设置栈的大小"><a href="#设置栈的大小" class="headerlink" title="设置栈的大小"></a>设置栈的大小</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码就会导致StackOverflowError异常。递归调用操作不当十分容易导致栈溢出。</p><p><img src="https://image.cclblog.cn/blog/20200613161704.png" alt=""></p><p>test2()这个方法执行了10271次才溢出，可以通过<code>-Xss</code>选项来设置线程的最大栈空间，这个栈空间的大小直接决定了函数的调用的最大深度。</p><p><img src="https://image.cclblog.cn/blog/20200613162335.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200613162909.png" alt=""></p><p>发现test2()方法只运行了541次，得出<code>-Xss</code>改变了栈空间的大小。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>栈是一种快速有效的分配方式，访问速度仅次于程序计数器。</li><li>对于栈来说不存在垃圾回收的问题。</li></ul><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p><strong>栈的存储单位就是栈桢。</strong></p><p>每个方法被执行的时候，java虚拟机都会同步创建一个栈桢用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法从被调用到执行完毕的过程，就对应着一个栈桢在虚拟机中从入栈到出栈的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个程序main()方法中调用test1()，test1()调用test2()，test2()调用test3()。</p></blockquote><p>将程序在test1()处打个断点，平时写代码调试的时候，经常接触栈栈桢，只是有可能不知道这是而已。</p><p><img src="https://image.cclblog.cn/blog/20200613164510.png" alt=""></p><p>然后步入接着执行程序</p><p><img src="https://image.cclblog.cn/blog/20200613164755.png" alt=""></p><p>继续步入执行</p><p><img src="https://image.cclblog.cn/blog/20200613165010.png" alt=""></p><p>test3()方法执行完毕后开始出栈。</p><p><img src="https://image.cclblog.cn/blog/20200613165154.png" alt=""></p><p>之后就是test2出栈test1出栈最后main出栈，程序执行结束。</p><p>这里如果调试的时候执行了下一步怎么返回上一步执行，退回去重新操作。idea提供了丢帧的操作。</p><p><img src="https://image.cclblog.cn/blog/20200613165543.png" alt=""></p><p>抛弃test1()后就回到main()这个栈桢了。</p><p><img src="https://image.cclblog.cn/blog/20200613172005.gif" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200613172046.gif" alt=""></p><blockquote><p>这个就像你写的程序一个方法中调用另一个方法，就相当于妈妈让你爸爸去买醋，然后你爸爸让你去买醋，你买回来后高速你爸爸我买回来了，然后就没你的事情了，然后你爸爸高速你妈妈，买回来了。。。当然你也可以直接告诉你妈妈，，但是程序不行啊。这就是一个入栈出栈的过程，如果你爸爸告诉你去买，你告诉你爸爸去买，无限循环，不就导致错误了吗。</p></blockquote><h2 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h2><ul><li>不同线程中包含的栈桢是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li><li>java方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用return命令；另外一种是抛出异常；</strong>不管使用哪种方式，都会导致栈帧被弹出。</li></ul><h2 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h2><ul><li><strong>局部变量表（*）</strong></li><li><strong>操作数栈（*）</strong></li><li>动态连接</li><li>方法返回地址</li><li>一些附加的信息</li></ul><p><img src="https://image.cclblog.cn/blog/20200613180052.png" alt=""></p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><ul><li><p>局部变量表(Local Variables Table)是一组变量值的存储空间，用于存放<strong>方法参数</strong>和<strong>方法内部定义的局部变量</strong>这些数据类型包括各大基本数据类型、对象引用（reference），以及returnAddress类型。</p><blockquote><p>基本数据类型无需多言，reference就是一个对象实例的引用。returnAddress是为了字节码指令jsr、jsr_w和ret服务的，指向一条字节码指令的地址，目前已经很少使用。</p></blockquote></li><li><p>由于局部变量表在栈帧之中，因此，如果函数的参数和局部变量很多，会使得局部变量表膨胀，因此，每一次函数调用，其局部变量表会占用更多的栈空间，最终导致函数的嵌套调用的次数减少。</p><blockquote><p><strong>栈大小固定，栈中存放栈帧，栈帧中有局部变量表，局部变量表存放局部变量，局部变量很多，占用空间就大，导致栈中可以存放的栈桢变少，自然函数嵌套的次数也就减少</strong></p></blockquote></li><li><p>局部变量表是建立在线程的栈上，是线程的私有数据，<strong>不存在数据安全问题。</strong></p></li><li><p><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，存储在方法的Code属性的maximum local variables数据项中。（后续会说明）在方法运行期间是不会改变局部变量表的大小的。</p></li></ul><blockquote><p>局部变量表中的容量的意思是你这个方法中有多少局部变量，和方法参数，这个肯定是确定的啊，在编译期间就确定的。你自己都能数一数一个方法中有多少变量和参数，更别说编译器了。</p></blockquote><ul><li>局部变量表中的变量只在当前方法中有效。当在方法执行的时候，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也随之销毁。</strong></li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">short</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> d = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">float</span> e = <span class="number">11.2F</span>;</span><br><span class="line">    <span class="keyword">double</span> f = <span class="number">1.1</span>;</span><br><span class="line">    <span class="keyword">char</span> g = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">boolean</span> i = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    String h = <span class="string">"aa"</span>;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析test1()方法的局部变量表：</strong></p><p><img src="https://image.cclblog.cn/blog/20200613220859.png" alt=""></p><p><strong>因为这是静态方法所以并不存在该对象的引用this，如果不是静态方法，index为0的位置就是隐藏的this。</strong></p><p><img src="https://image.cclblog.cn/blog/20200613222439.png" alt=""></p><h4 id="变量槽Slot"><a href="#变量槽Slot" class="headerlink" title="变量槽Slot"></a>变量槽Slot</h4><ul><li>局部变量表，最基本的存储单元是变量槽</li><li>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</li></ul><blockquote><p>byte、short、char在存储前会被转换为int，boolean也被转换为int，0为false，非0表示true。</p><p><strong>long和double占据两个变量槽。</strong></p></blockquote><ul><li>JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量的值。</li><li><strong>如果要访问局部变量表中的一个64bit（long、double）的局部变量值时，只需要使用前一个索引即可。这也是JVM规定必须的。</strong></li><li><strong>如果一个方法不是静态方法，那么该对象的引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。</strong></li><li><strong>变量槽（Slot）可以重复利用</strong></li></ul><h5 id="变量槽的重复利用"><a href="#变量槽的重复利用" class="headerlink" title="变量槽的重复利用"></a>变量槽的重复利用</h5><p>栈帧中的局部变量表中的槽位是可以重复利用的，如果一个局部变量出了它的作用域，那么在其作用域之后申明的局部变量就会复用过期局部变量的槽位，从而达到节省资源的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/blog/20200613224813.png" alt=""></p><blockquote><p>这个代码不是静态代码，所以肯定存在一个this这个对象的引用，为什么是2个槽位，而不是3个槽位，代码中b这个变量出了代码块后，这个变量槽就没必要存储它了，然后a也没必要在重开一个槽位，就相当于占用了b的槽位，把b替换了。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200613225335.png" alt=""></p><blockquote><p>这是你可能会想，如果a是long或者double类型的占用2个槽位，但是b只空出一个槽位，那该怎么算？如果这样的话，槽位就会变成3，而不是4，照样重用那个槽位，然后在添加上一个槽位就可以了。</p></blockquote><p> <img src="https://image.cclblog.cn/blog/20200614154741.png" alt=""></p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><ul><li><p>后入先出（Last In First Out）栈，也常被称作操作栈。</p></li><li><p>同局部变量表一样，操作数栈的最大深度也在编译的时候被写入Code属性的max_stacks数据项之中。</p></li><li><p>栈中的任何一个元素都是可以任意的Java数据类型。<strong>32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。</strong></p></li><li><p>操作数栈<strong>不是采用访问索引的方式来进行数据访问的</strong>，而是只能通过标准的入栈(push)和出栈(pop)操作来完成一次数据访问。</p></li><li><p>操作数栈中元素类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器必须严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。</p></li><li><p><strong>Java虚拟机的解释执行引擎被称为“基于栈的执行引擎”，里面的“栈”就是操作数栈。</strong></p></li></ul><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/blog/20200615162713.png" alt=""></p><p><strong>编译的时候局部变量表和操作数栈的大小和深度就是确定的。</strong></p><p><img src="https://image.cclblog.cn/blog/20200615164022.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164049.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164109.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164158.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164159.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164200.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164302.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164301.png" alt=""></p><h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><ul><li>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现<strong>动态连接。</strong></li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。比如：描述一个方法调用另外的其他方法时候，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态连接的作用就是为了将这些符号引用转换为调用方法的直接引用。</strong></li></ul><blockquote><p>具体描述在方法调用中说明。</p></blockquote><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><ul><li>方法调用阶段的唯一任务就是确定被调用方法到底是哪个方法。一切方法调用在Class文件里面存储的都只是<strong>符号引用</strong>，而不是<strong>方法在运行时内存布局中入口地址（这个就是直接引用）</strong>。</li><li>某些调用需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</li></ul><p><strong>例如</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"琦玉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main()方法中调用了test1()方法，它的字节码为</p><p><img src="https://image.cclblog.cn/blog/20200616155943.png" alt=""></p><p>在java虚拟机中支持以下5条方法调用字节码指令：</p><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td><strong>invokestatic</strong></td><td>用于调用静态方法</td></tr><tr><td><strong>invokespecial</strong></td><td>用于调用实例构造方法<code>&lt;init&gt;()</code>、私有方法和父类中的方法</td></tr><tr><td><strong>invokevirtual</strong></td><td>用于调用所有的<strong>虚方法</strong></td></tr><tr><td><strong>invokeInterface</strong></td><td>用于调用接口方法，会在运行时再确定一个实现该接口的对象</td></tr><tr><td><strong>invokedynamic</strong></td><td><strong>这个最为特殊，具体说明。</strong></td></tr></tbody></table><h4 id="虚方法、非虚方法"><a href="#虚方法、非虚方法" class="headerlink" title="虚方法、非虚方法"></a>虚方法、非虚方法</h4><ul><li>只要是能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，java语言里符合这个条件的方法有<strong>静态方法、私有方法、实例构造器、父类方法</strong>这4种，再加上被final修饰的方法（尽管它是使用invokevirtual指令调用），这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为<code>非虚方法</code>与之相反就是<strong>虚方法</strong>。</li></ul><blockquote><p>静态方法、私有方法、实例构造器、父类方法还有被final修饰的方法有一个共同的特点就是它们都不能通过继承或别的方式重写，之所以叫做非虚我认为就是十分确定的，你调用这些方法能特别肯定的，你的程序中只有一个地方有该方法，是十分确定的，不像有些方法可以重写，重载一样，你调用一个方法系统不知道调用哪个，必须等到程序真正运行调用的时候才能知道，虚无缥缈，所以就叫做虚方法了。</p></blockquote><h4 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h4><p><a href="/2020/06/12/2-2-1">通过分派彻底理解重载和重写</a></p><h4 id="invokedynamic"><a href="#invokedynamic" class="headerlink" title="invokedynamic"></a>invokedynamic</h4><ul><li><p>jdk7中增加的一个指令，<strong>这个指令是为了实现动态类型语言支持而做出的改进。</strong></p></li><li><p>每一处含有invokedynamic指令的位置都被称作“动态调用点”，虽然这个指令是jdk7引用的，但是并没有提供直接生成该指令的方法。<strong>直到java8中的Lambda表达式的出现，invokedynamic指令的生成，在java中才有了直接的生成方式。</strong></p></li></ul><p><strong>动态类型、静态类型语言</strong></p><p>动态语言的特征是它的类型检查的主体过程是在运行期间而不是编译期进行的（例如js、php、python等）相对的在编译期间就进行类型检查过程的语言，例如c++、java就是最常用的静态类型语言。</p><blockquote><p>a = 1; 这个语句在python中就可以执行，但是在java中就会报错，静态语言是对a变量的检查，而动态语言是对1这个值的检查，根据这个值来确定变量a的类型。一个运行时确定，一个编译期确定。</p></blockquote><p><strong>这两个类型的语言各自优点？</strong></p><blockquote><p><strong>静态语言：</strong>能够在编译期确定变量类型，十分严谨，利于系统的稳定性。</p><p><strong>动态语言：</strong>运行时才确定类型，十分灵活，并且静态类型花费很多代码才能实现的功能，动态语言可能很简洁就能实现，提高了开发的效率。</p></blockquote><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>当一个方法开始执行后只有两种方法可以退出这个方法：</p><ol><li>执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层方法的调用者，这种退出的方式为“正常调用完成”。</li></ol><blockquote><p>ireturn(返回值是boolean，byte，char，short和int时使用)、lreturn、freturn、dreturn、areturn（引用类型）、return（void类型）</p></blockquote><ol start="2"><li>方法在执行的过程中遇到了异常，并且这个异常并未在方法内进行处理，这种退出方法的方式称为“异常调用完成”。</li></ol><blockquote><p>一个方法使用异常完成出口的方式退出，是不会给它的上层调用者提供任何返回值的。</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p><strong>方法退出的过程就等同于当前栈帧出栈。这是需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</strong></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clinit()与init()</title>
      <link href="/2020/06/10/java/jvm/2-1-1/"/>
      <url>/2020/06/10/java/jvm/2-1-1/</url>
      
        <content type="html"><![CDATA[<h2 id="lt-clinit-gt-与-lt-init-gt"><a href="#lt-clinit-gt-与-lt-init-gt" class="headerlink" title="&lt;clinit&gt;()与&lt;init&gt;()"></a><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code></h2><h3 id="lt-clinit-gt"><a href="#lt-clinit-gt" class="headerlink" title="&lt;clinit&gt;()"></a><code>&lt;clinit&gt;()</code></h3><ul><li><code>&lt;clinit&gt;()</code>的执行时期为类初始化阶段，并且该方法只能被jvm使用，专门负责类变量的初始化工作。</li><li>Java 类加载的初始化过程中，编译器<strong>按语句在源文件中出现的顺序</strong>，依次自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并产生 <code>&lt;clinit&gt;()</code>方法。 如果类中没有静态语句和静态代码块，那可以不生成该方法。</li><li><code>&lt;clinit&gt;()</code> 不需要显式调用父类（接口除外，接口不需要调用父接口的初始化方法，只有使用到父接口中的静态变量时才需要调用）的初始化方法 <code>&lt;clinit&gt;()</code>，虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。</li></ul><p><strong>类何时进行初始化？（主动引用）</strong></p><blockquote><ol><li>使用new关键字实例化对象的时候；读取或设置一个类型的静态字段（被final修饰的除外，因为已在编译期将结果放入了常量池）；调用一个静态方法。</li><li>使用反射调用。</li><li>初始化类的时候，发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li><li><strong>当使用JDK7新加入的动态语言支持时。（后续在字节码章节详细讲解）</strong></li><li>当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果这个接口的实现类发生了初始化，那么该接口要在其之前被初始化。</li></ol><p><strong>以上的条件是当类或接口未初始化过，即是第一次初始化，才会执行。并且有且只有这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型都不会触发初始化，称为被动引用</strong></p></blockquote><p><strong>被动引用</strong></p><ol><li><p>通过子类引用父类的静态字段，不会导致子类初始化，只会触发父类的初始化。</p></li><li><p>通过数组定义来引用类。</p></li></ol><blockquote><p>假如有一个Student类</p><p>Student[] studentArray = new Student[10];</p><p>这种情况并不会导致Student类进行初始化。你并没有使用Student类中的任何，但是你声明数组，必然会导致和数组相关的类进行了初始化，[Lorg.fenixsoft.classloading.SuperClass 这个类发生了初始化，这是个与一维数组相关的类，具体不做详细介绍。</p></blockquote><ol start="3"><li>使用类中的被final修饰的静态常量。</li></ol><blockquote><p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p></blockquote><h3 id="lt-init-gt"><a href="#lt-init-gt" class="headerlink" title="&lt;init&gt;()"></a><code>&lt;init&gt;()</code></h3><ul><li><p>执行时期：对象的初始化阶段。</p></li><li><p>执行构造器，以及非静态初始化块中的代码。</p></li></ul><p><strong>实例化一个类的四种途径:</strong></p><ol><li>调用 new 操作符</li><li>调用 Class 或 java.lang.reflect.Constructor 对象的newInstance()方法(反射)</li><li>调用任何现有对象的clone()方法</li><li>通过 java.io.ObjectInputStream 类的 getObject() 方法反序列化</li></ol><h3 id="lt-clinit-gt-与-lt-init-gt-执行顺序案例"><a href="#lt-clinit-gt-与-lt-init-gt-执行顺序案例" class="headerlink" title="&lt;clinit&gt;()与&lt;init&gt;()执行顺序案例"></a><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code>执行顺序案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test instance; <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// &lt;clinit&gt;()</span></span><br><span class="line">        System.out.println(<span class="string">"static开始"</span>);</span><br><span class="line">        instance = <span class="keyword">new</span> Test();</span><br><span class="line">        System.out.println(<span class="string">"static结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// &lt;init&gt;()</span></span><br><span class="line">        System.out.println(<span class="string">"构造器开始"</span>);</span><br><span class="line">        System.out.println(<span class="string">"x="</span> + x + <span class="string">";y="</span> + y);</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        System.out.println(<span class="string">"x="</span> + x + <span class="string">";y="</span> + y);</span><br><span class="line">        System.out.println(<span class="string">"构造器结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">1</span>; <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> y; <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test.getInstance();</span><br><span class="line">        System.out.println(<span class="string">"x="</span> + x);</span><br><span class="line">        System.out.println(<span class="string">"y="</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><blockquote><p>static开始<br>构造器开始<br>x=0;y=0<br>x=1;y=1<br>构造器结束<br>static结束<br>x=1<br>y=1</p></blockquote><blockquote><p>从结果中可以看出静态代码块先执行，如果静态代码块中执行了其它方法，则先去执行，然后在回来继续执行，静态代码，这就说明了<code>&lt;clinit&gt;()</code>方法在<code>&lt;init&gt;()</code>之前执行。</p></blockquote><blockquote><p><code>&lt;clinit&gt;()</code>方法就是将一个类中的所有的静态代码块以及类变量整合到一块，注意这里是有顺序的执行，如果其中调用了其它非静态方法，就会执行完后接着执行，如果有父类的话当然执行父类的静态代码块以及类变量，就像下图一样，<strong>把父类和子类的这些静态代码块，类变量全部整合到一块，按照代码编写的顺序来执行。</strong></p><p><code>&lt;init&gt;()</code>也是如此，不过整合的是普通代码块和普通的成员变量了。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200610133639.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载子系统</title>
      <link href="/2020/06/09/java/jvm/2-1/"/>
      <url>/2020/06/09/java/jvm/2-1/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><h3 id="一个类的生命周期"><a href="#一个类的生命周期" class="headerlink" title="一个类的生命周期"></a>一个类的生命周期</h3><p><img src="https://image.cclblog.cn/blog/20200609204057.png" alt=""></p><p>其中加载，验证，准备，初始化，和卸载这五个阶段顺序是确定的，解析阶段则不一定，在某些情况下可以在初始化阶段之后再进行，这是为了支持java语言的运行时绑定特性。</p><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载阶段，java虚拟机需要完成：</p><ol><li><p>通过一个类的全限定名来获取定义此类的二进制字节流。</p></li><li><p>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构。</p></li><li><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p></li></ol><blockquote><p><strong>这个java.lang.Class对象，将相当于一个模具，假如你在家里面自制雪糕，必须有个模具吧，用这个模具来生产雪糕，假如你这个模具是塑料的。</strong></p><p><strong>1.中的字节流就相当于这个模具的第一道加工，把塑料的原料加工成塑料</strong></p><p><strong>2.中的就是相当于第二道加工，塑料模具基本成型，然后运输到方法区</strong></p><p><strong>3.就相当于这个模具上色美化等，真正的成为了一个可以使用的模具了，然后你就可以用它来制作雪糕，你制作的每个雪糕就是一个个对象，他们的形状是一样的，但是具体的内容即原料颜色等可能不一样，这也就是对象的具体内容可能不同</strong></p></blockquote><p><img src="https://image.cclblog.cn/blog/20200609204148.png" alt=""></p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ol><li><strong>文件格式验证</strong>，验证字节流是否符合Class文件格式规范。</li></ol><blockquote><p><strong>就是看看你这个文件是不是符合我要加载的，就相当于一个图片还有各种格式.jpg.png，不能你把随便一个文件的后缀名改成.class就加载你吧。</strong></p></blockquote><ol start="2"><li><strong>元数据验证</strong>，对字节码描述的信息进行验证，保证描述的信息符合，比如一个类是否继承了被final修饰的类，如果一个类不是抽象类，是否实现了其父类或接口中要求实现的方法等。</li></ol><blockquote><p><strong>就是看看程序中代码是否做了规定以外的事情，这个规定就好java的语言规范，就相当于一个人要遵守法律一样，就相当于查一下你有没有犯法，做了规定以外的事情。比如你不是我老婆，我和你睡在了一块？？？</strong></p></blockquote><ol start="3"><li><strong>字节码验证</strong>，验证程序语义是否为合法的，符合逻辑的。</li></ol><blockquote><p><strong>就是详细的检查程序代码是否是安全的，会不会对虚拟机造成威胁，这个阶段最为复杂，三言两语很难说清，要检查的东西有很多</strong></p></blockquote><ol start="4"><li><strong>符号引用验证</strong>，验证一个类是否缺少或者被禁止访问它依赖的某些外部类、方法等。</li></ol><blockquote><p><strong>就是我依赖的类，我能不能访问。比如买了一个苹果手机，看一下我能不能使用它，不能使用的话不就出问题了</strong></p></blockquote><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值阶段。</p><p>例如一个变量定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>那变量在准备阶段过后的初始值为0而不是123，真正把value赋值的操作是在类的初始化阶段才会被执行。</p><p>但是如果 value被声明为 <strong>final</strong>那么在准备阶段就会给value赋值为123</p><p><strong>例如</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test2 instance = Test2.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test2 test2 = <span class="keyword">new</span> Test2();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a="</span> + a);</span><br><span class="line">        System.out.println(<span class="string">"b="</span> + b);</span><br><span class="line">        <span class="keyword">return</span> test2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序的输出结果为 a=1 b=0 并不是a=1 b=1</strong></p><blockquote><p>分析：</p><ol><li>准备阶段，会将静态变量从上到下设置为默认值，a=0,test2=null,b=0</li><li>当调用一个类的静态变量或静态方法会导致该类初始化，并设置成实际的默认值</li><li>此时a还是0，因为它并没有默认值，然后test2 赋值，调用了Test2()构造方法，对a++,b++ ,此时a = 1 b = 1</li><li>然后给b赋值默认值0，这样就导致了覆盖了前面的1，导致最后b=0</li></ol><p>如果变成private static int b = 0;private static Test2 test2 = new Test2();那最后的结果就变成了a=1 b=1了，和代码的顺序有关。</p></blockquote><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。这个阶段很重要，需要了解Class文件的类文件结构。后续会详细讲解。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类的初始化是类加载过程的最后一个步骤，直到初始化阶段，Java虚拟机才真正开始执行类中编写的java程序代码。</p><p>这个阶段是为静态变量赋予正确的初始值，执行静态代码块，执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。</p><p><strong>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，可以赋值但是不能访问。例如：</strong></p><p><img src="https://image.cclblog.cn/blog/20200609204234.png" alt="">    </p><p><strong>java虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。这个说明父类中定义的静态语句块肯定优先于子类执行。例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a =  <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Test1.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果为2，这不就说明了Test父类中的静态代码块被执行了吗。</p><p><strong>如果一个类中没有静态语句块，也没有对变量的赋值操作，编译器就不会生成<code>&lt;clinit&gt;()</code>方法。</strong></p><p><strong>执行接口的<code>&lt;clint&gt;()</code>方法无需先执行父类的<code>&lt;clinit&gt;()</code>方法</strong>，因为当只有父接口中定义的变量被使用时，父接口才会被初始化。接口的实现类在初始化时也不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p><p><strong><code>&lt;clinit&gt;()</code>在多线程环境下是安全的，并且只会被执行一次</strong>，只会有一个线程去执行，其它线程阻塞，直到执行完该方法后，其它线程才能操作，否则一直阻塞，并且<code>&lt;clinit&gt;()</code>只会被多个线程执行一次，执行完后，其它线程将不会再次执行。</p><blockquote><p><strong>这就好比你的目的是制作一辆汽车（一个类的模板），你有必要去生产两个车壳子（其中的静态代码块，赋值操作）吗？程序中只需要一个类模板就行了，<code>&lt;clinit&gt;()</code>方法就相当于类模板的装饰，装饰这个类一开始有哪些属性，也就是出厂设置吧。其他你初始化赋值<code>&lt;init&gt;()</code>方法，就是你自定义的值了。你开多个线程，就相当于多个工厂，一旦其中一个工厂接下了这份活，你得赶紧通知其他的工厂不要做了，如果几个工厂都生产的话，你总不能只给一份钱吧（浪费系统资源）。</strong></p></blockquote><p>这就相当于生产一个汽车零件，你的目的只是制作一辆汽车，你完全没有必要去生产</p><h4 id="lt-clinit-gt-与-lt-init-gt-方法"><a href="#lt-clinit-gt-与-lt-init-gt-方法" class="headerlink" title="&lt;clinit&gt;()与&lt;init&gt;()方法"></a><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code>方法</h4><p>详情见 <strong><a href="/2020/06/10/java/jvm/2-1-1/"><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code>详解</a></strong></p><h3 id="类加载器ClassLoader"><a href="#类加载器ClassLoader" class="headerlink" title="类加载器ClassLoader"></a>类加载器ClassLoader</h3><p><img src="https://image.cclblog.cn/blog/20200611160308.png" alt=""></p><ul><li>启动类加载器（Bootstrap Class Loader）</li></ul><blockquote><ol><li>这个类加载器使用C/C++语言实现的，嵌套在JVM内部。所以java程序中是获取不到的。</li><li>负责加载放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，并且必须被java虚拟机识别（按照文件名识别，.jar），名字不符合即使放在此目录下也不能加载。</li><li>不继承自java.lang.ClassLoader，没有父加载器</li><li>出于安全考虑，只能加载包名为java、javax、sun等开头的类</li></ol></blockquote><ul><li>扩展类加载器（Extension Class Loader）</li></ul><blockquote><ol><li>这个类加载器是在sun.misc.Launcher$ExtClassLoader中以java代码的形式实现的。</li><li>负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li></ol></blockquote><ul><li>应用程序类加载器（Application Class Loader）</li></ul><blockquote><p>这个类加载器由sun.misc.Launcher$AppClassLoader来实现。它负责加载用户类路径上所有的类库。如果应用程序中没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p></blockquote><h4 id="自定义类加载器步骤"><a href="#自定义类加载器步骤" class="headerlink" title="自定义类加载器步骤"></a>自定义类加载器步骤</h4><ol><li>继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器。</li><li>jdk1.2之前，继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载，之后不在建议这样做，而是建议把自定义的类加载逻辑写在findClass()方法中。</li><li>在编写自定义类加载器时，如果需求简单，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，可以使自定义类加载器编写更加简洁。</li></ol><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><blockquote><p>JVM对class文件采用的是<strong>按需加载</strong>的方式，当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，JVM采用的是<strong>双亲委派机制</strong>。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200611134915.png" alt=""></p><p><strong>双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的类加载器中，只有当父加载器反馈自己无法完成这个加载请求时（它的搜索范围内没有找到所需的类）时，子加载器才会尝试自己去完成加载。</strong></p><blockquote><p>双亲委派机制就是：<code>自底向上检查类是否已经加载，自顶向下尝试是否可以加载类</code></p></blockquote><p><strong>类加载流程图：</strong></p><p><img src="https://image.cclblog.cn/blog/20200611143430.jfif" alt=""></p><p><strong>使用双亲委派机制的优势？（为什么要使用双亲委派机制？优点有哪些？）</strong></p><blockquote><ol><li>避免类的重复加载。</li><li>保护核心API被随意篡改。通过委托方式，不会去篡改核心<code>.class</code>，即使篡改也不会去加载，即使加载也不会是同一个<code>.class</code>对象了。不同的加载器加载同一个<code>.class</code>也不是同一个<code>Class</code>对象。这样保证了<code>Class</code>执行安全。</li></ol></blockquote><p><strong>弊端：</strong></p><blockquote><p>双亲委派模型是单向的，永远是子加载器请求父加载器，这就造成了上层的类加载器无法访问下层类加载器所加载的类。例如常见的JDBC就是这样，JDBC在java.sql.Driver中只定义了接口，具体的实现是由具体的数据库厂商来实现的，例如你使用msql，mysql肯定实现了Driver中的接口，但是它的jar在你的目录下，系统类加载器无法识别，你要是用mysql的话就会出现问题，自然就会出现解决的办法。线程上下文类加载器，和jdk6提供的java.util.ServiceLoader类具体不过多介绍。</p></blockquote><h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><p>当父加载器去委托子加载器去加载类的时候就破坏了这个双亲委派模型，双亲委派模型有三次被破坏，具体不做说明。</p><p>这两篇文章写得挺好。</p><p><a href="https://blog.csdn.net/awake_lqh/article/details/106171219" target="_blank" rel="noopener">双亲委派模型的破坏(JDBC例子)</a></p><p><a href="https://blog.csdn.net/sinat_34976604/article/details/86723663" target="_blank" rel="noopener">双亲委派模式破坏-JDBC</a></p><h4 id="jdk9下发生的变化（简）"><a href="#jdk9下发生的变化（简）" class="headerlink" title="jdk9下发生的变化（简）"></a>jdk9下发生的变化（简）</h4><p>jdk9对java进行了模块化，是一次重大的变化，这个模型也随之而变。</p><p><img src="https://image.cclblog.cn/blog/20200611152410.png" alt=""></p><ol><li>扩展类加载器被平台类加载器替代。</li><li>它们都不在派生自java.net.URLClassLoader，而是全部继承于jdk.internal.loader.BuiltinClassLoader。</li><li>这个双亲委派模型发生了变化。</li></ol><blockquote><p>jdk9相当于对java核心代码进行了重构，变成模块化，启动类加载器，平台类加载器，应用程序类加载器，都被明确规定了加载哪些模块的类，这样类的加载过程就变成了，在委派给父类加载器的时候首先看自己是否可以加载此类，这个变化可以说破坏了双亲委派的这个模型。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM简介</title>
      <link href="/2020/06/08/java/jvm/1-1/"/>
      <url>/2020/06/08/java/jvm/1-1/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM（Hotspot）"><a href="#JVM（Hotspot）" class="headerlink" title="JVM（Hotspot）"></a>JVM（Hotspot）</h2><p><img src="https://image.cclblog.cn/blog/20200612162656.png" alt=""></p><p><code>java虚拟机是运行在操作系统之上的，它与硬件没有直接的交互！！！</code></p><h3 id="程序运行的过程"><a href="#程序运行的过程" class="headerlink" title="程序运行的过程"></a>程序运行的过程</h3><p><img src="https://image.cclblog.cn/blog/20200611155155.png" alt=""></p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p><img src="https://image.cclblog.cn/blog/20200611160308.png" alt=""></p><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p><img src="https://image.cclblog.cn/blog/20200611161129.png" alt=""></p><ul><li>99%的垃圾回收操作都是在堆上，所谓的JVM调优实际上就是在对堆的一个调优！！！</li></ul><h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><p><img src="https://image.cclblog.cn/blog/20200611170207.png" alt=""></p><h3 id="JDK不同版本JVM变化"><a href="#JDK不同版本JVM变化" class="headerlink" title="JDK不同版本JVM变化"></a>JDK不同版本JVM变化</h3><ul><li><p>jdk6：存在永久代，静态变量存放在永久代。</p></li><li><p>jdk7：存在永久代，逐步去永久代；将<strong>字符串常量池</strong>和<strong>静态变量</strong>移动到了堆空间中。</p></li><li><p>jdk8：永久代，类型信息、字段、方法、常量保存在本地内存的元空间（Metaspace），字符串常量池、静态变量仍然在堆中。</p></li></ul><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol><li><p>为什么将字符串常量池移入到堆中？（为什么去永久代，改为元空间？）</p><blockquote><ol><li>字符串存在永久代中，容易出现性能问题和内存溢出，因为字符串应该是程序中非常常用的。</li><li>类及方法的信息等比较难确定大小，因此对于永久代的大小指定比较困难。</li><li>永久代会为GC带来不必要的复杂度，并且回收效率很低。</li><li>Oracle将HotSpot与JRockit合二为一，借鉴了后者虚拟机的优点。</li></ol></blockquote></li></ol><h3 id="其他虚拟机"><a href="#其他虚拟机" class="headerlink" title="其他虚拟机"></a>其他虚拟机</h3><p>BEA JRockit，IBM J9不做过多介绍。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2020/06/06/java/jvm/jvm/"/>
      <url>/2020/06/06/java/jvm/jvm/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><ol><li><strong><a href="/2020/06/08/java/jvm/1-1/">JVM简介</a></strong></li></ol><hr><h2 id="内存结构篇"><a href="#内存结构篇" class="headerlink" title="内存结构篇"></a>内存结构篇</h2><ol><li><strong><a href="/2020/06/09/java/jvm/2-1/">类加载子系统</a></strong> </li><li><a href="/2020/06/12/java/jvm/2-2/"><strong>虚拟机栈</strong></a></li><li><a href="/2020/06/17/java/jvm/2-3/">本地方法栈</a></li><li><strong><a href="/2020/06/12/java/jvm/2-4/">程序计数器</a></strong></li><li><strong><a href="/2020/06/17/java/jvm/2-5/">堆</a></strong></li><li><strong><a href="/2020/06/19/java/jvm/2-6/">方法区</a></strong></li><li>执行引擎（×）</li><li>本地方法接口<strong>（略）</strong></li></ol><hr><h2 id="垃圾回收篇"><a href="#垃圾回收篇" class="headerlink" title="垃圾回收篇"></a>垃圾回收篇</h2><ol><li>垃圾收集器（×）</li><li>内存分配策略（×）</li></ol><h2 id="性能监控与调优篇"><a href="#性能监控与调优篇" class="headerlink" title="性能监控与调优篇"></a>性能监控与调优篇</h2><ol><li>性能监控（×）</li><li>性能调优（×）</li></ol><hr><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><ol><li>StringTable（×）</li><li>字节码（×）</li></ol><hr><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol><li>…（×）</li></ol><hr><p>​    <strong>要快速的学习JVM就要了解你写的一行代码假如Car car = new Car();这个到底在虚拟机中是怎么加载，分配内存等等，然后怎么被回收处理，等，综合性的学习才能学得更快记得更牢固，起初就是一个知识点知识点的学，堆、栈、方法区…就像一开始学是一个点，然后变成碎片，这些组合起来就是jvm的内存结构，慢慢的组成一个网（整个JVM网络），只要组成一个网络化的知识，我说的是并不是这个网络有多么牢固，要明白不求甚解这个道理，尤其是JVM，知识点互相穿插，并不是一个知识点你就能很透彻，有可能你学了别的知识点，然后再看前面恍然大悟，往往我就是这样。而是你有了个整体的认识，就像从上向下看，一目了然，我认为这就是大局观，一定要有这种观念，知识网络化，小到一个知识点，大到系统的一个架构，一切都是思想，一定要有这个思想，显然我在JVM这个上面功力明显不足，我现在还停留在碎片的阶段（2020-06-19），我并不能把这个JVM特别清楚详细的描述，更别说深入的了解，我只是在尝试深入了解，其中有的点我并不是很清楚，形成一个基本的网络时间肯定不会很长，然后慢慢巩固这个网络，不求甚解这个方法形成网络后，肯定不如你平常研究某个知识点掌握那么的牢固，这种情况下，往往是别人问你你了解，知道有这个知识点，但是只能说个支支吾吾大概，这时无需感觉很无奈，感觉自己白学了，首先有了一个知识网络，然后在逐个点的巩固，不断的巩固，总有一天，（其实我非常烦说这个“总有一天” 这到底是哪一天？但是这个确实需要你的用心的，如果你用心时间肯定不会很长，否则确实就是“总有一天了。。。”）这个网络必定会变得非常健壮。</strong></p><blockquote><p>JVM网络，java网络，框架网络等等整合组成整个体系，相信自己肯定有一天会发生质的变化，短期内可能并没有很好地效果，反而会感觉自己哪哪都掌握不牢！！质的变化，对计算机这个这个体系有自己的认识，并不仅仅局限于Java这门语言。</p></blockquote><p>​    学习了JVM这个之后，真后悔没早点学这个，这个真的不是很快就能学习的，不像框架一样基本学一学就用上了，这个需要自己用心去理解，比较偏理论和实践，自己永远不真正环境的调优，只是简单的自我尝试那些效果并不好，应该长期持续的学习并且实战演练，<strong>实战是进步最快的</strong>。我原本打算的是最后学一学的。。。哎然后才发现JVM这个太重要了，这个太有魅力了，真正的让你接触到了一点java代码到底怎么执行的，自己写代码也不少了，从来没有研究过，哎，自己始终在“上层”，混迹“上流社会”，学习了这个让我明白了每一行代码都干了什么（当然不能是每一行那么夸张，自己还没这个水平），让我对内存的分配，一个类的加载，从前我从来没注意过，因为平常写的那些代码怎么可能OOM（顶多研究递归报一个栈溢出），学习了JVM让我对java思想有了很大的进步，不仅是java，是编程的思想，面向对象的思想。</p><p>​    <strong>编程的道路真的是哪有什么岁月静好,不过是有人替你负重前行！就像自己用springboot、springcloud，自己写代码越来越简单，不能总是期待等着出现更好更简单使用的框架，改变自己，别等着别人来改变你！</strong></p><blockquote><p>个人理解，随笔记录，实际上还有很多点，自己的感悟，自己这大学期间的感悟，和生活中的感悟，在<a href="/2020/06/06/life/life/">感悟</a>中慢慢分享。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>感悟</title>
      <link href="/2020/06/06/life/life/"/>
      <url>/2020/06/06/life/life/</url>
      
        <content type="html"><![CDATA[<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol><li>初心！</li></ol>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> 感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
            <tag> 主题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
