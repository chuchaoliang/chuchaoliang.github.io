<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>装饰者模式</title>
      <link href="/2020/07/30/java/designMode/DecoratorPattern/"/>
      <url>/2020/07/30/java/designMode/DecoratorPattern/</url>
      
        <content type="html"><![CDATA[<h1 id="装饰者模式（DecoratorPattern）"><a href="#装饰者模式（DecoratorPattern）" class="headerlink" title="装饰者模式（DecoratorPattern）"></a>装饰者模式（DecoratorPattern）</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>原装M4A1、AK47，添加消音器，瞄准镜。</p><p><img src="https://image.cclblog.cn/Snipaste_2020-08-02_21-37-46.png" alt=""></p><p><img src="https://image.cclblog.cn/Snipaste_2020-08-02_21-25-20.png" alt=""></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rifle</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基本描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">M4A1</span> <span class="keyword">implements</span> <span class="title">Rifle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"出厂原装M4A1！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AK47</span> <span class="keyword">implements</span> <span class="title">Rifle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"出厂原装AK47！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="装饰类"><a href="#装饰类" class="headerlink" title="装饰类"></a>装饰类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RifleDecorator</span> <span class="keyword">implements</span> <span class="title">Rifle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Rifle decoratedRifle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RifleDecorator</span><span class="params">(Rifle decoratedRifle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.decoratedRifle = decoratedRifle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        decoratedRifle.describe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SilencerDecorator</span> <span class="keyword">extends</span> <span class="title">RifleDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SilencerDecorator</span><span class="params">(Rifle decoratedRifle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(decoratedRifle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.describe();</span><br><span class="line">        System.out.println(<span class="string">"添加消音器！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GunsightDecorator</span> <span class="keyword">extends</span> <span class="title">RifleDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GunsightDecorator</span><span class="params">(Rifle decoratedRifle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(decoratedRifle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.describe();</span><br><span class="line">        System.out.println(<span class="string">"添加瞄准镜！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Rifle m4A1 = <span class="keyword">new</span> M4A1();</span><br><span class="line">        m4A1 = <span class="keyword">new</span> SilencerDecorator(m4A1);</span><br><span class="line">        m4A1 = <span class="keyword">new</span> GunsightDecorator(m4A1);</span><br><span class="line">        m4A1.describe();</span><br><span class="line">        System.out.println(<span class="string">"********************"</span>);</span><br><span class="line">        Rifle ak47 = <span class="keyword">new</span> AK47();</span><br><span class="line">        ak47 = <span class="keyword">new</span> SilencerDecorator(ak47);</span><br><span class="line">        ak47 = <span class="keyword">new</span> GunsightDecorator(ak47);</span><br><span class="line">        ak47.describe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>出厂原装M4A1！！！<br>添加消音器！！！<br>添加瞄准镜！！！</p><hr><p>出厂原装AK47！！！<br>添加消音器！！！<br>添加瞄准镜！！！</p></blockquote><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>这个装饰者模式就相当于并没有改变原来的对象结构，但是给原来对象穿上了一件衣服。就是创建一些修饰的类，用来包装原来的类。就像游戏中一个人初始化的时候没有任何装备，然后用武器来修饰，各种装备来修饰这个初始化的人。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桥接模式</title>
      <link href="/2020/07/28/java/designMode/BridgePattern/"/>
      <url>/2020/07/28/java/designMode/BridgePattern/</url>
      
        <content type="html"><![CDATA[<h1 id="桥接模式（BridgePattern）"><a href="#桥接模式（BridgePattern）" class="headerlink" title="桥接模式（BridgePattern）"></a>桥接模式（BridgePattern）</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>存在两个兵工厂，用来生产M4A1和AK47</p><p><img src="https://image.cclblog.cn/Snipaste_2020-08-01_20-57-05.png" alt=""></p><p>将两个兵工厂与具体的步枪分开，通过聚合来实现相关联。</p><p><img src="https://image.cclblog.cn/Snipaste_2020-08-01_21-08-44.png" alt=""></p><p><img src="https://image.cclblog.cn/Snipaste_2020-08-01_20-58-32.png" alt=""></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="兵工厂相关类"><a href="#兵工厂相关类" class="headerlink" title="兵工厂相关类"></a>兵工厂相关类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractArsenal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractRifle abstractRifle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractArsenal</span><span class="params">(AbstractRifle abstractRifle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.abstractRifle = abstractRifle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这可用抽象方法，根据情况选择</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationRifle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.abstractRifle.reloading();</span><br><span class="line">        <span class="keyword">this</span>.abstractRifle.fire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RussiaArsenal</span> <span class="keyword">extends</span> <span class="title">AbstractArsenal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RussiaArsenal</span><span class="params">(AbstractRifle abstractRifle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(abstractRifle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationRifle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"RussiaArsenal!!!"</span>);</span><br><span class="line">        <span class="keyword">super</span>.operationRifle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">USAArsenal</span> <span class="keyword">extends</span> <span class="title">AbstractArsenal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">USAArsenal</span><span class="params">(AbstractRifle abstractRifle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(abstractRifle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationRifle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"USAArsenal!!!"</span>);</span><br><span class="line">        <span class="keyword">super</span>.operationRifle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体步枪类"><a href="#具体步枪类" class="headerlink" title="具体步枪类"></a>具体步枪类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRifle</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 射击</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装弹中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">reloading</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">M4A1</span> <span class="keyword">extends</span> <span class="title">AbstractRifle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"M4A1射击，哒哒哒哒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reloading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"M4A1装弹中......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ak47</span> <span class="keyword">extends</span> <span class="title">AbstractRifle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Ak47射击，乌拉乌拉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reloading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AK47装弹中......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RussiaArsenal russiaArsenal1 = <span class="keyword">new</span> RussiaArsenal(<span class="keyword">new</span> Ak47());</span><br><span class="line">        russiaArsenal1.operationRifle();</span><br><span class="line">        </span><br><span class="line">        RussiaArsenal russiaArsenal2 = <span class="keyword">new</span> RussiaArsenal(<span class="keyword">new</span> M4A1());</span><br><span class="line">        russiaArsenal2.operationRifle();</span><br><span class="line">        </span><br><span class="line">        USAArsenal usaArsenal1 = <span class="keyword">new</span> USAArsenal(<span class="keyword">new</span> Ak47());</span><br><span class="line">        usaArsenal1.operationRifle();</span><br><span class="line">        </span><br><span class="line">        USAArsenal usaArsenal2 = <span class="keyword">new</span> USAArsenal(<span class="keyword">new</span> M4A1());</span><br><span class="line">        usaArsenal2.operationRifle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>RussiaArsenal!!!<br>AK47装弹中……<br>Ak47射击，乌拉乌拉</p><p>RussiaArsenal!!!<br>M4A1装弹中……<br>M4A1射击，哒哒哒哒</p><p>USAArsenal!!!<br>AK47装弹中……<br>Ak47射击，乌拉乌拉</p><p>USAArsenal!!!<br>M4A1装弹中……<br>M4A1射击，哒哒哒哒</p></blockquote><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>桥接这个模式就是将抽象与实现解耦，使这两者可以独立的变化，就像上面的例子中，增加一个M16步枪类，扩展非常简单，或者增加一个中国兵工厂，并不影响具体的步枪类。这个模式也从一方面解决了用继承的话会产生类爆炸的问题，俄罗斯M4A1、俄罗斯AK47、美国M4A1、美国AK47等等，这样的话类就特别多，每次扩展也非常不方便。</p><blockquote><p>突然感觉这个和抽象工厂解决工厂方法类爆炸问题好像(#&gt;д&lt;)ﾉ！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/2020/07/27/java/designMode/BuilderPattern/"/>
      <url>/2020/07/27/java/designMode/BuilderPattern/</url>
      
        <content type="html"><![CDATA[<h1 id="建造者模式（BuilderPattern）"><a href="#建造者模式（BuilderPattern）" class="headerlink" title="建造者模式（BuilderPattern）"></a>建造者模式（BuilderPattern）</h1><h1 id="简单解读"><a href="#简单解读" class="headerlink" title="简单解读"></a>简单解读</h1><blockquote><p>先看具体代码在来了解这个比较好一些。</p></blockquote><p><strong>构造者模式有四个基本属性：</strong></p><ol><li>具体的产品类</li></ol><blockquote><p>这个类中有可能存在很多复杂的对象，那就很适合用构建者模式。不过实现一中的例子是一个十分简单的构造模式，成员变量全部都为字符串。</p></blockquote><ol start="2"><li>抽象构建者</li></ol><blockquote><p><strong>规范这个产品怎么组建，提供一系列抽象方法，或者用接口。</strong>假如将你具体产品类中复杂的那些成员变量都想象成各个零件的话，那这个抽象构建者实际上就是定义怎么生产这些零件，具体生产交由具体的构造者来，生产什么是由导演类来确定的。（具体产品类中那些复杂的对象举个例子来说吧，假如存在一个List，你能知道用的是哪个List的实现类吗？不知道明白我的意思吗，具体的生产什么是看具体的导演类让你生产ArraryList还是其它实现List接口的类。根据导演类给你传输的不同得到的最终对象也就有所差别）</p></blockquote><ol start="3"><li>具体的构建者</li></ol><blockquote><p>实现抽象构建者的所有方法，并且返回一个构建的产品类。</p></blockquote><ol start="4"><li>导演类</li></ol><blockquote><p>导演类是将产品类中的成员变量传输给抽象的建造者，他是和抽象的建造者打交道的。</p><p>举个例子来说明：</p><p>假如开发一个软件，产品经理（导演类）告诉项目组开发负责人（抽象建造者）的用户需求（告诉用户需求的意思就好比传ArrayList还是其它），然后负责人定制一系列开发计划，当然自己并不去实现 ，就像架构师搭建一个壳子，具体的内容交由普通程序员（具体的构建者）来构建，构建完成后交付给产品经理。</p></blockquote><h1 id="实现一"><a href="#实现一" class="headerlink" title="实现一"></a>实现一</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>构造一把M4A1步枪</p><blockquote><p>这个实现一是强行用建造者模式，Rifle这个类中成员变量非常简单，不涉及多态，直接工厂也就就行了。但是为了简化建造者模式更容易理解，才这样写，后续我会模拟一个复杂一点的场景并结合工厂模式说明。</p></blockquote><h2 id="具体产品"><a href="#具体产品" class="headerlink" title="具体产品"></a>具体产品</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rifle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 步枪名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 步枪子弹</span></span><br><span class="line">    <span class="keyword">private</span> String bullet;</span><br><span class="line">    <span class="comment">// 枪身</span></span><br><span class="line">    <span class="keyword">private</span> String gunBody;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBullet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bullet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBullet</span><span class="params">(String bullet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bullet = bullet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGunBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gunBody;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGunBody</span><span class="params">(String gunBody)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gunBody = gunBody;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Rifle&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", bullet='"</span> + bullet + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", gunBody='"</span> + gunBody + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象构造者"><a href="#抽象构造者" class="headerlink" title="抽象构造者"></a>抽象构造者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractRifleBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置枪的名字</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置枪身</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBullet</span><span class="params">(String bullet)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置子弹</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setGunBody</span><span class="params">(String gunBody)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组装获得步枪</span></span><br><span class="line">    <span class="function">Rifle <span class="title">createRifle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体构造者"><a href="#具体构造者" class="headerlink" title="具体构造者"></a>具体构造者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">M4A1Builder</span> <span class="keyword">implements</span> <span class="title">AbstractRifleBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Rifle rifle = <span class="keyword">new</span> Rifle();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        rifle.setName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBullet</span><span class="params">(String bullet)</span> </span>&#123;</span><br><span class="line">        rifle.setBullet(bullet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGunBody</span><span class="params">(String gunBody)</span> </span>&#123;</span><br><span class="line">        rifle.setGunBody(gunBody);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Rifle <span class="title">createRifle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.rifle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="管理者"><a href="#管理者" class="headerlink" title="管理者"></a>管理者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractRifleBuilder rifleBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(AbstractRifleBuilder rifleBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rifleBuilder = rifleBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Rifle <span class="title">createRifle</span><span class="params">(String name, String bullet, String gunBody)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rifleBuilder.setName(name);</span><br><span class="line">        <span class="keyword">this</span>.rifleBuilder.setBullet(bullet);</span><br><span class="line">        <span class="keyword">this</span>.rifleBuilder.setGunBody(gunBody);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.rifleBuilder.createRifle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Director m4A1Director = <span class="keyword">new</span> Director(<span class="keyword">new</span> M4A1Builder());</span><br><span class="line">        Rifle M4A1 = m4A1Director.createRifle(<span class="string">"步枪名称：M4A1"</span>, <span class="string">"装填5.56mm子弹"</span>, <span class="string">"组装M4A1外壳"</span>);</span><br><span class="line">        System.out.println(M4A1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Rifle{name=’步枪名称：M4A1’, bullet=’装填5.56mm子弹’, gunBody=’组装M4A1外壳’}</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://image.cclblog.cn/Snipaste_2020-07-26_23-00-18.png" alt=""></p><blockquote><p>上面的那个例子我感觉是最简单的一种构造者模式了，产品类中全是字符串类型的，而且只有一个具体构造者，这也就是一个基本的构造者模式 。</p></blockquote><h1 id="实现二"><a href="#实现二" class="headerlink" title="实现二"></a>实现二</h1><p>实现一中的抽象构造者和管理者这两个角色不是必须的。实现二中也可以满足实现一的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Refile</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 步枪名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 步枪子弹</span></span><br><span class="line">    <span class="keyword">private</span> String bullet;</span><br><span class="line">    <span class="comment">// 枪身</span></span><br><span class="line">    <span class="keyword">private</span> String gunBody;</span><br><span class="line">    <span class="comment">// 枪托（可以省略）</span></span><br><span class="line">    <span class="keyword">private</span> String gunStock;</span><br><span class="line">    <span class="comment">// 瞄准镜（可以省略）</span></span><br><span class="line">    <span class="keyword">private</span> String gunSight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Refile</span><span class="params">(RefileBuilder refileBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = refileBuilder.name;</span><br><span class="line">        <span class="keyword">this</span>.bullet = refileBuilder.bullet;</span><br><span class="line">        <span class="keyword">this</span>.gunBody = refileBuilder.gunBody;</span><br><span class="line">        <span class="keyword">this</span>.gunStock = refileBuilder.gunStock;</span><br><span class="line">        <span class="keyword">this</span>.gunSight = refileBuilder.gunSight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Refile&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", bullet='"</span> + bullet + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", gunBody='"</span> + gunBody + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", gunStock='"</span> + gunStock + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", gunSight='"</span> + gunSight + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RefileBuilder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 步枪名称</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="comment">// 步枪子弹</span></span><br><span class="line">        <span class="keyword">private</span> String bullet;</span><br><span class="line">        <span class="comment">// 枪身</span></span><br><span class="line">        <span class="keyword">private</span> String gunBody;</span><br><span class="line">        <span class="comment">// 枪托（可以省略）</span></span><br><span class="line">        <span class="keyword">private</span> String gunStock;</span><br><span class="line">        <span class="comment">// 瞄准镜（可以省略）</span></span><br><span class="line">        <span class="keyword">private</span> String gunSight;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RefileBuilder</span><span class="params">(String name, String bullet, String gunBody)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.bullet = bullet;</span><br><span class="line">            <span class="keyword">this</span>.gunBody = gunBody;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RefileBuilder <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RefileBuilder <span class="title">setBullet</span><span class="params">(String bullet)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.bullet = bullet;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RefileBuilder <span class="title">setGunBody</span><span class="params">(String gunBody)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.gunBody = gunBody;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RefileBuilder <span class="title">setGunStock</span><span class="params">(String gunStock)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.gunStock = gunStock;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RefileBuilder <span class="title">setGunSight</span><span class="params">(String gunSight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.gunSight = gunSight;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Refile <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Refile(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p><img src="https://image.cclblog.cn/Snipaste_2020-07-28_18-22-14.png" alt=""></p><blockquote><p>RefileBuilder是Refile的一个静态内部类，这种构造方法适合那些成员变量特别多，而且有成员变量的必须要传过来，有的则无需必须存在，就是这个Refile不用定义非常多的不同参数的构造方法了。定义一个构造方法，可以自主选择set。</p></blockquote><h1 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h1><p>我感觉这个建造者模式就是将一个对象的所有成员变量的set方法交由别的类（抽象构建者）来管理，交给别的类来构建你这个对象，用户只需将构建这个对象的原材料给说明，对象set方法的管理者就给你将这个对象构建出来并且返回给用户。</p><h2 id="工厂方法vs建造者方法"><a href="#工厂方法vs建造者方法" class="headerlink" title="工厂方法vs建造者方法"></a>工厂方法vs建造者方法</h2><p>可以看我之前写的工厂方法构造M4A1和这个差不多，看看两者的区别。</p><p>工厂方法这个模式就生产M4A1来说，它是直接生产出这个M4A1整体，建造者模式是关注的是这个M4A1的构造过程，枪身，子弹。。组装在一起。工厂方法模式创建对象的粒度比较粗，而建造者模式更加关注这个对象一步一步的创建过程，我感觉这个实际应用中要是十分关注一个对象的过程就使用建造者模式，只关注生产出来某个对象就行那就工厂方法模式。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板方法模式</title>
      <link href="/2020/07/25/java/designMode/TemplateMethodPattern/"/>
      <url>/2020/07/25/java/designMode/TemplateMethodPattern/</url>
      
        <content type="html"><![CDATA[<h1 id="模板方法模式（TemplateMethodPattern）"><a href="#模板方法模式（TemplateMethodPattern）" class="headerlink" title="模板方法模式（TemplateMethodPattern）"></a>模板方法模式（TemplateMethodPattern）</h1><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p><img src="https://image.cclblog.cn/Snipaste_2020-07-27_21-57-06.png" alt=""></p><p>AbstractRifle抽象步枪类，其中RifleTemplate为步枪模板方法，先装弹后射击。。</p><h1 id="实现一"><a href="#实现一" class="headerlink" title="实现一"></a>实现一</h1><h2 id="抽象模板"><a href="#抽象模板" class="headerlink" title="抽象模板"></a>抽象模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRifle</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 射击</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装弹中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">reloading</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">RifleTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reloading();</span><br><span class="line">        fire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体的模板类"><a href="#具体的模板类" class="headerlink" title="具体的模板类"></a>具体的模板类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">M4A1</span> <span class="keyword">extends</span> <span class="title">AbstractRifle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"M4A1射击，哒哒哒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reloading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"M4A1装弹中，5.56mm"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ak47</span> <span class="keyword">extends</span> <span class="title">AbstractRifle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AK47射击，乌拉乌拉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reloading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AK47装弹中，7.62mm"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        M4A1 m4A1 = <span class="keyword">new</span> M4A1();</span><br><span class="line">        m4A1.RifleTemplate();</span><br><span class="line">        Ak47 ak47 = <span class="keyword">new</span> Ak47();</span><br><span class="line">        ak47.RifleTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>M4A1装弹中，5.56mm<br>M4A1射击，哒哒哒<br>AK47装弹中，7.62mm<br>AK47射击，乌拉乌拉</p></blockquote><h1 id="实现二"><a href="#实现二" class="headerlink" title="实现二"></a>实现二</h1><p>改变实验一中的需求，要求AK47不用填充子弹直接就可以射击，M4A1可以控制是否填充子弹。</p><p><img src="https://image.cclblog.cn/Snipaste_2020-07-27_22-55-44.png" alt=""></p><h2 id="抽象模板-1"><a href="#抽象模板-1" class="headerlink" title="抽象模板"></a>抽象模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRifle</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 射击</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装弹中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">reloading</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">RifleTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isReloading()) &#123;</span><br><span class="line">            reloading();</span><br><span class="line">        &#125;</span><br><span class="line">        fire();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否需要装弹</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 需要 false 不需要</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isReloading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体的模板类-1"><a href="#具体的模板类-1" class="headerlink" title="具体的模板类"></a>具体的模板类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">M4A1</span> <span class="keyword">extends</span> <span class="title">AbstractRifle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> reloading;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">M4A1</span><span class="params">(<span class="keyword">boolean</span> reloading)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reloading = reloading;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"M4A1射击，哒哒哒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reloading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"M4A1装弹中，5.56mm"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReloading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.reloading;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ak47</span> <span class="keyword">extends</span> <span class="title">AbstractRifle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AK47射击，乌拉乌拉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reloading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AK47装弹中，7.62mm"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isReloading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试类-1"><a href="#测试类-1" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        M4A1 m4A1 = <span class="keyword">new</span> M4A1(<span class="keyword">false</span>); <span class="comment">// 可以自己选择true或者false</span></span><br><span class="line">        m4A1.RifleTemplate();</span><br><span class="line">        Ak47 ak47 = <span class="keyword">new</span> Ak47();</span><br><span class="line">        ak47.RifleTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>M4A1射击，哒哒哒<br>AK47射击，乌拉乌拉</p></blockquote><h1 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h1><blockquote><p>我理解的模板模式就是和它的名字一样，定义了一个对象的一个框架，也就是模板，具体的实现交由子类来。还可以这样看，就是将几个对象的公有的一些方法抽象到一个类中，这些类要有一些共性，就比如本例子中的M4A1和AK47都是现安装子弹然后在射击，要是每个类都这些模板方法都不一样，那得弄出很多个模板方法。。。不过幸好还有实现二中的方式缓解这种情况。如果实在不可缓解我感觉是不是不合适用模板方法考虑别的设计模式。。或者对这个模板方法进行改进。这个模板方法模式重用性好，扩展性也好满足了开闭原则， 但是由于继承这层关系，万一那个抽象模板发生变动，其子类全部需要改变。。</p></blockquote><p>总的来说，我感觉这个模板方法适合：假如有一个复杂的算法，其中某一个小部分交给子类去实现，而不能像本例子中的那样抽象模板中的模板方法全部都是由子类实现的。这可以参照AQS中在acquire方法中只有tryAcquire方法是交由子类实现的，调用本类的tryAcquire方法抛出一个异常，其它的算法均为自己实现。这样更加的灵活。</p><blockquote><p>这个模板方法实际上不就是继承+重写吗。。AQS中的tryAcquire虽然叫模板方法模式，就是不同类继承重写这个方法。父类中某些方法具体在子类中延迟实现。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap-put方法解析</title>
      <link href="/2020/07/24/java/collection/HashMap-put/"/>
      <url>/2020/07/24/java/collection/HashMap-put/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap-put方法解析"><a href="#HashMap-put方法解析" class="headerlink" title="HashMap|put方法解析"></a>HashMap|put方法解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHashMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">"a"</span>, <span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接点进put方法内，看到实则调用putVal方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="putVal方法"><a href="#putVal方法" class="headerlink" title="putVal方法"></a>putVal方法</h2><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p><strong>就算不看源码之前，自己想一下该怎么往哈希桶中插入一些值（首先肯定要了解HashMap的基本结构的啊！）：</strong></p><ol><li>先根据一些算法找到你要插入元素在哈希桶中的位置。</li><li>找到这个位置之后判断一下这个位置是否为空，为空则直接插入，执行完毕。</li><li>如果不为空则，看一下你要插入的是否和这个元素的key相等，相等则替换值即可。</li><li>否则肯定是判断这个结点的下一个是否为空，为空的话，说明这个哈希桶中不是链表就是红黑树。</li><li>先判断一下它是否为树，如果为树，按照红黑树的方式插入元素。</li><li>否则为链表则遍历该链表啊，看是不是和你的值冲突，如果冲突就替换，否则在链表最后插入即可。</li></ol><blockquote><p>这个过程很简单，实际上除了TreeNode类中有关的那些方法，其它的实现都相对简单。那个TreeNode要对红黑树特别了解才能理解明白。上述的几个步骤中就是其中缺少了对于扩容的一些处理，对于链表每次要是插入一个元素就应该考虑是否扩容，是否树化。所以在第6步骤插入元素后需要考虑这些。（替换则不需要考虑了啊）</p><p><strong>源码中的实现大概思想是这样，但存在许多细节。这里随便列举几个：</strong></p><ol><li><p>首先这个一个元素到底存放在哈希桶中哪个位置，这个算法具体怎么实现的？？</p></li><li><p>如果达到扩容阈值，扩容之后那哈希桶中的元素该怎么重新分配（这个是在resize扩容方法中处理的）？？？</p></li><li><p>还可以得出一个问题就是为什么HashMap的长度要是2的幂次方（这个和1和2问题有关）？</p></li><li><p>…</p><p><strong>后面都会详细解释这些问题、</strong></p></li></ol></blockquote><p><img src="https://image.cclblog.cn/Snipaste_2020-07-25_14-29-24.png" alt=""></p><h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><p>看putVal方法之前要明白一个元素是怎么确定在table数组中的位置的。</p><blockquote><p><strong>(n- 1) &amp; hash</strong>  </p><p><strong>n为table的长度，hash为可以的hash并且这个hash并不是直接取key的哈希而是经过hash这个扰动函数让hash更加分散</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123; <span class="comment">// 返回这个你传入的键的hash值</span></span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>); <span class="comment">// 让hash的高16位与低16位异或，更分散，扰动函数，让哈希更分散；这里还说明了如果你的key为空则放在哈希桶的0位置处</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>(n- 1) &amp; hash到底是什么意思？</p><blockquote><p>这个含义是hash % n的意思。</p><ol><li><p>首先hashMap的长度规定为2的次幂，那么长度的2进制必然为前面一个1后面全是0，比如8是1000，4是0100。</p></li><li><p>那么这个2进制减去1是多少，比如8的二进制-1 ：1000 - 1 = 0111 原来为1的位变0后面全部为1。</p></li><li><p>然后和hash进行与操作，&amp;操作只有在全是1的情况下才为1，可以看出来了吧，这个n-1&amp;hash 无论hash的高位多么的花里胡哨的全给我变成0，只保留后面的几位，如果hash&gt;n-1 的话就是求余操作，否则就是hash这个值。</p></li></ol><p><strong>这你也就明白了HashMap的长度为什么是2的次幂了吧。这个在resize方法中也有体现后续会说明。</strong></p></blockquote><p><strong>参数含义</strong></p><ol><li>key的哈希值</li><li>key</li><li>value</li><li>是否覆盖原来旧的值，就是HashMap中存在与你这个key相同的，false覆盖，true不覆盖</li><li>evict，如果为false，则处于创建模式（无特殊含义，在HashMap的一个构造函数中传过来的是false）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">// 判断当前的table是否为空</span></span><br><span class="line">            n = (tab = resize()).length; <span class="comment">// resize()方法中初始化table，并将初始化后的长度赋值给n</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// 判断元素要插入的位置的那个哈希桶是否为null，(n - 1) &amp; hash 意思是求出该元素在hash桶中的下标</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">// 为空说明这个哈希桶还未有其他元素，直接填入这个位置即可</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// 判断你插入元素是否和p冲突（p为哈希桶的第一个元素，冲突的意思就是hash相同key的equals为true）</span></span><br><span class="line">                e = p; <span class="comment">// 将p赋值为e这个Node结点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果这个哈希桶中已经是个红黑树</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value); <span class="comment">// 红黑树的putTreeVal来插入这个元素，返回旧的结点如果有冲突的话，并赋值给e</span></span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 为链表结点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123; <span class="comment">// 遍历链表</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123; <span class="comment">// 判断p的下一个结点是否为空，这个为空的意思就是已经遍历到链表的最后一个结点了。。</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">// 遍历完全部的链表都没发现链表中与你要插入的结点冲突，直接new一个结点插入到链表的尾部即可</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st 因为你插入了一个元素就需要判断一下你这个插入后的长度是不是超过了建树的阈值，TREEIFY_THRESHOLD默认为8</span></span><br><span class="line">                            treeifyBin(tab, hash); <span class="comment">// 这个是将这个链表树化的操作</span></span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// 跳出循环</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// 发现与你要插入的元素冲突的元素</span></span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// 跳出循环</span></span><br><span class="line">                    p = e; <span class="comment">// 这个就是每次都将p设置为e = p.next，p的下一个结点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key 经过上面那些操作这个e保存的就是与你冲突的那个节点</span></span><br><span class="line">                V oldValue = e.value; <span class="comment">// 将e结点的value赋值给oldValue</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>) <span class="comment">// onlyIfAbsent：是否替换旧值（put方法传入的是false替换），或者e的value为空满足其一则替换</span></span><br><span class="line">                    e.value = value; <span class="comment">// 将新值替换为这个节点的值</span></span><br><span class="line">                afterNodeAccess(e); <span class="comment">// HashMap中为空函数并没有实际含义（LinkedHashMap使用）</span></span><br><span class="line">                <span class="keyword">return</span> oldValue; <span class="comment">// 返回旧值，因为是替换操作没有新增加结点，所以无需考虑扩容问题，直接返回即可。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount; <span class="comment">// 修改的次数+1</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">// 插入元素后判断是否超过扩容阈值</span></span><br><span class="line">            resize(); <span class="comment">// 超过扩容阈值进行扩容操作</span></span><br><span class="line">        afterNodeInsertion(evict); <span class="comment">// HashMap中为空函数并没有实际含义（LinkedHashMap使用）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 新增加了节点，并没有替换，所以返回null</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>确定元素在哈希桶中的位置：</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote><p>这个过程和自己想的过程一样吗，就是它插入时利用了一个中间变量e来记录与我key值相同的结点，如果这个e不为空则说明要覆盖这个结点，然后根据onlyIfAbsent这个参数，<strong>注意这个若这个e的value为null也进行覆盖！！</strong>覆盖之后就返回原来旧的value。</p><p>如果e为空，则判断是否需要扩容了，然后返回null。</p></blockquote><h2 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h2><h3 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h3><p>不看源码之前自己现想一下让你实现扩容怎么实现（这个比较难想得出来！！）：</p><ol><li>简单的思考一下，既然是扩容方法，肯定是要确定一下新的table容量，扩容阈值threshold肯定也需要重新设定一下子啊，不设定这个容量&gt;扩容阈值不得每次都扩容吗。<strong>可得出第一个步骤就是求出新的table容量和相应的扩容阈值threshold。</strong>具体新的table是原来容量的多少倍肯定看源码才明白，现在明白新的table长度肯定是原来的2的幂次方的倍数。！</li><li>第1步中既然得到了扩容阈值和新容量，现在肯定要new一个新的table出来，然后把原来的table拷贝到这个新的table中。再细化一下，肯定是遍历原来的table然后判断哈希桶的根中是否存在数据存在数据则说明不是链表就是树，分别对链表和树进行相关处理，如果为空则跳过判断下一个了。</li><li>第2步拷贝到新的table完成后自然就返回这个新的table即可！！</li></ol><blockquote><p>如果只知道resize看表面来说是扩容方法，但是它还有一层含义就是初始化HashMap这个职责。这个我是肯定想不到，设计者思考的。</p><p>这个第2个步骤中对链表的处理，你想一下该怎么处理，现在的table是原来的2倍，链表该怎么移动？？后续给出答案！</p></blockquote><h3 id="源码解读-1"><a href="#源码解读-1" class="headerlink" title="源码解读"></a>源码解读</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123; <span class="comment">// hashMap的初始化、扩容方法</span></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table; <span class="comment">// 将table赋值给oldTab</span></span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">// 获取table的长度</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold; <span class="comment">// 将扩容阈值赋值给oldThr</span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>; <span class="comment">// 新的容量 和 新的扩容阈值</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">// 这里的意思就是你这个table已经初始化过了，并不是第一次使用这个hashMap</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; <span class="comment">// 如果你的旧容量大于默认的最大容量</span></span><br><span class="line">                threshold = Integer.MAX_VALUE; <span class="comment">// 将扩容阈值直接设置为int的最大值，就是再也不用考虑扩容</span></span><br><span class="line">                <span class="keyword">return</span> oldTab; <span class="comment">// 直接返回即可</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY) <span class="comment">// 将旧容量扩大2倍后赋值给新容量，如果小于默认的最大值 并且旧容量要大于默认的容量16</span></span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold 就将旧容量扩大2倍然后直接赋值给新的扩容阈值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 这里说明你是自己指定了这个hashMap的长度</span></span><br><span class="line">            newCap = oldThr; <span class="comment">// 你如果是通过有参数构造函数传过来的话，就是将hashMap的table长度赋值给了threshold，然后这里初始化的时候才真正的赋值给真正的容量</span></span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// 你并没有指定任何的初始值，也就是用的无参构造函数</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY; <span class="comment">// 将容量直接设置为默认即可</span></span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="comment">// 负载因子设置为(默认容量 x 负载因子 -&gt; 16 x 0.75)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123; <span class="comment">// 新的扩容阈值为0 这说明你是自己指定的hashMap容量，需要设置一下这个扩容阈值</span></span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor; <span class="comment">// 上面已经求出了新的hashMap容量，新的容量 x 负载因子 就是扩容阈值</span></span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ? <span class="comment">// 这里是判断你这个新的容量小于hashMap的默认最大值，并且新的阈值也要小于</span></span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE); <span class="comment">// 都满足的话新的扩容阈值直接设置为求出来的即可，否则设置为int最大值，以后无需考虑扩容</span></span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr; <span class="comment">// 将计算出来的扩容阈值赋值给threshold即可；从这往上所做的操作就是得到 newCap 和 newThr这两个值</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap]; <span class="comment">// 根据新容量设置一个新的Node数组</span></span><br><span class="line">        table = newTab; <span class="comment">// 将新的table数组赋值给table</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123; <span class="comment">// 如果旧的长度不为空，这个才会考虑将原来旧的数据转移到新创建的中Node数组中，否则你执行的只是hashMap的初始化操作没必要拷贝啊！！</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123; <span class="comment">// for循环遍历旧的Node数组</span></span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123; <span class="comment">// 如果hash桶的根不为空，则说明这个桶中存在数据，否则为空无需操作</span></span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>; <span class="comment">// 将旧的数据设置为空，释放空间，因为旧的桶已经不用了</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) <span class="comment">// 如果这个根结点的下一个结点为空则说明只有这一个数据</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">// 直接在新的Node数组中找出一个位置填进去即可。找的方法还是和原来一样 e.hash &amp; (newCap - 1)</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 这个桶中的数据已经变成了树了</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap); <span class="comment">// 拆了这个树</span></span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// 这个哈希桶为链表，这里操作巧妙，见后续详解，注释无法全部说明，先看后续详解再看注释比较好！！！</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>; <span class="comment">// 定义 旧的位置的头结点，旧的位置尾结点</span></span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>; <span class="comment">// 定义 新的位置的头结点，新的位置尾结点</span></span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">// (e.hash &amp; oldCap) == 0 只要满足这个条件就是在原位置的链表</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>) <span class="comment">// 这几步的操作就是构建这个旧的位置的链表</span></span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123; <span class="comment">// 否则就是在 旧容量 + 原来的下标的位置上</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>) <span class="comment">// 这几步的操作就是构建这个新的位置的链表</span></span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123; <span class="comment">// 旧位置下的链表头不为空</span></span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead; <span class="comment">// 将链表头填入哈希桶的根处</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123; <span class="comment">// 新位置下的链表头不为空</span></span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead; <span class="comment">// 将链表头填入哈希桶的根处</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab; <span class="comment">// 返回这个新的Node数组</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/Snipaste_2020-07-25_15-30-02.png" alt=""></p><p>统一说明这两个问题（<strong>这也和为什么长度要是2的次幂有关</strong>）</p><p>举个栗子！旧容量为4，扩容后为8：</p><p><img src="https://image.cclblog.cn/Snipaste_2020-07-25_16-22-57.png" alt=""></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><blockquote><p>这个resize方法很重要，是兼顾了初始化，和扩容。这个方法大致分为2部分，前面一部分是确定新的table长度和新的扩容阈值threshold。后半部分就是new个新的table然后复制元素到新的table中然后返回新的table。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 集合框架 </category>
          
          <category> Map </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 集合框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RenntrantLock中unlock过程解析</title>
      <link href="/2020/07/20/java/juc/reentrantLock-unlock/"/>
      <url>/2020/07/20/java/juc/reentrantLock-unlock/</url>
      
        <content type="html"><![CDATA[<h1 id="RenntrantLock中unlock过程解析"><a href="#RenntrantLock中unlock过程解析" class="headerlink" title="RenntrantLock中unlock过程解析"></a>RenntrantLock中unlock过程解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>直接点进unlock方法，这个解锁和加锁不一样不分公平非公平之说。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>查看release方法</p><h2 id="release方法"><a href="#release方法" class="headerlink" title="release方法"></a>release方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head; <span class="comment">// 获得当前队列的头结点</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) </span><br><span class="line">                unparkSuccessor(h); <span class="comment">// 这个方法是释放锁中的重头戏最为重要，后面详细说明。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><pre><code>/** * h != null 判断队列头是否为空，如果head执行null，说明当前并没发生竞争，只有一个线程访问或者线程交替访问简短来说就是发生线程竞争的情况 * h.waitStatus != 0 需要满足这个条件是因为如果头线程的waitStatus为0的话只能说明线程中曾发生过竞争，但是现在已经不存在需要唤醒的结点了，就是当前线程中只有头结点这一个结点。 * 你不了解为什么这样的话可以看加锁的过程，后一个结点会把前一个结点的状态设置为-1。然后再根据后面说明的唤醒线程的具体处理过程unparkSuccessor(h)方法看一看。 */</code></pre></blockquote><p>先看tryRelease这个方法，这个和加锁中的那个tryAcquire方法一样的，一个尝试解锁，一个尝试获取锁。都是模板方法的体现，具体的实现交由子类重写。</p><p><img src="https://image.cclblog.cn/Snipaste_2020-07-27_16-01-54.png" alt=""></p><h2 id="tryRelease方法"><a href="#tryRelease方法" class="headerlink" title="tryRelease方法"></a>tryRelease方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases; <span class="comment">// 获取原来的锁的状态减去释放的 重入的一种体现</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) <span class="comment">// 当前要尝试解锁的线程和持有锁的线程是不是一样，不一样则就出现错误了！！</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(); <span class="comment">// 抛出异常程序终止</span></span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>; <span class="comment">// 这个变量代表是否释放锁成功，false代表失败，true成功，看下面代码就知道了。。</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 如果锁释放后，c=0的意思就是锁的状态变为未被任何线程持有状态</span></span><br><span class="line">                free = <span class="keyword">true</span>; <span class="comment">// 释放成功，将free设置为true。</span></span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>); <span class="comment">// 将当前持有锁的线程设置为空，因为没有线程持有锁了，肯定要设置null啊。</span></span><br><span class="line">            &#125;</span><br><span class="line">            setState(c); <span class="comment">// 设置锁的状态</span></span><br><span class="line">            <span class="keyword">return</span> free; <span class="comment">// 返回当前线程是否成功释放锁！</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    exclusiveOwnerThread = thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个方法只是简单的释放锁而已并不是释放锁的重头戏，唤醒线程释放锁才是重头戏。这个tryRelease方法也体现了ReentrantLock锁的重入性。</p></blockquote><p>这个方法执行完毕后返回free，如果释放成功，返回true，看release方法接着向下执行。</p><h2 id="unparkSuccessor方法（※）"><a href="#unparkSuccessor方法（※）" class="headerlink" title="unparkSuccessor方法（※）"></a>unparkSuccessor方法（※）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus; <span class="comment">// 获取头结点的waitStatus</span></span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) <span class="comment">// 头结点的ws小于0，存在需要唤醒的结点</span></span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>); <span class="comment">// 将头结点的ws设置为0</span></span><br><span class="line">    </span><br><span class="line">        Node s = node.next; <span class="comment">// 获取头结点的下一个结点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果头结点的下一个结点为null，或者头结点的下一个结点的ws&gt;0，都是些不正常的情况</span></span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev) <span class="comment">// 这个for循环是从线程的尾结点一直向前便利直到获得最后一个等待唤醒的结点。（这里的最后如果从前往后就是第一个，从后往前不就是最后了吗hh）</span></span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread); <span class="comment">// 唤醒这个队列中第一个waitStatus&lt;0的那个线程</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/Snipaste_2020-07-27_16-56-43.png" alt=""></p><h2 id="线程被唤醒之后"><a href="#线程被唤醒之后" class="headerlink" title="线程被唤醒之后"></a>线程被唤醒之后</h2><blockquote><p>不知道还知不知道这个被唤醒的线程当时最后被阻塞哪里！！！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 阻塞当前线程</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>被唤醒的那个线程当时被阻塞到了这里，被唤醒之后肯定要尝试获取锁，走的还是加锁的那套流程，知道在哪阻塞了加锁之前那套也说的很明白。可以看之前的加锁过程来了解，这里简单的说明。</p><p><img src="https://image.cclblog.cn/Snipaste_2020-07-27_17-05-49.png" alt=""></p><blockquote><p>return Thread.interrupted();这个返回值不用太在意，返回线程的一个中断状态，阻塞的时候是否被中断了，这里很细节暂时不用管。只知道返回了true或者false，程序继续执行，又进入一次for循环，因为锁已经是空闲状态所有，这里尝试获取锁会成功，然后将原来的头结点干掉，当前节点变为原来的头结点。</p><p><strong>这也就说明了unparkSuccessor中为什么直接ws设置为0</strong>，这个当前节点也有两种情况。</p><p>一种为&lt;0，说明线程中还存在需要被唤醒的结点，它释放锁后和这个unlock路线一样的。</p><p>还有一种情况是状态为0，说明当前节点是这个队列中最后的那个结点（因为最后那个结点的状态才会是0），队列中也自然就不存在需要被唤醒的结点了啊。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>解锁过程就是将这个锁的状态设置为0-&gt;将当前持有锁的线程设置为null-&gt;唤醒队列中的线程-&gt;被唤醒的线程执行加锁的过程。。。。明白了加锁过程解锁应该很简单。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RenntrantLock中lock过程解析</title>
      <link href="/2020/07/16/java/juc/reentrantLock-lock/"/>
      <url>/2020/07/16/java/juc/reentrantLock-lock/</url>
      
        <content type="html"><![CDATA[<h1 id="RenntrantLock中lock过程解析"><a href="#RenntrantLock中lock过程解析" class="headerlink" title="RenntrantLock中lock过程解析"></a>RenntrantLock中lock过程解析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="公平锁与非公平锁初识"><a href="#公平锁与非公平锁初识" class="headerlink" title="公平锁与非公平锁初识"></a>公平锁与非公平锁初识</h2><p>直接点进lock()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock(); <span class="comment">// lock方法为Sync类中的抽象方法，具体交由它的子类（FairSync和NonfairSync）来实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用sync的lock方法，Sync是RenntrantLock的一个内部类，Sync这个lock方法是抽象方法，实则分别调用的是它的两个子类的lock方法。</p><p><img src="https://image.cclblog.cn/Snipaste_2020-07-23_22-50-05.png" alt=""></p><p><img src="https://image.cclblog.cn/Snipaste_2020-07-23_22-51-09.png" alt=""></p><p><strong>FairSync</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            acquire(<span class="number">1</span>); <span class="comment">// 公平锁直接调用AQS中的acquire(int)方法</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>NonfairSync</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; <span class="comment">// 非公平锁，先尝试获取锁，这里和公平锁的区别可以看到了吧，公平锁直接执行else中代码！！！所以这个效率比公平锁高</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">// CAS尝试获取锁</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread()); <span class="comment">// 获取成功将当前线程设置为成员变量（exclusiveOwnerThread）拥有锁的线程</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>); <span class="comment">// 否则就和公平锁一样使用AQS中的acquire(int)方法来进行后续处理。</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>代码中的注释写出了非公平锁和公平锁的区别，好比超市排队结账，非公平锁就是买完东西后一来就直接要插队，要去结账（插队操作就是CAS操作），然后发现此时收银员正在给另外一个人结账（也就是锁被其他线程占用），那就乖乖排队，执行acquire(1)；公平锁就好比一个老实人，乖乖排队直接acquire(1)。</strong></p></blockquote><h2 id="acquire方法"><a href="#acquire方法" class="headerlink" title="acquire方法"></a>acquire方法</h2><p>它们都要进入acquire方法，这个方法是AQS类中的一个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它们都会执行tryAcquire(arg)这个方法，这个方法的意思是尝试获取锁，但是这个方法在AQS中并未具体实现，子类来实现这个方法，模板方法设计模式的一种体现。</p><p><img src="https://image.cclblog.cn/Snipaste_2020-07-23_23-02-44.png" alt=""></p><h2 id="tryAcquire方法"><a href="#tryAcquire方法" class="headerlink" title="tryAcquire方法"></a>tryAcquire方法</h2><h3 id="FairSync中"><a href="#FairSync中" class="headerlink" title="FairSync中"></a><strong>FairSync中</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123; <span class="comment">// 获取锁成功true，否则false</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread(); <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();  <span class="comment">// 获取锁当前状态</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 如果当前状态为0则表示锁未被占用</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">// 判断自己是否需要排队</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// CAS设置这个状态为acquires</span></span><br><span class="line">            setExclusiveOwnerThread(current); <span class="comment">// 设置当前线程为拿到锁的这个线程</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 返回true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// state不是0，则说明锁被持有，判断一下当前请求线程是否等于持有这个锁的线程。这里体现了ReentrantLock的重入性！！！</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires; <span class="comment">// 原来的状态加上acquires</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// 判断一下是否小于0，基本不可能出现这个情况</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc); <span class="comment">// 重新对state进行赋值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 获取失败返回false，锁在被其它线程占用并且占用这个锁的线程也不是当前请求的线程。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NonfairSync中"><a href="#NonfairSync中" class="headerlink" title="NonfairSync中"></a><strong>NonfairSync中</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;    <span class="keyword">return</span> nonfairTryAcquire(acquires);&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// 这里可以看出非公平锁没有调用!hasQueuedPredecessors()这个方法，也就是无需判断自己是否排队。其它操作和公平锁相同。</span></span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><p>明白上述操作就应该明白了</p><ol><li><strong>非公平锁和公平锁的区别？</strong></li><li><strong>RenntrantLock为什么是可重入锁？</strong></li><li><strong>RenntrantLock类的内部结构？</strong></li></ol><p>之后读源码就该按照一条线来分析了，上述操作是按照两条线，（公平锁和非公平锁），下面就来具体分析公平锁的加锁是怎么实现的，因为公平锁比非公平锁多一点东西，公平锁弄懂，非公平锁自然也就容易明白了。</p></blockquote><h2 id="详解公平锁加锁过程"><a href="#详解公平锁加锁过程" class="headerlink" title="详解公平锁加锁过程"></a>详解公平锁加锁过程</h2><p>前面调用了FairSync中的tryAcquire方法后，如果获取成功返回true，否则返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">//这里假如FairSync的这个方法返回的是false获取锁失败，要是返回true的话就不用往下看了。</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>分析<strong>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</strong>这个方法，先看其中的addWaiter这个方法，实际上这里你想一下，自己获取锁失败了，结果就是自己要去排队了，就是实际处理更加复杂而已。</p><h3 id="addWaiter方法"><a href="#addWaiter方法" class="headerlink" title="addWaiter方法"></a>addWaiter方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123; <span class="comment">// 这个方法就是为当前线程排队节点，并且初始化这个队列，这个参数的意思就是你是共享模式(Node.SHARED)还是独占模式(Node.EXCLUSIVE)。</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode); <span class="comment">// 封装当前线程为Node结点</span></span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        Node pred = tail; <span class="comment">// 得到这个队列的尾结点</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">// 如果这个尾结点不为空，这里说明这个队列已经初始化过了</span></span><br><span class="line">            node.prev = pred; <span class="comment">// 将当前线程的结点的上一个指向这个尾结点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="comment">// CAS设置当前线程封装的结点为尾结点，之所以CAS操作是因为这时候有可能会有其它线程更改了这个尾结点！！！</span></span><br><span class="line">                pred.next = node; <span class="comment">// CAS设置成功 将原来的尾结点的下一个指针设置为当前线程结点</span></span><br><span class="line">                <span class="keyword">return</span> node; <span class="comment">// 返回当前线程的结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node); <span class="comment">// 当前队列未初始化或者CAS设置失败（在这个过程中别的线程将尾结点更改）</span></span><br><span class="line">        <span class="keyword">return</span> node; <span class="comment">// 返回当前线程的结点</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我感觉这个实际上说初始化可能不太准确，先看Node结点的成员变量组成都有哪些。（注意并未列出全部只是列出部分当前使用到的成员变量）</p><p><img src="https://image.cclblog.cn/Snipaste_2020-07-24_11-46-06.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结点共享模式下的标记</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line"><span class="comment">// 结点独占模式下的标记</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 上一个结点</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;</span><br><span class="line"><span class="comment">// 下一个结点</span></span><br><span class="line"><span class="keyword">volatile</span> Node next;</span><br><span class="line"><span class="comment">// 这个结点的线程</span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread;</span><br></pre></td></tr></table></figure><p>这是这个Node类中目前使用到的部分成员变量，从这些元素中就可以看出这个是一个双向链表的一个结点。然后分析AQS中的一些成员变量。</p><p><img src="https://image.cclblog.cn/Snipaste_2020-07-24_11-50-10.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="comment">// 尾结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"><span class="comment">// 锁的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><p>知道这些后肯定就认识到了，在这个队列未初始化之前的情况是：</p><p><img src="https://image.cclblog.cn/Snipaste_2020-07-24_11-59-36.png" alt=""></p><h4 id="enq方法"><a href="#enq方法" class="headerlink" title="enq方法"></a>enq方法</h4><p>继续向下执行，上述addWaiter假如我们未初始化，或者CAS失败，然后会执行enq这个方法。这个方法主要难度在理解这个for死循环，构成了不断自旋操作，使用CAS+自旋设置tail结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 死循环</span></span><br><span class="line">            Node t = tail; <span class="comment">// 获得当前尾结点</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 尾结点为空初始化这个结点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">// new 一个Node结点，CAS设置为头结点</span></span><br><span class="line">                    tail = head; <span class="comment">// 让尾结点也指向这个结点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 已经初始化</span></span><br><span class="line">                node.prev = t; <span class="comment">// node结点的上一个指向尾结点（这个node结点是你本线程构造出来的一个结点）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">// CAS设置尾结点为你当前线程的结点</span></span><br><span class="line">                    t.next = node; <span class="comment">// 设置成功将以前尾结点的下一个结点指针指向当前线程的结点</span></span><br><span class="line">                    <span class="keyword">return</span> t; <span class="comment">// 返回旧的尾结点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/Snipaste_2020-07-24_13-57-10.png" alt=""></p><p>这个操作执行完后那么这个addWaiter方法就彻底执行完毕了，此刻的链表的情况为：</p><p><img src="https://image.cclblog.cn/Snipaste_2020-07-24_14-08-59.png" alt=""></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><blockquote><p>这个图应该很清楚了吧，那个thread那个t1是我随便写的，表示的线程对象。</p><p>现在应该明白了addWaiter（）这个方法是做什么的了吧！！！</p></blockquote><p><img src="https://image.cclblog.cn/Snipaste_2020-07-24_14-28-22.png" alt=""></p><h3 id="acquireQueued-addWaiter-Node-EXCLUSIVE-arg-方法"><a href="#acquireQueued-addWaiter-Node-EXCLUSIVE-arg-方法" class="headerlink" title="acquireQueued(addWaiter(Node.EXCLUSIVE), arg)方法"></a>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)方法</h3><p>前面已经了解了addWaiter这个方法，这个方法返回的是当前线程封装后的Node结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123; <span class="comment">// 死循环</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">// 获取当前线程结点的前一个结点！</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 如果这当前线程的前一个结点为头结点那么就执行tryAcquire方法尝试获取锁，这是自旋的一种体现</span></span><br><span class="line">                    setHead(node); <span class="comment">// 获取锁成功，将当前线程节点设置为头结点</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// 断绝之前的头结点和现在的头结点直线的关系，方便将其GC回收</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 当前节点不是线程中的第二个节点(也就是你前一个节点是head节点)或者tryAcquire获取锁失败，执行此方法</span></span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>现在来看shouldParkAfterFailedAcquire这个方法</p><h4 id="shouldParkAfterFailedAcquire方法"><a href="#shouldParkAfterFailedAcquire方法" class="headerlink" title="shouldParkAfterFailedAcquire方法"></a>shouldParkAfterFailedAcquire方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus; <span class="comment">// 获取你前一个结点的一个状态</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL) <span class="comment">// 判断这个状态是否为-1，代表你当前并不不能去尝试获取锁，要被阻塞</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果这个状态大于0，说明当前线程被中断</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123; <span class="comment">// do while删除队列中状态大于0的线程结点</span></span><br><span class="line">                node.prev = pred = pred.prev; <span class="comment">// 将node的前一个结点指针重新设置，并且让pred重新赋值为一个状态不是大于0的结点</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node; <span class="comment">// 将pred结点的下一个指针指向当前线程结点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL); <span class="comment">// 否则将前一个线程结点的状态设置为-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// return false</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/Snipaste_2020-07-24_15-00-00.png" alt=""></p><p>假如返回false的话就再次执行循环，尝试获取锁，这就是第二次自旋操作！！！</p><p>如果第二次自旋还是获取锁失败的话，又将进入这个方法，此时当前线程的前一个结点的waitStatus为-1，直接返回true，导致parkAndCheckInterrupt()这个方法执行！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 阻塞当前线程</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到这里线程的加锁才真正的结束！！！到现在还有一个方法还未说明，不知道心里想到了吗！！hasQueuedPredecessors()就是这个方法，到现在才说因为要把前面这些弄懂这个方法才比较好明白！！</p><h3 id="hasQueuedPredecessors-方法"><a href="#hasQueuedPredecessors-方法" class="headerlink" title="hasQueuedPredecessors()方法"></a>hasQueuedPredecessors()方法</h3><p>这个方法是tryAcquire中的判断自己是否需要排队</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp; <span class="comment">// 队列不为空，但是当前线程是队列中第一个排队的那个线程。</span></span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/Snipaste_2020-07-24_15-24-08.png" alt=""></p><p>到此非公平锁加锁完毕，非公平锁大致流程也一样，就是除了我上述说的那些不一样之外都相同。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AQS就是用一个volatile修饰的state标志来记录锁相关的状态，加上一个阻塞队列。如果这个标志位是被占用状态然后此线程就阻塞入队，空闲状态就可以获取锁，这里获取锁成功的含义就是你那个线程执行的lock()这个方法能正常返回，然后它自然就可以向下执行了，加锁不就是阻塞住，不让lock()方法正常返回吗。不过在阻塞这个过程中存在很多细节，并不是直接将线程阻塞住（这样的话不就和1.6之前的synchronized差不多啦嘛，当然是在存在线程竞争情况下，非竞争情况下还是lock是Java API级别较快），而是进行自旋操作再次尝试获取锁（不知道你感觉这个1.6版本的synchronized锁升级差不多吗）。加锁就是利用的Unsafe类的park()方法。</p><p>然后这里简单总结一下。</p><ol><li>阻塞队列的第一个结点的线程总是为空。</li><li>当前持有锁的那个线程总是不在队列当中。</li></ol><blockquote><p>那个第一个结点应该模拟的是当前持有锁的那个线程，就像食堂吃饭排队一样，你能说在窗口打饭的第一个人在排队吗？？？</p><p>只有第二个人才是第一个在排队等待的人，他才有资格询问一下该不该轮到我了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/2020/07/13/java/designMode/FactoryPattern/"/>
      <url>/2020/07/13/java/designMode/FactoryPattern/</url>
      
        <content type="html"><![CDATA[<h1 id="工厂模式（FactoryPattern）"><a href="#工厂模式（FactoryPattern）" class="headerlink" title="工厂模式（FactoryPattern）"></a>工厂模式（FactoryPattern）</h1><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>生产AK47、M4A1、M16这三种枪械</p><h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h1><p><img src="https://image.cclblog.cn/Snipaste_2020-07-24_21-57-17.png" alt=""></p><h2 id="具体产品类"><a href="#具体产品类" class="headerlink" title="具体产品类"></a>具体产品类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rifle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 射击</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 装弹中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reloading</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 特性</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trait</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AK47</span> <span class="keyword">implements</span> <span class="title">Rifle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AK47射击 -- 哒哒哒哒哒哒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reloading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Ak47 填充弹夹"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Ak47 威力大，后坐力大！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">M4A1</span> <span class="keyword">implements</span> <span class="title">Rifle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"M4A1射击 -- 哔哔哔哔哔哔"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reloading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"M4A1 填充弹夹"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"M4A1 射程远，射速快！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">M16</span> <span class="keyword">implements</span> <span class="title">Rifle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"M16射击 -- 嘤嘤嘤嘤嘤嘤"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reloading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"M16 填充弹夹"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"M16 后坐力低，精度高！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂-1"><a href="#简单工厂-1" class="headerlink" title="简单工厂"></a>简单工厂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RifleFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Rifle&gt; <span class="function">T <span class="title">getRifle</span><span class="params">(Class&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        Rifle rifle = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过反射来生成对象，而不是传输一个字符串比较，符合开闭原则</span></span><br><span class="line">            rifle = (Rifle) Class.forName(c.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) rifle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AK47 ak47 = RifleFactory.getRifle(AK47<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">// 通过工厂获取一把AK47</span></span><br><span class="line">        ak47.reloading(); <span class="comment">// 填充子弹</span></span><br><span class="line">        ak47.fire(); <span class="comment">// 射击</span></span><br><span class="line">        ak47.trait(); <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><p>简单工厂比较简单，如果获得某个类的对象的时候直接获取不需要其它的一些特殊处理，则可以使用这个简单工厂模式，需要对不同的类进行定制处理，则这个工厂显得过于冗余，不好处理！！！</p></blockquote><h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h1><p><img src="https://image.cclblog.cn/Snipaste_2020-07-24_22-06-57.png" alt=""></p><p><img src="https://image.cclblog.cn/Snipaste_2020-07-24_22-08-08.png" alt=""></p><h2 id="具体产品类-1"><a href="#具体产品类-1" class="headerlink" title="具体产品类"></a>具体产品类</h2><p>与简单工厂中相同！！！</p><h2 id="工厂方法-1"><a href="#工厂方法-1" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>定义一个抽象工厂或者接口，我比较喜欢用接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractRifleFactory</span> </span>&#123;</span><br><span class="line">    &lt;T extends Rifle&gt; <span class="function">T <span class="title">createRifle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AK47Factory</span> <span class="keyword">implements</span> <span class="title">AbstractRifleFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Rifle&gt; <span class="function">T <span class="title">createRifle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">new</span> AK47();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">M4A1Factory</span> <span class="keyword">implements</span> <span class="title">AbstractRifleFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Rifle&gt; <span class="function">T <span class="title">createRifle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">new</span> M4A1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">M16Factory</span> <span class="keyword">implements</span> <span class="title">AbstractRifleFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Rifle&gt; <span class="function">T <span class="title">createRifle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">new</span> M16();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试类-1"><a href="#测试类-1" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AK47Factory ak47Factory = <span class="keyword">new</span> AK47Factory(); <span class="comment">// 只需知道AK47工厂便可得到其对象</span></span><br><span class="line">        AK47 ak47 = ak47Factory.createRifle(); <span class="comment">// 来一把AK47</span></span><br><span class="line">        ak47.reloading();</span><br><span class="line">        ak47.fire();</span><br><span class="line">        ak47.trait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><blockquote><p>工厂模式相较简单工厂具体的生产交由子类来实现，每个工厂职责单一，可对每个产品生产做特殊处理也不至于显得冗余，但是这个扩展的话增加的类你不感觉太多了吧，容易造成类爆炸，上述例子比较简单，如果在不同步枪的基础上，还需要添加国家这个条件呢，俄罗斯AK47，俄罗斯M4A1，美国AK47，美国M4A1等等。。这就需要轮到抽象工厂上场了。</p></blockquote><h1 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h1><p>现在需求发生变化，每个步枪都由俄罗斯和美国来制作，生产时要知道我这是俄罗斯AK47还是美国制造。</p><blockquote><p>这里需要知道产品族的概念，这个概念比较简单。你根据国家来分的话，比如俄罗斯的AK47，M4A1，M16都是俄罗斯生产的他们是一个产品族。然后根据步枪的种类来分的话，俄罗斯的AK47，美国的AK47是一个产品族，看具体要求的场景了。反正比较灵活。</p></blockquote><h2 id="具体的产品类"><a href="#具体的产品类" class="headerlink" title="具体的产品类"></a>具体的产品类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rifle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 射击</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 装弹中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reloading</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 特性</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trait</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">USAM16</span> <span class="keyword">implements</span> <span class="title">Rifle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"USA M16射击 -- 嘤嘤嘤嘤嘤嘤"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reloading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"USA M16 填充弹夹"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"USA M16 后坐力低，精度高！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">USAM4A1</span> <span class="keyword">implements</span> <span class="title">Rifle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"USA M4A1射击 -- 哔哔哔哔哔哔"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reloading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"USA M4A1 填充弹夹"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"USA M4A1 射程远，射速快！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">USAAK47</span> <span class="keyword">implements</span> <span class="title">Rifle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"USA AK47射击 -- 哒哒哒哒哒哒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reloading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"USA Ak47 填充弹夹"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"USA Ak47 威力大，后坐力大！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RussiaM16</span> <span class="keyword">implements</span> <span class="title">Rifle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Russia M16射击 -- 嘤嘤嘤嘤嘤嘤"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reloading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Russia M16 填充弹夹"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Russia M16 后坐力低，精度高！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RussiaM4A1</span> <span class="keyword">implements</span> <span class="title">Rifle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Russia M4A1射击 -- 哔哔哔哔哔哔"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reloading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Russia M4A1 填充弹夹"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Russia M4A1 射程远，射速快！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RussiaAK47</span> <span class="keyword">implements</span> <span class="title">Rifle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Russia AK47射击 -- 哒哒哒哒哒哒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reloading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Russia Ak47 填充弹夹"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Russia Ak47 威力大，后坐力大！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象工厂-1"><a href="#抽象工厂-1" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>这里我根据枪械来分类，所以要创建3个不同枪械的工厂，根据国家的话创建两个工厂就够了！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RifleFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建俄罗斯步枪</span></span><br><span class="line">    &lt;T extends Rifle&gt; <span class="function">T <span class="title">createRussiaRifle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建美国步枪</span></span><br><span class="line">    &lt;T extends Rifle&gt; <span class="function">T <span class="title">createUSARifle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">M16Factory</span> <span class="keyword">implements</span> <span class="title">RifleFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Rifle&gt; <span class="function">T <span class="title">createRussiaRifle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">new</span> RussiaM16();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Rifle&gt; <span class="function">T <span class="title">createUSARifle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">new</span> USAM16();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">M4A1Factory</span> <span class="keyword">implements</span> <span class="title">RifleFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Rifle&gt; <span class="function">T <span class="title">createRussiaRifle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">new</span> RussiaM4A1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Rifle&gt; <span class="function">T <span class="title">createUSARifle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">new</span> USAM4A1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AK47Factory</span> <span class="keyword">implements</span> <span class="title">RifleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Rifle&gt; <span class="function">T <span class="title">createRussiaRifle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">new</span> RussiaAK47();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Rifle&gt; <span class="function">T <span class="title">createUSARifle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">new</span> USAAK47();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试类-2"><a href="#测试类-2" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// AK47生产线</span></span><br><span class="line">        AK47Factory ak47Factory = <span class="keyword">new</span> AK47Factory();</span><br><span class="line">        RussiaAK47 russiaAK47 = ak47Factory.createRussiaRifle();</span><br><span class="line">        russiaAK47.reloading();</span><br><span class="line">        russiaAK47.fire();</span><br><span class="line">        russiaAK47.trait();</span><br><span class="line">        System.out.println(<span class="string">"===================================="</span>);</span><br><span class="line">        <span class="comment">// M4A1生产线</span></span><br><span class="line">        M4A1Factory m4A1Factory = <span class="keyword">new</span> M4A1Factory();</span><br><span class="line">        USAM4A1 usam4A1 = m4A1Factory.createUSARifle();</span><br><span class="line">        usam4A1.reloading();</span><br><span class="line">        usam4A1.fire();</span><br><span class="line">        usam4A1.trait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p><img src="https://image.cclblog.cn/Snipaste_2020-07-24_22-49-24.png" alt=""></p><blockquote><p>抽象工厂解决了工厂方法，由于条件变成二维导致类产生急剧增多的问题，如果这个需求按照工厂方法来写则需要创建6个工厂，抽象方法创建3个就可，减少了类，但是这个抽象方法有个缺点就是，如果加入一个中国制造那就需要在那个接口中添加一个中国制造的方法，所有实现这个接口的类都需要修改，就违反了开闭原则，横向容易扩展，假如你现在添加一个QBZ95步枪生产线就很容易。纵向不容易扩展，根据具体的场景选择使用。</p></blockquote><h1 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h1><blockquote><p>简单工厂主要将各个产品的创造全部集中到了一个工厂中，通过反射类符合开闭原则。</p><p>工厂方法是定义一个抽象工厂类，不同产品对应不同的工厂，继承抽象工厂类来生产不同的产品。</p><p>抽象工厂解决的是工厂方法应对二维条件，会产生过多的工厂的问题，但是抽象工厂纵向不易拓展。</p><p>这三种都不是最完美的，各有优缺点，具体场景具体使用！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中集合框架</title>
      <link href="/2020/07/10/java/theme/collections/"/>
      <url>/2020/07/10/java/theme/collections/</url>
      
        <content type="html"><![CDATA[<p><img src="https://image.cclblog.cn/Snipaste_2020-07-25_22-39-29.png" alt="常见的List"></p><p><img src="https://image.cclblog.cn/Snipaste_2020-07-25_22-39-54.png" alt="常见的Map"></p><p><img src="https://image.cclblog.cn/Snipaste_2020-07-25_22-52-20.png" alt="Queue"></p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h2 id="Vector、Stack"><a href="#Vector、Stack" class="headerlink" title="Vector、Stack"></a>Vector、Stack</h2><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="添加元素方法put（√）"><a href="#添加元素方法put（√）" class="headerlink" title="添加元素方法put（√）"></a><a href="/2020/07/24/java/collection/HashMap-put">添加元素方法put（√）</a></h3><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><h2 id="……"><a href="#……" class="headerlink" title="……"></a>……</h2>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> JAVA </category>
          
          <category> 集合框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> JAVA </tag>
            
            <tag> 集合框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2020/07/09/java/designMode/SingletonPattern/"/>
      <url>/2020/07/09/java/designMode/SingletonPattern/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式（SingletonPattern）"><a href="#单例模式（SingletonPattern）" class="headerlink" title="单例模式（SingletonPattern）"></a>单例模式（SingletonPattern）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>单例设计模式（Singleton Design Pattern）。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式 。</strong></p><h2 id="实现一个单例需要考虑的问题？"><a href="#实现一个单例需要考虑的问题？" class="headerlink" title="实现一个单例需要考虑的问题？"></a>实现一个单例需要考虑的问题？</h2><ol><li>构造函数需要时private访问权限的，这样才能避免外部通过new创建实例。</li><li>考虑对象创建时的线程安全问题。</li><li>考虑延迟加载的问题。</li><li>考虑性能问题，是否加锁。</li></ol><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1.饿汉式"></a>1.饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungryType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> HungryType instance = <span class="keyword">new</span> HungryType();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungryType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungryType <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。 这个不支持懒加载不一定就不好，提前初始化确实是一种浪费资源的行为，但是如果你的这个单例类初始化时间过长的话，极端一点，还不如系统运行起来的时候就先加载好，这样用户访问响应变快，当然这个比较极端，空间换时间。</p></blockquote><h3 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2.懒汉式"></a>2.懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyType instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazyType <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazyType();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>懒汉式相对饿汉式来说就是支持懒加载，但是这个synchronized关键字，每次去访问这个方法都会锁，导致这个函数并发度较低。<strong>我认为不要使用这种方法。</strong></p></blockquote><h3 id="3-双重检测（DCL）"><a href="#3-双重检测（DCL）" class="headerlink" title="3.双重检测（DCL）"></a>3.双重检测（DCL）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DCLType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DCLType instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DCLType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DCLType <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 类级别的锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DCLType<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> DCLType();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>双重检测锁（DCL）解决了懒汉式synchronized关键字每次访问该方法都加锁的问题。提高了性能。这个方式既支持懒加载又提高了并发度。</p><p><strong>volatile</strong></p><p>这个instance加这个关键字是因为指令重排的问题，防止对象被new出来，赋值给了instance但是还没来得及初始化，就被另一个线程拿去使用了。可加可不加，现在高版本的Java不存在这个问题了。（这个我只是简单的说一下，这个要了解JVM类加载的过程，字节码指令）</p></blockquote><h3 id="4-静态内部类"><a href="#4-静态内部类" class="headerlink" title="4.静态内部类"></a>4.静态内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InnerClassType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义私有的静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InnerClassType instance = <span class="keyword">new</span> InnerClassType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InnerClassType <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个静态内部类的方法是简化了DCL方式，但是又拥有DCL的特性。我感觉这个不错！<strong>这种实现方法既保证了线程安全，又能做到延迟加载。</strong></p><p>如果了解静态内部类特性的话，肯定知道外部类加载静态内部类不会去加载，等你调用getInstance这个方法的时候才会去加载静态内部类 。这就实现了<strong>懒加载</strong>。</p><p><strong>至于线程安全，这个JVM来保证的。</strong></p></blockquote><h3 id="5-枚举"><a href="#5-枚举" class="headerlink" title="5.枚举"></a>5.枚举</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumType &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>之所以存在一个枚举类是因为前面的几种严格意义上来说并不安全，虽然加了synchronized关键字，但是你这个只能保证多线程环境下的安全，Java中存在<strong>反射</strong>。</p><p>枚举是绝对安全的，而且简单，要知道为什么就需要去详细了解enum。简单的说一下这个类反编译后是继承java.lang.Enum这个类的。所以说enum可以算是一种class的一种特殊化。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我只是简单的列举了单例的几种实现方式，其中并没有写一些关于业务的逻辑代码，比如你可以像枚举类那个例子中那样，用单例模式实现一个简单的计数器。<strong>这些单例模式前三种肯定要十分明白，尤其是第三种（DCL）。</strong>但是我都感觉不太好，我感觉静态内部类较好，枚举类实现单例最好。</p><p>上述只是说明单例的实现的几种方式，并没有说明为什么要使用单例模式，单例模式的弊端（破坏面向对象的特性等等），替代单例模式的方案，多例模式（限定数量new多个一个类的实例）的实现方式，可以百度查找，这个我目前只是明白一些并不能总结很好，停留知道怎么使用阶段。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new一个类初始化的顺序</title>
      <link href="/2020/07/03/java/javase/18/"/>
      <url>/2020/07/03/java/javase/18/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StringBuffer与StringBuilder</title>
      <link href="/2020/07/02/java/javase/4/"/>
      <url>/2020/07/02/java/javase/4/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li><strong>StringBuffer</strong>就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类，提供append和add方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个线程安全的可修改的字符序列，把所有修改数据的方法都加上synchronized。但是保证了线程安全是需要性能的代价的。</li><li><strong>StringBuilder</strong>是JDK1.5发布的，它和<strong>StringBuffer</strong>本质上并没有什么区别，就是去掉了保证线程安全的那部分，减少了开销。</li></ul><h1 id="相同点、不同点"><a href="#相同点、不同点" class="headerlink" title="相同点、不同点"></a>相同点、不同点</h1><p><img src="https://image.cclblog.cn/blog/20200702174359.png" alt=""></p><blockquote><p>实际上StringBuffer就是一个加锁的StringBuilder，其它的除了那个缓冲区，没什么区别，他们就相当于一个壳子，实际上调用的是他们父类中的方法，来进行操作那个char[]数组的。</p></blockquote><h1 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h1><p><strong>这个要明白String是final修饰的，正是因为它的不可变性，所以例如拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"a"</span> + <span class="string">"b"</span> + <span class="string">"c"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/blog/20200702174739.png" alt=""></p><blockquote><p>这种情况编译器会直接带代码进行优化为 String a = “abc” 无需额外的操作，看字节码astore就知道直接存入局部变量表1的位置。（0的位置是args数组）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"a"</span>;</span><br><span class="line">        String b = <span class="string">"b"</span>;</span><br><span class="line">        String c = <span class="string">"c"</span>;</span><br><span class="line">        String d = a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/blog/20200702175310.png" alt=""></p><blockquote><p>这种编译器自然就没办法进行优化，但是JVM会帮助你做相关的优化，字节码中可以看出JVM中new StringBuilder操作append()方法拼接的字符串。</p><p><strong>这里并未出现new多次StringBuilder这个现象，我看网上的好多都说这个操作会出现new 多个StringBuilder对象，这个？？？？？。难道是JVM更加的优化了这个，还是有的我并不了解，待研究，遇到操作字符串拼接还是老老实实new StringBuilder吧</strong></p></blockquote><hr><blockquote><p><strong>突然想到循环，如果再循环内的话这个操作应该就会出现问题！！！</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"a"</span>;</span><br><span class="line">        String d = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            d += a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"a"</span>;</span><br><span class="line">        String d = <span class="string">""</span>;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            d = stringBuilder.append(a).toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/blog/20200702180455.png" alt=""></p><blockquote><p>百度需谨慎啊啊！！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的内部类</title>
      <link href="/2020/06/30/java/javase/6/"/>
      <url>/2020/06/30/java/javase/6/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在Java中，可以将一个类定义在另一个类里面或者一个方法里边，这样的类称为内部类，广泛意义上的内部类一般包括四种：</p><ul><li><p><strong>成员内部类</strong></p></li><li><p><strong>局部内部类</strong></p></li><li><p><strong>匿名内部类</strong></p></li><li><p><strong>静态内部类</strong> </p></li></ul><h1 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h1><ul><li><p><strong>该类像是外部类的一个成员，可以无条件的访问外部类的所有成员属性和成员方法（包括private成员和静态成员）</strong>；</p></li><li><p>成员内部类拥有与外部类同名的成员变量时，会发生隐藏现象，即默认情况下访问的是成员内部类中的成员。如果要访问外部类中的成员，需要以下形式访问：【外部类.this.成员变量  或  外部类.this.成员方法】；</p></li><li><p>在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问；</p></li><li><p>成员内部类是依附外部类而存在的，也就是说，<strong>如果要创建成员内部类的对象，前提是必须存在一个外部类的对象；</strong></p></li><li><p>内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。如果成员内部类用private修饰，则只能在外部类的内部访问；如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。<strong>外部类只能被public和包访问两种权限修饰。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String testStr = <span class="string">"琦玉"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterClass</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员内部类（普通内部类）</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 成员内部类不可以定义静态的属性和方法</span></span><br><span class="line">        <span class="comment">//private static String str;</span></span><br><span class="line">        <span class="keyword">private</span> String str;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.str = str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">testArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试内部类中和外部类出现同名方法</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 在内部类中出现和外部类同名方法，默认调用本类中的方法</span></span><br><span class="line">            <span class="comment">//testArea();</span></span><br><span class="line">            <span class="comment">// 外部类名.this.方法名/类名 可以调用外部方法</span></span><br><span class="line">            <span class="comment">// 无条件的访问外部类所有成员属性，和成员方法（即使是private，或者static）</span></span><br><span class="line">            System.out.println(OuterClass.<span class="keyword">this</span>.str); <span class="comment">// 外部类</span></span><br><span class="line">            System.out.println(testStr); <span class="comment">// 琦玉</span></span><br><span class="line">            <span class="keyword">return</span> OuterClass.<span class="keyword">this</span>.testArea();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass(<span class="string">"外部类"</span>);</span><br><span class="line">        InnerClass innerClass = outerClass.<span class="keyword">new</span> InnerClass(<span class="string">"局部内部类"</span>);</span><br><span class="line">        System.out.println(outerClass.testArea()); <span class="comment">// 打印 外部类</span></span><br><span class="line">        System.out.println(innerClass.test()); <span class="comment">// 打印 外部类 通过（外部类名.this.方法名）可以调用外部方法调用了外部类中方法</span></span><br><span class="line">        System.out.println(innerClass.testArea()); <span class="comment">// 打印 局部外部类</span></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出结果：</span></span><br><span class="line"><span class="comment">         * 外部类</span></span><br><span class="line"><span class="comment">         * 外部类</span></span><br><span class="line"><span class="comment">         * 琦玉</span></span><br><span class="line"><span class="comment">         * 局部外部类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h1><ul><li>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内；</li><li>局部内部类就像是方法里面的一个局部变量一样，是<strong>不能有public、protected、private以及static修饰符的。</strong></li></ul><blockquote><p>这个局部内部类太鸡肋了，应该都不怎么使用，定义的时候和普通的class是一样的，除了不能用修饰符，还有作用域太小了吧，谁没事在代码块中定义一个局部内部类啊。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">memberFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不可用修饰符修饰</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">PartInnerClass</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = <span class="string">"aaa"</span>;</span><br><span class="line">            <span class="keyword">private</span> String str1 = <span class="string">"sss"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">PartInnerClass</span><span class="params">(String str1)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.str1 = str1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> str1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        PartInnerClass innerClass = <span class="keyword">new</span> PartInnerClass(<span class="string">"局部内部类"</span>);</span><br><span class="line">        System.out.println(innerClass.test());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 局部内部类出了作用域就无法使用了！！！</span></span><br><span class="line">        <span class="comment">//new PartInnerClass("sss");</span></span><br><span class="line">        memberFunction();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出结果：</span></span><br><span class="line"><span class="comment">         * 局部内部类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><ul><li><p>一般使用匿名内部类的方法来编写事件监听代码；</p></li><li><p>匿名内部类不能定义静态成员、方法和类；</p></li><li><p><strong>匿名内部类是不能有访问修饰符和static修饰符的；</strong></p></li><li><p><strong>匿名内部类是唯一一种没有构造器的类；</strong></p></li><li><p>匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p></li></ul><blockquote><p><strong>因为匿名内部类为局部内部类，所以局部内部类的所有限制都对其生效。</strong></p></blockquote><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ul><li><strong>继承一个类，重写其方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = <span class="string">"匿名内部类通过继承实现"</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.run();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出结果：</span></span><br><span class="line"><span class="comment">         * 匿名内部类通过继承实现</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>实现一个接口（可以是多个），实现其方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = <span class="string">"匿名内部类通过接口实现"</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        runnable.run();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 匿名内部类通过接口实现</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h1><ul><li><p>静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似；</p></li><li><p>不能使用外部类的非static成员变量或者方法。</p></li></ul><blockquote><p>静态内部类如果去掉关键字static就变成了成员内部类，成员内部类是非静态内部类它可以自由的引用外部类的属性和方法，无论这些属性和方法是静态的还是非静态的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String testStr = <span class="string">"琦玉"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterClass</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员内部类（普通内部类）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String str;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以定义静态的参数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String str1 = <span class="string">"静态内部类的静态参数"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.str = str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试内部类中和外部类出现同名方法</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 只能访问外部类的静态成员变量，或者方法</span></span><br><span class="line">            System.out.println(testStr); <span class="comment">// 琦玉</span></span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 静态内部类不依赖外部类，直接声明就可以</span></span><br><span class="line">        InnerClass innerClass = <span class="keyword">new</span> InnerClass(<span class="string">"静态内部类"</span>);</span><br><span class="line">        System.out.println(innerClass.test()); <span class="comment">// 打印 静态内部类</span></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出结果：</span></span><br><span class="line"><span class="comment">         * 琦玉</span></span><br><span class="line"><span class="comment">         * 静态内部类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><blockquote><p>这些内部类根本不用记，从名字上就可以知道意思；</p><p><strong>成员内部类：</strong>这个就想成类的成员变量，成员变量能被各种访问符修饰，这个自然可以，成员变量依赖类的实例化，这个也依赖于外部类啊。</p><p><strong>静态内部类：</strong>了解了成员内部类，加一个static修饰就是静态内部类了啊，就相当于普通的成员变量，加一个static修饰不就变成，类变量了，类变量，类方法不依赖类的实例变量，只能调用类中静态方法和静态变量，那么这个静态内部类也不就一样，就不依赖于外部类，直接new，只能用外部类的静态方法和静态变量。</p><p><strong>局部内部类：</strong>局部内部类这个更加见名知意了，局部的，在一个方法中，或者代码块中，仅仅在这个中生效，就想象成方法中定义的一个<strong>局部变量</strong>，怎么可能用修饰符修饰。</p><p><strong>匿名内部类：</strong>这个也见名知意，就是没有名字的内部类，为什么没有名字，肯定是new xxx() {} 重写方法或者实现接口中的方法，这个用的比较多应该熟悉。</p></blockquote><ul><li>成员内部类===》类的成员变量</li><li>静态内部类===》类的类变量</li><li>局部内部类===》方法的局部变量</li><li>匿名内部类===》。。。。</li></ul><hr><blockquote><p>实际上我感觉对普通的程序员来说这些内部类就偶尔用一用匿名内部类吧，看那jdk源码中发现用了很多成员内部类，和静态内部类。我反正没怎么用过，比较low，<strong>我对内部类的理解仅此而已，仅仅是知道些特性，到底该怎么用，何时去用还差一点感觉。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式</title>
      <link href="/2020/06/30/java/javase/11/"/>
      <url>/2020/06/30/java/javase/11/</url>
      
        <content type="html"><![CDATA[<h2 id="Stream-流"><a href="#Stream-流" class="headerlink" title="Stream 流"></a>Stream 流</h2><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"学生id"</span>)</span><br><span class="line">    <span class="keyword">public</span> Integer id;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"学生姓名"</span>)</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"学生年龄"</span>)</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"学生生日"</span>)</span><br><span class="line">    <span class="keyword">public</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line"><span class="comment">// 模拟数据</span></span><br><span class="line">ArrayList&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">students.add(<span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"张三"</span>, <span class="number">20</span>, dateFormat.parse(<span class="string">"2020-10-01"</span>)));</span><br><span class="line">students.add(<span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">"萧炎"</span>, <span class="number">22</span>, dateFormat.parse(<span class="string">"2020-10-02"</span>)));</span><br><span class="line">students.add(<span class="keyword">new</span> Student(<span class="number">3</span>, <span class="string">"唐三"</span>, <span class="number">18</span>, dateFormat.parse(<span class="string">"2020-09-10"</span>)));</span><br><span class="line">students.add(<span class="keyword">new</span> Student(<span class="number">4</span>, <span class="string">"牧尘"</span>, <span class="number">20</span>, dateFormat.parse(<span class="string">"2020-05-20"</span>)));</span><br><span class="line">students.add(<span class="keyword">new</span> Student(<span class="number">5</span>, <span class="string">"林动"</span>, <span class="number">16</span>, dateFormat.parse(<span class="string">"2020-08-09"</span>)));</span><br></pre></td></tr></table></figure><h3 id="Stream对象的创建"><a href="#Stream对象的创建" class="headerlink" title="Stream对象的创建"></a>Stream对象的创建</h3><p>Stream对象分为两种，一种串行的流对象，一种并行的流对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// permissionList指所有权限列表</span></span><br><span class="line"><span class="comment">// 为集合创建串行流对象</span></span><br><span class="line">Stream&lt;Student&gt; stream = students.stream();</span><br><span class="line"><span class="comment">// 为集合创建并行流对象</span></span><br><span class="line">Stream&lt;Student&gt; parallelStream = students.parallelStream();</span><br></pre></td></tr></table></figure><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>Stream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random(); </span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>对Stream中的元素进行过滤操作，当设置条件返回true时返回相应元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取权限类型为目录的权限</span></span><br><span class="line">List&lt;UmsPermission&gt; dirList = permissionList.stream()</span><br><span class="line">    .filter(permission -&gt; permission.getType() == <span class="number">0</span>)</span><br><span class="line">    .collect(Collectors.toList());Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>对Stream中的元素进行转换处理后获取。比如可以将UmsPermission对象转换成Long对象。 我们经常会有这样的需求：需要把某些对象的id提取出来，然后根据这些id去查询其他对象，这时可以使用此方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有权限的id组成的集合</span></span><br><span class="line">List&lt;Long&gt; idList = permissionList.stream()</span><br><span class="line">    .map(permission -&gt; permission.getId())</span><br><span class="line">    .collect(Collectors.toList());Copy to clipboardErrorCopied</span><br><span class="line">    </span><br><span class="line">List&lt;String&gt; collect = joinCircles.stream().filter(joinCircle -&gt; joinCircle.getUserSignin() &lt; <span class="number">10</span>).distinct()</span><br><span class="line">                .map(JoinCircle::getUserId).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>从Stream中获取指定数量的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取前5个权限对象组成的集合</span></span><br><span class="line">List&lt;UmsPermission&gt; firstFiveList = permissionList.stream()</span><br><span class="line">    .limit(<span class="number">5</span>)</span><br><span class="line">    .collect(Collectors.toList());Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>仅获取Stream中元素的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// count操作：获取所有目录权限的个数</span></span><br><span class="line"><span class="keyword">long</span> dirPermissionCount = permissionList.stream()</span><br><span class="line">    .filter(permission -&gt; permission.getType() == <span class="number">0</span>)</span><br><span class="line">    .count();Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>对Stream中元素按指定规则进行排序。</p><h4 id="对单个属性排序："><a href="#对单个属性排序：" class="headerlink" title="对单个属性排序："></a>对单个属性排序：</h4><hr><ol><li>根据年龄<strong>升序排序</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">students.stream()</span><br><span class="line">    .sorted(Comparator.comparing(Student::getAge))</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><ol start="2"><li>根据年龄<strong>降序排序（先升序，后逆序）</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">students.stream()</span><br><span class="line">  .sorted(Comparator.comparing(Student::getAge).reversed())</span><br><span class="line">  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p><strong>这个是先根据年龄升序排序，然后利用reversed()逆序；</strong></p><ol start="3"><li>根据年龄<strong>降序排序（直接逆序）</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">students.stream()</span><br><span class="line"> .sorted(Comparator.comparing(Student::getAge,Comparator.reverseOrder()))</span><br><span class="line"> .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p><strong>利用Comparator.reverseOrder()直接就是降序排序</strong></p><hr><h4 id="对多个属性排序"><a href="#对多个属性排序" class="headerlink" title="对多个属性排序"></a>对多个属性排序</h4><ol><li>根据年龄<strong>降序</strong>，生日<strong>升序</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">students.stream()</span><br><span class="line"> .sorted(Comparator.comparing(Student::getAge).reversed()</span><br><span class="line"> .thenComparing(Student::getBirthday))</span><br><span class="line"> .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">students.stream()</span><br><span class="line"> .sorted(Comparator.comparing(Student::getAge,Comparator.reverseOrder())</span><br><span class="line"> .thenComparing(Student::getBirthday))</span><br><span class="line"> .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><blockquote><p>第一种是先按照年龄升序，然后逆序，第二种则是直接按照年龄降序</p></blockquote><ol start="2"><li>根据年龄<strong>降序</strong>，生日<strong>降序</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">students.stream()</span><br><span class="line"> .sorted(Comparator.comparing(Student::getAge)</span><br><span class="line"> .thenComparing(Student::getBirthday).reversed())</span><br><span class="line"> .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><blockquote><p>这里要明白为什么只是用了一次reversed()年龄为什么也逆序了，reversed()的作用域是reversed()前面的所有的排序，也就是作用域为年龄和生日，如果想按照<strong>年龄升序，生日降序：</strong>则在年龄后面在加上一个reversed()<strong>逆序两次也就是升序了</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">students.stream()</span><br><span class="line"> .sorted(Comparator.comparing(Student::getAge,Comparator.reverseOrder())</span><br><span class="line"> .thenComparing(Student::getBirthday,Comparator.reverseOrder()))</span><br><span class="line"> .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><hr><p><strong>Comparator自定义比较器：</strong></p><blockquote><p>int compare(Object o1, Object o2);</p><p>1、比较者大于被比较者，那么返回正整数<br>2、比较者等于被比较者，那么返回0<br>3、比较者小于被比较者，那么返回负整数</p></blockquote><p>定义一个类实现Comparator接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Student</span>&gt; </span>&#123;   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里可以自己定义复杂的排序算法</span></span><br><span class="line">        <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用该排序器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">students.stream().sorted(<span class="keyword">new</span> StudentComparator()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>自定义比较复杂的排序算法，利用stream流排序（可以去详细了解stream流）分页获取数据例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">students.stream().sorted(newStudentComparator()).skip(<span class="number">5</span>).limit(<span class="number">10</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>逆序存在两种写法：</p><ul><li>Comparator.comparing(Student::getAge).reversed()</li><li>Comparator.comparing(Student::getAge,Comparator.reverseOrder())</li></ul><blockquote><ol><li>第一种写法会逆序之前的全部排序规则，如果思路不清晰容易出错，如果要排序的全部字段都按照降序，推荐使用这个，直接在最后添加reversed()就好。</li><li>但是如果比较比较复杂，使用Comparator.reverseOrder()比较稳妥一些。</li></ol></blockquote><h3 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h3><p>跳过指定个数的Stream中元素，获取后面的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳过前5个元素，返回后面的</span></span><br><span class="line">List&lt;UmsPermission&gt; skipList = permissionList.stream()</span><br><span class="line">    .skip(<span class="number">5</span>)</span><br><span class="line">    .collect(Collectors.toList());Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p>剔除重复的元素</p><h3 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h3><h4 id="Collectors-toList"><a href="#Collectors-toList" class="headerlink" title="Collectors.toList()"></a>Collectors.toList()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; studentList = </span><br><span class="line">students.stream().filter(student -&gt; student.getAge() &gt; <span class="number">20</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><blockquote><p>[Student(id=2, name=萧炎, age=22, birthday=Fri Oct 02 00:00:00 CST 2020)]</p></blockquote><h4 id="Collectors-joining"><a href="#Collectors-joining" class="headerlink" title="Collectors.joining()"></a>Collectors.joining()</h4><ul><li>Collectors.joining()</li><li>Collectors.joining(delimiter)</li><li>Collectors.joining(delimiter,prefix,suffix)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String studentStr1 = students.stream().map(Student::getName).collect(Collectors.joining());</span><br><span class="line">String studentStr2 = students.stream().map(Student::getName).collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">String studentStr3 = students.stream().map(Student::getName).collect(Collectors.joining(<span class="string">","</span>, <span class="string">"武动乾坤-&gt;"</span>, <span class="string">"&lt;-斗破苍穹"</span>));</span><br></pre></td></tr></table></figure><blockquote><p>张三萧炎唐三牧尘林动<br>张三,萧炎,唐三,牧尘,林动<br>武动乾坤-&gt;张三,萧炎,唐三,牧尘,林动&lt;-斗破苍穹</p></blockquote><h4 id="Collectors-toSet"><a href="#Collectors-toSet" class="headerlink" title="Collectors.toSet()"></a>Collectors.toSet()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; ageSet = students.stream().map(Student::getAge).collect(Collectors.toSet());</span><br></pre></td></tr></table></figure><blockquote><p>[16, 18, 20, 22]</p></blockquote><h4 id="Collectors-toMap-Collectors-toConcurrentMap"><a href="#Collectors-toMap-Collectors-toConcurrentMap" class="headerlink" title="Collectors.toMap()/Collectors.toConcurrentMap()"></a>Collectors.toMap()/Collectors.toConcurrentMap()</h4><ul><li>Collectors.toMap(p1,p2);</li><li>Collectors.toMap(p1,p2,p3);</li><li>Collectors.toMap(p1,p2,p3,p4);</li></ul><blockquote><p>p1： 要转换为的map的键</p><p>p2：要转换为的map的值，如果要转换为本对象则可设置为Function.identity()</p><p>p3：用于解决键的冲突，（o1,o2）-&gt; o1 如果冲突选择前面的那个值，<strong>如果不设置冲突会造成异常</strong></p><p>p4：设置要转换为的Map类型，如果不设置就为Map/ConcurrentMap  </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Student&gt; studentMap = students.stream().collect(Collectors.toMap(Student::getId, Function.identity()));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Student&gt; outStudentMap = students.stream().collect(Collectors.toMap(Student::getId, Function.identity(), (o1, o2) -&gt; o2));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;Integer, Student&gt; studentConcurrentHashMap = students.stream().collect(Collectors.toMap(Student::getId, Function.identity(), (o1, o2) -&gt; o2, ConcurrentHashMap::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure><blockquote><p>略，可以尝试键相同的情况下，不设置param3所产生异常！</p><p>Collectors.toConcurrentMap()的所有都和Collectors.toMap()相同！！除了返回的Map类型</p></blockquote><h4 id="Collectors-groupingBy-Collectors-groupingByConcurrent"><a href="#Collectors-groupingBy-Collectors-groupingByConcurrent" class="headerlink" title="Collectors.groupingBy()/Collectors.groupingByConcurrent()"></a>Collectors.groupingBy()/Collectors.groupingByConcurrent()</h4><ul><li>Collectors.groupingBy(p1)</li><li>Collectors.groupingBy(p1,p2)</li><li>Collectors.groupingBy(p1,p2,p3)</li></ul><blockquote><p>p1：按照什么来进行分组</p><p>p2：分组完成后用什么容器装载数据 <strong>默认Map</strong></p><p>p3：分类后，对应的分类结果用什么容器装载 <strong>默认List</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, List&lt;Student&gt;&gt; groupStudentByGrade = students.stream().collect(Collectors.groupingBy(Student::getGrade,ConcurrentHashMap::<span class="keyword">new</span>, Collectors.toList()));</span><br><span class="line"></span><br><span class="line">Map&lt;String, Long&gt; groupCountingByGrade = students.stream().collect(Collectors.groupingBy(Student::getGrade, Collectors.counting()));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; groupStudentByGradeAndAge = students.stream().collect(Collectors.groupingBy(student -&gt; student.getGrade() + <span class="string">","</span> + student.getAge()));</span><br></pre></td></tr></table></figure><blockquote><p>{高三=[Student(id=5, name=林动, age=16, birthday=Sun Aug 09 00:00:00 CST 2020, grade=高三)], </p><p>高二=[Student(id=2, name=萧炎, age=22, birthday=Fri Oct 02 00:00:00 CST 2020, grade=高二),     Student(id=4, name=牧尘, age=20, birthday=Wed May 20 00:00:00 CST 2020, grade=高二)], </p><p>高一=[Student(id=1, name=张三, age=20, birthday=Thu Oct 01 00:00:00 CST 2020, grade=高一),             Student(id=3, name=唐三, age=18, birthday=Thu Sep 10 00:00:00 CST 2020, grade=高一)]}</p></blockquote><blockquote><p>{高三=1, 高二=2, 高一=2}</p></blockquote><blockquote><p>结果三：略 根据年级和年龄分类无意义，只是为了展示多个条件分组</p></blockquote><p><strong>这个分组远远不止这点东西，其他的可以自行了解这个</strong></p><h4 id="Collectors-partitioningBy"><a href="#Collectors-partitioningBy" class="headerlink" title="Collectors.partitioningBy"></a>Collectors.partitioningBy</h4><p><strong>分割列表 一个为false 一个为true</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Student&gt;&gt; partitioningStudent = students.stream().collect(Collectors.partitioningBy(student -&gt; student.getAge() &gt; <span class="number">20</span>));</span><br></pre></td></tr></table></figure><blockquote><p>{false=[Student(id=1, name=张三, age=20, birthday=Thu Oct 01 00:00:00 CST 2020, grade=高一), Student(id=3, name=唐三, age=18, birthday=Thu Sep 10 00:00:00 CST 2020, grade=高一), Student(id=4, name=牧尘, age=20, birthday=Wed May 20 00:00:00 CST 2020, grade=高二), Student(id=5, name=林动, age=16, birthday=Sun Aug 09 00:00:00 CST 2020, grade=高三)], </p><p>true=[Student(id=2, name=萧炎, age=22, birthday=Fri Oct 02 00:00:00 CST 2020, grade=高二)]}</p></blockquote><h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>另外，一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; agesList =                                              students.stream().map(Student::getAge).collect(Collectors.toList());</span><br><span class="line">IntSummaryStatistics intSummaryStatistics = </span><br><span class="line">    agesList.stream().mapToInt(x -&gt; x).summaryStatistics();</span><br><span class="line">System.out.println(<span class="string">"获取最大的年龄："</span> + intSummaryStatistics.getMax());</span><br><span class="line">System.out.println(<span class="string">"获取最小的年龄："</span> + intSummaryStatistics.getMin());</span><br><span class="line">System.out.println(<span class="string">"所有年龄之和："</span> + intSummaryStatistics.getSum());</span><br><span class="line">System.out.println(<span class="string">"获取年龄的平均是："</span> + intSummaryStatistics.getAverage());</span><br><span class="line">System.out.println(<span class="string">"获取年龄个数："</span> + intSummaryStatistics.getCount());</span><br></pre></td></tr></table></figure><p><strong>stream 不仅仅是这些，这只是基本的使用</strong></p><hr><p><strong>全部代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        <span class="comment">// 模拟数据</span></span><br><span class="line">        ArrayList&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        students.add(<span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"张三"</span>, <span class="number">20</span>, dateFormat.parse(<span class="string">"2020-10-01"</span>), <span class="string">"高一"</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">"萧炎"</span>, <span class="number">22</span>, dateFormat.parse(<span class="string">"2020-10-02"</span>), <span class="string">"高二"</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> Student(<span class="number">3</span>, <span class="string">"唐三"</span>, <span class="number">18</span>, dateFormat.parse(<span class="string">"2020-09-10"</span>), <span class="string">"高一"</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> Student(<span class="number">4</span>, <span class="string">"牧尘"</span>, <span class="number">20</span>, dateFormat.parse(<span class="string">"2020-05-20"</span>), <span class="string">"高二"</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> Student(<span class="number">5</span>, <span class="string">"林动"</span>, <span class="number">16</span>, dateFormat.parse(<span class="string">"2020-08-09"</span>), <span class="string">"高三"</span>));</span><br><span class="line">        <span class="comment">// Collectors.toList()</span></span><br><span class="line">        List&lt;Student&gt; studentList = students.stream().filter(student -&gt; student.getAge() &gt; <span class="number">20</span>).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// Collectors.joining()</span></span><br><span class="line">        String studentStr1 = students.stream().map(Student::getName).collect(Collectors.joining());</span><br><span class="line">        String studentStr2 = students.stream().map(Student::getName).collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">        String studentStr3 = students.stream().map(Student::getName).collect(Collectors.joining(<span class="string">","</span>, <span class="string">"武动乾坤-&gt;"</span>, <span class="string">"&lt;-斗破苍穹"</span>));</span><br><span class="line">        Set&lt;Integer&gt; ageSet = students.stream().map(Student::getAge).collect(Collectors.toSet());</span><br><span class="line">        <span class="comment">// Collectors.toMap()/Collectors.toConcurrentMap()</span></span><br><span class="line">        Map&lt;Integer, Student&gt; studentMap = students.stream().collect(Collectors.toMap(Student::getId, Function.identity()));</span><br><span class="line">        Map&lt;Integer, Student&gt; outStudentMap = students.stream().collect(Collectors.toMap(Student::getId, Function.identity(), (o1, o2) -&gt; o2));</span><br><span class="line">        ConcurrentHashMap&lt;Integer, Student&gt; studentConcurrentHashMap = students.stream().collect(Collectors.toMap(Student::getId, Function.identity(), (o1, o2) -&gt; o2, ConcurrentHashMap::<span class="keyword">new</span>));</span><br><span class="line">        <span class="comment">//Collectors.groupingBy()/Collectors.groupingByConcurrent()</span></span><br><span class="line">        ConcurrentHashMap&lt;String, List&lt;Student&gt;&gt; groupStudentByGrade = students.stream().collect(Collectors.groupingBy(Student::getGrade, ConcurrentHashMap::<span class="keyword">new</span>, Collectors.toList()));</span><br><span class="line">        Map&lt;String, List&lt;Student&gt;&gt; groupStudentByGradeAndAge = students.stream().collect(Collectors.groupingBy(student -&gt; student.getGrade() + <span class="string">","</span> + student.getAge()));</span><br><span class="line">        Map&lt;String, Long&gt; groupCountingByGrade = students.stream().collect(Collectors.groupingBy(Student::getGrade, Collectors.counting()));</span><br><span class="line">        <span class="comment">//Collectors.partitioningBy() 分割列表 一个为false 一个为true</span></span><br><span class="line">        Map&lt;Boolean, List&lt;Student&gt;&gt; partitioningStudent = students.stream().collect(Collectors.partitioningBy(student -&gt; student.getAge() &gt; <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Collectors.toList()--&gt;"</span> + studentList);</span><br><span class="line">        System.out.println(<span class="string">"Collectors.joining()--&gt;"</span> + studentStr1);</span><br><span class="line">        System.out.println(<span class="string">"Collectors.joining(delimiter)--&gt;"</span> + studentStr2);</span><br><span class="line">        System.out.println(<span class="string">"Collectors.joining(delimiter,prefix,suffix)--&gt;"</span> + studentStr3);</span><br><span class="line">        System.out.println(<span class="string">"Collectors.toSet()--&gt;"</span> + ageSet.toString());</span><br><span class="line">         <span class="comment">//这里为了程序正常执行，并没有创建相同的id</span></span><br><span class="line">        System.out.println(<span class="string">"Collectors.toMap(p1, p2)--&gt;"</span> + studentMap.toString());</span><br><span class="line">        System.out.println(<span class="string">"Collectors.toMap(p1, p2, p3)--&gt;"</span> + outStudentMap.toString());</span><br><span class="line">        System.out.println(<span class="string">"Collectors.toMap(p1, p2, p3, p4)"</span> + studentConcurrentHashMap.toString());</span><br><span class="line">        System.out.println(<span class="string">"Collectors.groupingBy()单条件分组--&gt;"</span> + groupStudentByGrade);</span><br><span class="line">        System.out.println(<span class="string">"Collectors.groupingBy()多条件分组--&gt;"</span> + groupStudentByGradeAndAge);</span><br><span class="line">        System.out.println(<span class="string">"Collectors.groupingBy()计数--&gt;"</span> + groupCountingByGrade);</span><br><span class="line">        System.out.println(<span class="string">"Collectors.partitioningBy()"</span> + partitioningStudent);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类VS接口</title>
      <link href="/2020/06/29/java/javase/17/"/>
      <url>/2020/06/29/java/javase/17/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是抽象类和接口？"><a href="#什么是抽象类和接口？" class="headerlink" title="什么是抽象类和接口？"></a>什么是抽象类和接口？</h1><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><strong>abstract修饰的类。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">int</span> 方法名(参数列表); <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>抽象的方法没有方法体。需要注意的是在抽象类中既可以有抽象方法，也可以有普通方法。</li></ul><blockquote><p><strong>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</strong></p></blockquote><ul><li><p>抽象类不能被实例化，如果被实例化，编译就无法通过。</p></li><li><p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p></li><li><p><strong>构造方法和类方法不能声明为抽象方法。</strong></p></li><li><p>抽象方法必须用public、或者protected修饰（不能使用private，子类无法重写，无意义）默认缺省为 public。</p></li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><strong>interface关键字声明接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名 </span>&#123;</span><br><span class="line">    返回值 方法名(参数列表); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><ul><li>接口中每一个方法都是隐式抽象的，<strong>接口中的方法会被隐式的指定为public abstract并且只能是。</strong></li></ul><ul><li>接口中可以含有成员变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法（java8存在变化）。</li></ul><h3 id="java8之后接口的变化"><a href="#java8之后接口的变化" class="headerlink" title="java8之后接口的变化"></a>java8之后接口的变化</h3><p>在JDK1.8之前的版本（不包括JDK1.8），接口中不能有静态方法，抽象类中因为有普通方法，故也可以有静态方法。</p><p>在JDK1.8后（包括JDK1.8），在抽象类中依旧可以有静态方法，同时在接口中也可以定义静态方法了。</p><p>以下代码在JDK1.8之后是没有问题的（可以通过接口名来调用静态方法  ：Main.prinf(); ）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JDK1.7，接口中只包含抽象方法，使用public abstract  修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在JDK1.8，接口中新加了默认方法和静态方法：</strong></p><p>​        <strong>默认方法：</strong>使用default修饰，在接口的实现类中，可以直接调用该方法，也可以重写该方法。</p><p>​        <strong>静态方法：</strong>使用static修饰，通过接口直接调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;    </span><br><span class="line">    <span class="comment">//默认方法    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">"default method..."</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//静态方法    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">"static method..."</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在JDK1.9，接口中新加了私有方法，使用private修饰，私有方法供接口内的默认方法和静态方法调用。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口与抽象类区别？"><a href="#接口与抽象类区别？" class="headerlink" title="接口与抽象类区别？"></a>接口与抽象类区别？</h1><ul><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li><li>抽象类只能单继承，接口可以多继承。</li><li>抽象类中可以有普通成员变量，接口中没有普通成员变量。 </li><li>抽象类可以有构造方法，接口不能有构造方法。</li><li>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，<strong>但接口中定义的变量只是public static final 类型，并且默认即为 public static final 类型。</strong></li><li>….</li></ul><blockquote><p>接口和抽象类之间的区别真的要硬说真的还有很多，从各个方面，抽象类是is-a关系，接口是has-a关系；还有他们的使用场景也不同，等等。。这个了解就好。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题集（第二周）</title>
      <link href="/2020/06/29/java/question/2/"/>
      <url>/2020/06/29/java/question/2/</url>
      
        <content type="html"><![CDATA[<h1 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p><strong>尝试编译以下程序会产生怎么样的结果？（）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">var</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">long</span> param)</span> </span>&#123; <span class="keyword">var</span> = param; &#125;<span class="comment">//(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClass a, b;</span><br><span class="line">        a =<span class="keyword">new</span> MyClass();<span class="comment">//(2)</span></span><br><span class="line">        b =<span class="keyword">new</span> MyClass(<span class="number">5</span>);<span class="comment">//(3)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>编译错误将发生在（1），因为构造函数不能指定返回值</li><li><strong>B：</strong>编译错误将发生在（2），因为该类没有默认构造函数</li><li><strong>C：</strong>编译错误将在（3）处发生，因为该类没有构造函数，该构造函数接受一个int类型的参数</li><li><strong>D：</strong>该程序将正确编译和执行</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p>这道题一定要看仔细了，<strong>MyClass方法并不是构造参数</strong>，而是返回类型为void的普通方法，普通方法自然需要实例化对象然后去调用它，所以124不对，第三个是正确的，因为没有带参数的构造器，所以自然不能传一个int进去。</p></blockquote><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>从内存实现或者反射的角度来看，关于继承的说法正确的是（）。</p><p><strong>注：此处的继承不代表能调用</strong></p><ul><li><strong>A：</strong>子类将继承父类的所有的数据域和方法</li><li><strong>B：</strong>子类将继承父类的其可见的数据域和方法</li><li><strong>C：</strong>子类只继承父类public方法和数据域</li><li><strong>D：</strong>子类只继承父类的方法，而不继承数据域</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>子类可以继承父类的全部数据域和方法，但是这里继承代表的是“拥有”，即：只是拥有父类的全部数据域和方法，但不具备对某些私有数据域或私有方法的使用权（调用）。</p><p><strong>这道题明确标注：此处的继承不代表能调用。</strong></p></blockquote><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p><strong>java语言的下面几种数组复制方法中，哪个效率最高？</strong></p><ul><li><strong>A：</strong>for 循环逐一复制</li><li><strong>B：</strong>System.arraycopy</li><li><strong>C：</strong>Array.copyOf</li><li><strong>D：</strong>使用clone方法</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p> 复制的效率<strong>System.arraycopy&gt;clone&gt;Arrays.copyOf&gt;for循环</strong></p><p>这里面在System类源码中给出了arraycopy的方法，是native方法，也就是本地方法，肯定是最快的。而Arrays.copyOf(注意是Arrays类，不是Array实现的，在源码中是调用System.copyOf的，多了一个步骤，肯定就不是最快的。</p></blockquote><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p><strong>下列代码的输出结果是_</strong></p><ul><li><strong>A：</strong>true</li><li><strong>B：</strong>false</li><li><strong>C：</strong>null</li><li><strong>D：</strong>空字符串</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>==  优先级高于 三目运算符，先判断   true == true，此时返回为  true,</p><p>这时表达式为   boolean b = true?false:true?false:true</p><p>此时三目运算符从右向左执行,true?false:true，返回false</p><p>这时表达式为  boolean b = true?false:false;</p><p>结果为：boolean b = false ;</p></blockquote><h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p><strong>（多选）Which statement declares a variable a which is suitable for referring to an array of 50 string objects?（Java）</strong></p><ul><li><strong>A：</strong>char a[][];</li><li><strong>B：</strong>String a[];</li><li><strong>C：</strong>String[] a;</li><li><strong>D：</strong>Object a[50];</li><li><strong>E：</strong>String a[50];</li><li><strong>F：</strong>Object a[];</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BCF</span></span><p><strong>解析：</strong></p><p><strong>在java 中，声明一个数组时，不能直接限定数组长度，只有在创建实例化对象时，才能对给定数组长度。</strong></p><p>如下，1、2、3可以通过编译，4、5不行。而String是Object的子类，所以上述BCF均可定义一个存放50个String类型对象的数组。</p><ol><li><p>String a[]=new String[50];</p></li><li><p>String b[];</p></li><li><p>char c[];</p></li><li><p>String d[50];</p></li><li><p>char e[50];</p></li></ol></blockquote><h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><p><strong>运行代码，输出的结果是（）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> abc = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"P is init"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">S</span> <span class="keyword">extends</span> <span class="title">P</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"S is init"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(S.abc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>P is init<br />123</li><li><strong>B：</strong>S is init<br />P is init<br />123</li><li><strong>C：</strong>P is init<br />S is init<br />123</li><li><strong>D：</strong>S is init<br />123</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p><strong>被动引用不会出发子类初始化</strong> </p><p> 1.子类引用父类的静态字段，只会触发子类的加载、父类的初始化，不会导致子类初始化 </p><p> 2.通过数组定义来引用类，不会触发此类的初始化 </p><p> 3.常量在编译阶段会进行常量优化，将常量存入调用类的常量池中， 本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 </p></blockquote><h4 id="7"><a href="#7" class="headerlink" title="7"></a>7</h4><p><strong>下列哪个选项是Java调试器？如果编译器返回程序代码的错误，可以用它对程序进行调试。</strong></p><ul><li><strong>A：</strong>java.exe</li><li><strong>B：</strong>javadoc.exe</li><li><strong>C：</strong>jdb.exe</li><li><strong>D：</strong>javaprof.exe</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p>javac.exe是编译.java文件</p><p>java.exe是执行编译好的.class文件</p><p>javadoc.exe是生成Java说明文档</p><p>jdb.exe是Java调试器</p><p>javaprof.exe是剖析工具</p></blockquote><p><strong>class A {}</strong><br><strong>class B extends A {}</strong><br><strong>class C extends A {}</strong><br><strong>class D extends B {}</strong><br><strong>（多选）Which four statements are true ?</strong></p><ul><li><strong>A：</strong>The type List<A>is assignable to List.</li><li><strong>B：</strong>The type List<B>is assignable to List<A>.</li><li><strong>C：</strong>The type List<Object>is assignable to List&lt;?&gt;.</li><li><strong>D：</strong>The type List<D>is assignable to List&lt;?extends B&gt;.</li><li><strong>E：</strong>The type List&lt;?extends A&gt;is assignable to List<A>.</li><li><strong>F：</strong>The type List<Object>is assignable to any List reference.</li><li><strong>G：</strong>The type List&lt;?extends B&gt;is assignable to List&lt;?extends A&gt;.</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ACDG</span></span><p><strong>解析：</strong></p><p><strong>1.  只看尖括号里边的！！明确点和范围两个概念</strong></p><p><strong>2. 如果尖括号里的是一个类，那么尖括号里的就是一个点，比如List<A>,List<B>,List<Object></strong></p><p><strong>3. 如果尖括号里面带有问号，那么代表一个范围，<? extends A> 代表小于等于A的范围，<? super A>代表大于等于A的范围，<?>代表全部范围</strong></p><p><strong>4. 尖括号里的所有点之间互相赋值都是错，除非是俩相同的点</strong></p><p><strong>5. 尖括号小范围赋值给大范围，对，大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值，否则，不能赋值</strong></p><p><strong>6. List&lt;?&gt;和List 是相等的，都代表最大范围</strong></p><p><strong>7. List既是点也是范围，当表示范围时，表示最大范围</strong></p><hr><p>A：√ List就是List&lt;?&gt;代表最大的范围，A只是其中的一个点，肯定包含在内。</p><p>B：× 点与点之间不能相互赋值</p><p>C：√ List&lt;?&gt;表示最大的范围，List<Object>只是一个点，肯定被包含在内</p><p>D：√ List&lt;? extends B&gt;代表小于等于B的范围，List<D>是一个点，在其中。</p><p>E：× 点不能赋值给点</p><p>F：× List<Object>是一个点</p><p>G：√ 小于等于A的范围包含小于等于B的范围</p></blockquote><h4 id="8"><a href="#8" class="headerlink" title="8"></a>8</h4><p><strong>（多选）如下哪些是 java 中有效的关键字（）</strong></p><ul><li><strong>A：</strong>native</li><li><strong>B：</strong>NULL</li><li><strong>C：</strong>false</li><li><strong>D：</strong>this</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AD</span></span><p><strong>解析：</strong></p><p>true、false、null都不是关键字</p><p>goto、const、是保留的关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span>                <span class="keyword">continue</span>           <span class="keyword">for</span>            <span class="keyword">new</span>       </span><br><span class="line"><span class="keyword">switch</span>                  <span class="keyword">default</span>            <span class="keyword">if</span>             <span class="keyword">package</span>   </span><br><span class="line"><span class="keyword">synchronized</span>            <span class="keyword">do</span>                 goto           <span class="keyword">private</span>   </span><br><span class="line"><span class="keyword">this</span>                    <span class="keyword">break</span>              <span class="keyword">double</span>         implements </span><br><span class="line"><span class="keyword">protected</span>               <span class="keyword">throw</span>              <span class="keyword">byte</span>           <span class="keyword">else</span>       </span><br><span class="line"><span class="keyword">import</span>                  <span class="keyword">public</span>             <span class="keyword">throws</span>         <span class="keyword">case</span>       </span><br><span class="line"><span class="keyword">enum</span>                    <span class="keyword">instanceof</span>         <span class="keyword">return</span>         <span class="keyword">transient</span> </span><br><span class="line"><span class="keyword">catch</span>                   extends            <span class="keyword">int</span>            <span class="keyword">short</span>     </span><br><span class="line"><span class="keyword">try</span>                     <span class="keyword">char</span>               <span class="keyword">final</span>          <span class="class"><span class="keyword">interface</span> </span></span><br><span class="line"><span class="class"><span class="title">static</span>                  <span class="title">void</span>               <span class="title">class</span>          <span class="title">finally</span>   </span></span><br><span class="line"><span class="class"><span class="title">long</span>                    <span class="title">strictfp</span>           <span class="title">volatile</span>       <span class="title">const</span>    </span></span><br><span class="line"><span class="class"><span class="title">float</span>                   <span class="title">native</span>             <span class="title">super</span>          <span class="title">while</span></span></span><br><span class="line"><span class="class"><span class="title">boolean</span>                 <span class="title">assert</span> </span></span><br></pre></td></tr></table></figure></blockquote><h4 id="9"><a href="#9" class="headerlink" title="9"></a>9</h4><p><strong>What results from the following code fragment?</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">System.out.println(i + ~j);</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>Compilation error because”~”doesn’t operate on integers</li><li><strong>B：</strong>-5</li><li><strong>C：</strong>-6</li><li><strong>D：</strong>15</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p><strong>公式-n= ~ n+1可推出 ~ n=-n-1，所以~10=-11再加5结果为-6</strong></p><p>计算机本身储存的就是补码：</p><p>那么10的补码就是10的原码：0000 0000 0000 1010——这是补码，因为现在是计算机在计算</p><p>~10的补码就是：1111 1111 1111 0101</p><p>~10的反码就是：1111 1111 1111 0100——补码减1</p><p>~10的原码就是：1000 0000 0000 1011——反码取反：这个才是正常二进制数，换算为整数为-11</p><p>原码才可以对应为正常的整数，补码只有转换为原码才能被正常人类识别。</p></blockquote><h4 id="10"><a href="#10" class="headerlink" title="10"></a>10</h4><p><strong>抽象类方法的访问权限默认都是public。（  ）</strong></p><ul><li><strong>A：</strong>正确</li><li><strong>B：</strong>错误</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p><strong>关于抽象类</strong></p><p>JDK 1.8以前，抽象类的方法默认访问权限为protected</p><p>JDK 1.8时，抽象类的方法默认访问权限变为default</p><p><strong>关于接口</strong></p><p>JDK 1.8以前，接口中的方法必须是public的</p><p>JDK 1.8时，接口中的方法可以是public的，也可以是default的</p><p>JDK 1.9时，接口中的方法可以是private的</p></blockquote><h4 id="11"><a href="#11" class="headerlink" title="11"></a>11</h4><p><strong>（多选）Java创建对象的说法正确的有（）</strong></p><ul><li><strong>A：</strong>用new语句创建对象，是最常见的创建对象的方法。</li><li><strong>B：</strong>运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。</li><li><strong>C：</strong>调用对象的clone()方法。</li><li><strong>D：</strong>运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ABCD</span></span><p><strong>解析：</strong></p><p>Java有5种方式来创建对象：</p><ol><li>使用 new 关键字（最常用）： ObjectName obj = new ObjectName();</li><li>使用反射的Class类的newInstance()方法： ObjectName obj = ObjectName.class.newInstance(); </li><li>使用反射的Constructor类的newInstance()方法： ObjectName obj = ObjectName.class.getConstructor.newInstance();</li><li>使用对象克隆clone()方法： ObjectName obj = obj.clone(); </li><li>使用反序列化（ObjectInputStream）的readObject()方法： try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FILE_NAME))) { ObjectName obj = ois.readObject(); }</li></ol></blockquote><h4 id="12"><a href="#12" class="headerlink" title="12"></a>12</h4><p><strong>（多选）关于Java中的数组，下面的一些描述，哪些描述是准确的：（  ）</strong></p><ul><li><strong>A：</strong>数组是一个对象，不同类型的数组具有不同的类</li><li><strong>B：</strong>数组长度是可以动态调整的</li><li><strong>C：</strong>数组是一个连续的存储结构</li><li><strong>D：</strong>一个固定长度的数组可类似这样定义: int array[100]</li><li><strong>E：</strong>两个数组用equals方法比较时，会逐个便利其中的元素，对每个元素进行比较</li><li><strong>F：</strong>可以二维数组，且可以有多维数组，都是在Java中合法的</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ACF</span></span><p><strong>解析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] i = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] j = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] k = i;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">double</span>[] array_1 = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">100</span>];</span><br><span class="line">        System.out.println(array);</span><br><span class="line">        System.out.println(array_1);</span><br><span class="line">        System.out.println(i.equals(j));</span><br><span class="line">        System.out.println(i.equals(k));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[I@<span class="number">6</span>d6f6e28</span><br><span class="line">[D@<span class="number">135f</span>baa4</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>A 数组是对象，因为可以调用方法，从上面的输出结果可以看出不同类型的数组具有不同的类</p><p>B 数组长度是不能动态调整的</p><p>C Java中的数组中的数据是连续存储在一块内存中的，所以可以通过下标(即偏移量)的方式访问</p><p>D 固定长度的数组定义如上</p><p>E 查看源码可以知道数组的equals方法是object的equals，比较的是内存地址，Arrays.equal()可以比较数组元素。</p><p>F java可以有多维数组</p></blockquote><h4 id="13"><a href="#13" class="headerlink" title="13"></a>13</h4><p><strong>以下JAVA程序的运行结果是什么(  )</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Object o1 = <span class="keyword">true</span> ? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">Object o2;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">             o2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">o2 = <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(o1);</span><br><span class="line">System.out.print(<span class="string">" "</span>);         </span><br><span class="line">System.out.print(o2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>1 1</li><li><strong>B：</strong>1.0 1.0</li><li><strong>C：</strong>1 1.0</li><li><strong>D：</strong>1.0 1</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p>三元操作符类型的转换规则：</p><ol><li><p>若两个操作数不可转换，则不做转换，返回值为Object类型</p></li><li><p>若两个操作数是明确类型的表达式（比如变量），则按照正常的二进制数字来转换，int类型转换为long类型，long类型转换为float类型等。</p></li><li><p>若两个操作数中有一个是数字S,另外一个是表达式，且其类型标示为T，那么，若数字S在T的范围内，则转换为T类型；若S超出了T类型的范围，则T转换为S类型。</p></li><li><p>若两个操作数都是直接量数字，则返回值类型为范围较大者</p></li></ol></blockquote><h4 id="14"><a href="#14" class="headerlink" title="14"></a>14</h4><p><strong>以下关于Object类的说法正确的是（）</strong></p><ul><li><strong>A：</strong>Java中所有的类都直接或间接继承自Object，无论是否明确的指明，无论其是否是抽象类。</li><li><strong>B：</strong>Java中的接口(interface)也继承了Object类</li><li><strong>C：</strong>利用“==”比较两个对象时，Java调用继承自Object的equals方法，判断是否相等。</li><li><strong>D：</strong>如果类的定义中没有重新定义toString()方法，则该类创建的对象无法使用toStrig()方法。</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p><strong>A：</strong>Object 是基类 Java中的所有的类都直接或间接的继承；所以A对<br><strong>B：</strong>从一个class派生的必然是另一个class。Object是一个class，如果interface继承自Object，那么interface必然是一个class，所以B错<br><strong>C：</strong>利用equals()方法进行比较时 会调用== 可以看equals()方法的源码，可以这样说， == 比equal更加强大，所以C错<br><strong>D：</strong>toString()方法是Object类中 即使不重写也能使用 所以D错</p></blockquote><h4 id="15"><a href="#15" class="headerlink" title="15"></a>15</h4><p><strong>（多选）Java类Demo中存在方法func0、func1、func2、func3和func4，请问该方法中，哪些是不合法的定义？( )</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">float</span> <span class="title">func0</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　　<span class="keyword">byte</span> i=<span class="number">1</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">float</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　　<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">　　　　<span class="keyword">return</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">float</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　　<span class="keyword">short</span> i=<span class="number">2</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">float</span> <span class="title">func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　　<span class="keyword">long</span> i=<span class="number">3</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">float</span> <span class="title">func4</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　　<span class="keyword">double</span> i=<span class="number">4</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>func1</li><li><strong>B：</strong>func2</li><li><strong>C：</strong>func3</li><li><strong>D：</strong>func4</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AD</span></span><p><strong>解析：</strong></p><p>数据类型的转换，分为自动转换和强制转换。自动转换是程序在执行过程中 “ 悄然 ” 进行的转换，不需要用户提前声明，一般是从位数低的类型向位数高的类型转换；强制类型转换则必须在代码中声明，转换顺序不受限制。</p><p><strong>自动数据类型转换</strong></p><p>自动转换按从低到高的顺序转换。不同类型数据间的优先关系如下：<br>低 ———————————————&gt; 高<br>byte,short,char-&gt; int -&gt; long -&gt; float -&gt; double</p><p>运算中，不同类型的数据先转化为同一类型，然后进行运算，转换规则如下：</p><table><thead><tr><th><strong>操作数 1</strong> <strong>类型</strong></th><th><strong>操作数 2</strong> <strong>类型</strong></th><th><strong>转换后的类型</strong></th></tr></thead><tbody><tr><td>byte 、 short 、 char</td><td>int</td><td>int</td></tr><tr><td>byte 、 short 、 char 、 int</td><td>long</td><td>long</td></tr><tr><td>byte 、 short 、 char 、 int 、 long</td><td>float</td><td>float</td></tr><tr><td>byte 、 short 、 char 、 int 、 long 、 float</td><td>double</td><td>double</td></tr></tbody></table><p><strong>强制数据类型转换</strong></p><p>强制转换的格式是在需要转型的数据前加上 “( )” ，然后在括号内加入需要转化的数据类型。有的数据经过转型运算后，精度会丢失，而有的会更加精确</p></blockquote><h4 id="16"><a href="#16" class="headerlink" title="16"></a>16</h4><p><strong>Consider the following code:</strong></p><p><strong>String s=null;</strong></p><p><strong>Which code fragments cause an object of type NullPointerException to be thrown?</strong></p><ul><li><strong>A：</strong>if((s!=null)&amp;(s.length()&gt;0))</li><li><strong>B：</strong>if((s!=null)&amp;&amp;(s.length()&gt;0))</li><li><strong>C：</strong>if((s == null)|(s.length()==0))</li><li><strong>D：</strong>if((s == null)||(s.length()==0))</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AC</span></span><p><strong>解析：</strong></p><p>s为null，因此只要调用了s.length()都会抛出空指针异常。因此这个题目就是考察if语句的后半部分会不会执行。<br>A：单个与操作的符号&amp; 用在整数上是按位与，用在布尔型变量上跟&amp;&amp;功能类似，但是区别是无论前面是否为真，后面必定执行，因此抛出异常<br>B：与操作，前半部分判断为假，后面不再执行<br>C：这里跟 &amp; 和&amp;&amp; 的区别类似，后面必定执行，因此抛出异常<br>D：或语句，前面为真，整个结果必定为真，后面不执行</p></blockquote><h4 id="17"><a href="#17" class="headerlink" title="17"></a>17</h4><p><strong>（重要）下面代码的输出是什么？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String baseName = <span class="string">"base"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        callName();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System. out. println(baseName);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String baseName = <span class="string">"sub"</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System. out. println (baseName) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Base b = <span class="keyword">new</span> Sub();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>null</li><li><strong>B：</strong>sub</li><li><strong>C：</strong>base</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>1.首先，需要明白<strong>类的加载顺序</strong>。</p><p>(1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)</p><p>(2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )</p><p>(3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )</p><p>(4) 父类构造函数</p><p>(5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )</p><p>(6) 子类构造函数</p><p>其中：类中静态块按照声明顺序执行，并且(1)和(2)不需要调用new类实例的时候就执行了(意思就是在类加载到方法区的时候执行的)</p><p>2.其次，需要理解子类覆盖父类方法的问题，也就是<strong>方法重写实现多态</strong>问题。</p><p>Base b = new Sub();<strong>它为多态的一种表现形式，声明是Base,实现是Sub类，</strong> <strong>理解为</strong> <strong>b</strong> <strong>编译时表现为Base类特性，运行时表现为Sub类特性（这个非常重要）。</strong></p><p>当子类覆盖了父类的方法后，意思是父类的方法已经被重写，<strong>题中</strong> <strong>父类初始化调用的方法为子类实现的方法，子类实现的方法中调用的baseName为子类中的私有属性。</strong></p><p>由1.可知，此时只执行到步骤4.,子类非静态代码块和初始化步骤还没有到，子类中的baseName还没有被初始化。所以此时 baseName为空。 所以为null。</p></blockquote><h4 id="19"><a href="#19" class="headerlink" title="19"></a>19</h4><p><strong>设有下面两个赋值语句：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = Integer.parseInt(<span class="string">"1024"</span>);</span><br><span class="line">b = Integer.valueOf(<span class="string">"1024"</span>).intValue();</span><br></pre></td></tr></table></figure><p><strong>下述说法正确的是（）</strong></p><ul><li><strong>A：</strong>a是整数类型变量，b是整数类对象。</li><li><strong>B：</strong>a是整数类对象，b是整数类型变量。</li><li><strong>C：</strong>a和b都是整数类对象并且它们的值相等。</li><li><strong>D：</strong>a和b都是整数类型变量并且它们的值相等。</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p>intValue()是把Integer对象类型变成int的基础数据类型；<br>parseInt()是把String 变成int的基础数据类型；<br>Valueof()是把String 转化成Integer对象类型；（现在JDK版本支持自动装箱拆箱了。）<br>本题：parseInt得到的是基础数据类型int，valueof得到的是装箱数据类型Integer，然后再通过intValue转换成int，所以选择D</p></blockquote><h4 id="20"><a href="#20" class="headerlink" title="20"></a>20</h4><p><strong>A 是抽象父类或接口， B ， C 派生自 A ，或实现 A ，现在 Java 源代码中有如下声明：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. A  a0 = <span class="keyword">new</span>  A();</span><br><span class="line"><span class="number">2</span>. A  a1 = <span class="keyword">new</span>  B();</span><br><span class="line"><span class="number">3</span>. A  a2 = <span class="keyword">new</span>  C();</span><br></pre></td></tr></table></figure><p><strong>问以下哪个说法是正确的？（ ）</strong></p><ul><li><strong>A：</strong>第1行不能通过编译</li><li><strong>B：</strong>第1、2行能通过编译，但第3行编译出错</li><li><strong>C：</strong>第1、2、3行能通过编译，但第2、3行运行时出错</li><li><strong>D：</strong>第1行、第2行和第3行的声明都是正确的</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p><strong>抽象类和接口不能实例化了</strong>这个我竟然没注意。。。</p></blockquote><h4 id="21"><a href="#21" class="headerlink" title="21"></a>21</h4><p><strong>以下代码执行后输出结果为（ ）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Test t1 = <span class="keyword">new</span> Test();</span><br><span class="line">    &#123;</span><br><span class="line">         System.out.println(<span class="string">"blockA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"blockB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Test t2 = <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>blockAblockBblockA</li><li><strong>B：</strong>blockAblockAblockB</li><li><strong>C</strong>：blockBblockBblockA</li><li><strong>D</strong>：blockBblockAblockB</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>首先区别<clinit>是类初始化，<init>是实例初始化</p><p>类装载准备阶段-&gt;类初始化clinit阶段</p><p>类装载准备阶段：变量赋系统要求的初始值（0或者null等），final变量会在此时赋用户定义的初始值</p><p>类初始化<clinit>过程：</p><p>Step1 编译器收集t1的赋值动作，static语句块，main方法语句块</p><p>Step2 执行收集好的语句块：</p><p>Step2.1 执行t1 = new Test，发现clinit过程已经调用，于是可以开始触发init过程，执行成员变量的初始化（此处没有），以及非静态代码块，输出blockA，最后调用构造函数（此处没有）</p><p>Step2.2 按照顺序，执行static语句块，输出blockB</p><p>Step2.3 按照顺序，执行main方法语句块，执行t2 = new Test，触发init方法，执行非静态代码块,输出blockA</p><p><strong>其实这题很简单，第一你要搞懂，这程序是怎么走的，从上往下。第二你要知道静态块和构造块，静态块是程序走到静态快的位置就自动执行，仅且执行一次，构造块是创建类对象（实例化）操作时就加载一次。最后把题目从上往下执行，遵循第一和第二，就得到答案了。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String word=<span class="string">" "</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWord</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.word=word;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setI</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        Data0bject. i=I;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="22"><a href="#22" class="headerlink" title="22"></a>22</h4><p><strong>创建一个如下方式的DataObject:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataObject object=<span class="keyword">new</span> Data0bject ( );</span><br><span class="line">object. setWord(<span class="string">"123"</span>);</span><br><span class="line">object. setI(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>将此对象序列化为文件，并在另外一个JVM中读取文件，进行反序列化，请问此时读出的Data0bject对象中的word和i的值分别为：</strong></p><ul><li><strong>A：</strong>“”, 0</li><li><strong>B：</strong>“”, 2</li><li><strong>C：</strong>“123”, 2</li><li><strong>D：</strong>“123”, 0</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p><strong>Java在序列化时不会实例化static变量和transient修饰的变量，因为static代表类的成员，transient代表对象的临时数据，被声明这两种类型的数据成员不能被序列化。</strong></p></blockquote><h4 id="23"><a href="#23" class="headerlink" title="23"></a>23</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1=<span class="number">1</span>,b2=<span class="number">2</span>,b3,b6,b8;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span> b4=<span class="number">4</span>,b5=<span class="number">6</span>,b7;</span><br><span class="line">b3=(b1+b2);  <span class="comment">/*语句1*/</span></span><br><span class="line">b6=b4+b5;    <span class="comment">/*语句2*/</span></span><br><span class="line">b8=(b1+b4);  <span class="comment">/*语句3*/</span></span><br><span class="line">b7=(b2+b5);  <span class="comment">/*语句4*/</span></span><br><span class="line">System.out.println(b3+b6);</span><br></pre></td></tr></table></figure><p><strong>（多选）下列代码片段中，存在编译错误的语句是()</strong></p><ul><li><strong>A：</strong>语句2</li><li><strong>B：</strong>语句1</li><li><strong>C：</strong>语句3</li><li><strong>D：</strong>语句4</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BCD</span></span><p><strong>解析：</strong></p><p>Java表达式转型规则<strong>由低到高转换</strong>：</p><p>1、所有的byte,short,char型的值将被提升为int型；</p><p>2、如果有一个操作数是long型，计算结果是long型；</p><p>3、如果有一个操作数是float型，计算结果是float型；</p><p>4、如果有一个操作数是double型，计算结果是double型；</p><p>5、被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。</p><hr><p>语句1错误：b3=(b1+b2);自动转为int，所以正确写法为b3=(byte)(b1+b2);或者将b3定义为int；</p><p>语句2正确：b6=b4+b5;b4、b5为final类型，不会自动提升，所以和的类型视左边变量类型而定，即b6可以是任意数值类型；</p><p>语句3错误：b8=(b1+b4);虽然b4不会自动提升，但b1仍会自动提升，所以结果需要强转，b8=(byte)(b1+b4);</p><p>语句4错误：b7=(b2+b5); 同上。同时注意b7是<strong>final修饰，即只可赋值一次，便不可再改变</strong>。</p></blockquote><h4 id="24"><a href="#24" class="headerlink" title="24"></a>24</h4><p><strong>（多选）Java语言中，下面哪个语句是创建数组的正确语句？(     )</strong></p><ul><li><strong>A：</strong>float f[][] = new float<code>[6][6]</code>;</li><li><strong>B：</strong>float []f[] = new float<code>[6][6]</code>;</li><li><strong>C：</strong>float f[][] = new float<code>[][6]</code>;</li><li><strong>D：</strong>float [][]f = new float<code>[6][6]</code>;</li><li><strong>E：</strong>float [][]f = new float<code>[6][]</code>;</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ABD</span></span><p>解析：注意B选项就行，还有就是第一个框中必须有值！！</p></blockquote><h4 id="25"><a href="#25" class="headerlink" title="25"></a>25</h4><p><strong>（多选）以下类型为Final类型的为（）</strong></p><ul><li><strong>A：</strong>HashMap</li><li><strong>B：</strong>StringBuffer</li><li><strong>C：</strong>String</li><li><strong>D：</strong>Hashtable</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BC</span></span><p><strong>解析：</strong></p><p>StringBuilder , StringBuffer ,String 都是 final 的，但是为什么StringBuilder , StringBuffer可以进行修改呢，因为不可变包括的是，引用不可变以及对象不可变，而这三个都是属于引用不可变，（也就是地址不要变，里面的内容随心所欲），而StringBuilder , StringBuffer 中都包含右append方法，可对对象中的内容进行增加。</p><p>而String a=”123”+new String(“456”);实际上底层是用了一个StringBuffer 进行append；</p></blockquote><h4 id="26"><a href="#26" class="headerlink" title="26"></a>26</h4><p><strong>（多选）Java1.8版本之前的前提，Java特性中,abstract class和interface有什么区别（）</strong></p><ul><li><strong>A：</strong>抽象类可以有构造方法，接口中不能有构造方法</li><li><strong>B：</strong>抽象类中可以有普通成员变量，接口中没有普通成员变量</li><li><strong>C：</strong>抽象类中不可以包含静态方法，接口中可以包含静态方法</li><li><strong>D：</strong>一个类可以实现多个接口，但只能继承一个抽象类。</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ABD</span></span><p><strong>解析：</strong></p><p>A B D显然都是对的。主要说C选项：</p><p>在JDK1.8之前的版本（不包括JDK1.8），接口中不能有静态方法，抽象类中因为有普通方法，故也可以有静态方法。</p><p>在JDK1.8后（包括JDK1.8），在抽象类中依旧可以有静态方法，同时在接口中也可以定义静态方法了。</p><p>以下代码在JDK1.8之后是没有问题的（可以通过接口名来调用静态方法  ：Main.prinf(); ）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：</p><p>在JDK1.7，接口中只包含抽象方法，使用public abstract  修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;&#125;</span><br></pre></td></tr></table></figure><p><strong>在JDK1.8，接口中新加了默认方法和静态方法：</strong></p><p>​        默认方法：使用default修饰，在接口的实现类中，可以直接调用该方法，也可以重写该方法。</p><p>​        静态方法：使用static修饰，通过接口直接调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;    </span><br><span class="line">    <span class="comment">//默认方法    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">"default method..."</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//静态方法    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">"static method..."</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在JDK1.9，接口中新加了私有方法，使用private修饰，私有方法供接口内的默认方法和静态方法调用。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="27"><a href="#27" class="headerlink" title="27"></a>27</h4><p><strong>（）运算符把其操作数中所有值为0和所有值为1的位分别在结果的相应中设置1和0</strong></p><ul><li><strong>A：</strong>&amp;</li><li><strong>B：</strong>|</li><li><strong>C：</strong>！</li><li><strong>D：</strong>~</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p><del>是<a href="https://www.baidu.com/s?wd=位运算符&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">位运算符</a>，意义是 按位非（NOT）<br>按位非也叫做补，<a href="https://www.baidu.com/s?wd=一元运算符&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">一元运算符</a>NOT“</del>”是对其运算数的每一位取反。</p><ul><li>仅用于整数值</li><li>反转位，即0位变为1位，1变成0</li><li>在所有情况下〜x等于（-x）- 1</li></ul><p>例如</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="number">0111</span> (<span class="number">7</span>) <span class="built_in">=</span> <span class="number">1000</span> (<span class="number">8</span>)</span><br></pre></td></tr></table></figure></blockquote><h4 id="28"><a href="#28" class="headerlink" title="28"></a>28</h4><p><strong>Java 源程序文件的扩展名为（）</strong></p><ul><li><strong>A：</strong>.java</li><li><strong>B：</strong>.class</li><li><strong>C：</strong>.exe</li><li><strong>D：</strong>.jar</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>java中源文件的后缀为.java，经过javac.exe编译后生成字节码文件，后缀为.class，再经过java.exe编译为可执行文件，后缀为.exe。</p></blockquote><h4 id="29"><a href="#29" class="headerlink" title="29"></a>29</h4><p><strong>下列程序的运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCustomerInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// do something that may cause an Exception</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.FileNotFoundException ex) &#123;</span><br><span class="line">            System.out.print(<span class="string">"FileNotFoundException!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException ex) &#123;</span><br><span class="line">            System.out.print(<span class="string">"IOException!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.lang.Exception ex) &#123;</span><br><span class="line">            System.out.print(<span class="string">"Exception!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>IOException!</li><li><strong>B：</strong>IOException!Exception!</li><li><strong>C：</strong>FileNotFoundException!IOException!</li><li><strong>D：</strong>FileNotFoundException!IOException!Exception!</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><h4 id="try-catch-finally-规则"><a href="#try-catch-finally-规则" class="headerlink" title="try-catch-finally 规则"></a><strong>try-catch-finally 规则</strong></h4><p>1)  必须在 try 之后添加 catch 或 finally 块。try 块后可同时接 catch 和 finally 块，但至少有一个块。</p><p>2) 必须遵循块顺序：若代码同时使用 catch 和 finally 块，则必须将 catch 块放在 try 块之后。<br>3) catch 块与相应的异常类的类型相关。<br>4) 一个 try 块可能有多个 catch 块。若如此，则执行第一个匹配块。即Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或 其子类的实例，就执行这个catch代码块，不会再执行其他的 catch代码块<br>5) 可嵌套 try-catch-finally 结构。<br>6) 在 try-catch-finally 结构中，可重新抛出异常。<br>由此可以看出，<strong>catch只会匹配一个，因为只要匹配了一个，虚拟机就会使整个语句退出</strong></p></blockquote><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h4 id="30"><a href="#30" class="headerlink" title="30"></a>30</h4><p><strong>（多选）下面有关java threadlocal说法正确的有？</strong></p><ul><li><strong>A：</strong>ThreadLocal存放的值是线程封闭，线程间互斥的，主要用于线程内共享一些数据，避免通过参数来传递</li><li><strong>B：</strong>线程的角度看，每个线程都保持一个对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收</li><li><strong>C：</strong>在Thread类中有一个Map，用于存储每一个线程的变量的副本。</li><li><strong>D：</strong>对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ABCD</span></span><p><strong>解析：</strong></p><p><strong>ThreadLocal类用来提供线程内部的局部变量。</strong>这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。 可以总结为一句话：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 <strong>ThreadLocal设计的初衷：提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。</strong></p></blockquote><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h4 id="31"><a href="#31" class="headerlink" title="31"></a>31</h4><p><strong>（多选）下面的类哪些可以处理Unicode字符?</strong></p><ul><li><strong>A：</strong>InputStreamReader</li><li><strong>B：</strong>BufferedReader</li><li><strong>C：</strong>Writer</li><li><strong>D：</strong>PipedInputStream</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ABC</span></span><p><strong>解析：</strong></p><p>后缀是Stream的都是字节流，其他的都是字符流。</p></blockquote><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h4 id="32"><a href="#32" class="headerlink" title="32"></a>32</h4><p><strong>下面程序段的时间复杂度是（）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>( k &lt; n )&#123;</span><br><span class="line">   i ++ ;</span><br><span class="line">k += i ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>O(n)</li><li><strong>B：</strong>O(n^1/2)</li><li><strong>C：</strong>O(n*i)</li><li><strong>D：</strong>O(n+i)</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>设q为一共要执行的次数 </p><p>k=0+1; k=1+1</p><p>q ^ 2+q+1/4=2n+1/4</p><p>(q+1/2)=(2n+1/4) ^ 1/2</p><p>q=(2n+1/4)^1/2-1/2</p><p>所以 T(n)=O(n^1/2)</p></blockquote><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h4 id="33"><a href="#33" class="headerlink" title="33"></a>33</h4><p><strong>运用下列哪个命令能够获取JVM的内存映像</strong></p><ul><li><strong>A：</strong>jinfo</li><li><strong>B：</strong>jmap</li><li><strong>C：</strong>jhat</li><li><strong>D：</strong>jstat</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><ol><li><p>jps：查看本机java进程信息。</p></li><li><p>jstack：打印线程栈信息，制作线程dump文件。</p></li><li><p>jmap：打印内存映射，制作<strong>堆</strong>dump文件</p></li><li><p>jstat：性能监控工具。</p></li><li><p>jhat：内存分析工具</p></li><li><p>jconsole：简易的可视化控制台</p></li><li><p>jvisualvm：功能强大的控制台</p></li><li><p>jinfo<br>如何查看当前运行程序的配置<br>jps -l查看当前所有的进程及进程号<br>方式一：jinfo -flag 配置项 进程号<br>方式二：jinfo -flags 进程号（可查看所有配置项，包括系统默认的和人工自己配置的）</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 题集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 题集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2020/06/28/java/theme/design_mode/"/>
      <url>/2020/06/28/java/theme/design_mode/</url>
      
        <content type="html"><![CDATA[<h1 id="程序设计原则（06）"><a href="#程序设计原则（06）" class="headerlink" title="程序设计原则（06）"></a>程序设计原则（06）</h1><h3 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1.单一职责原则"></a>1.单一职责原则</h3><h3 id="2-里氏替换原则"><a href="#2-里氏替换原则" class="headerlink" title="2.里氏替换原则"></a>2.里氏替换原则</h3><h3 id="3-依赖倒置原则"><a href="#3-依赖倒置原则" class="headerlink" title="3.依赖倒置原则"></a>3.依赖倒置原则</h3><h3 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4.接口隔离原则"></a>4.接口隔离原则</h3><h3 id="5-迪米特法则"><a href="#5-迪米特法则" class="headerlink" title="5.迪米特法则"></a>5.迪米特法则</h3><h3 id="6-开闭原则"><a href="#6-开闭原则" class="headerlink" title="6.开闭原则"></a>6.开闭原则</h3><h1 id="创建型（05）"><a href="#创建型（05）" class="headerlink" title="创建型（05）"></a>创建型（05）</h1><h3 id="1-单例模式（√）"><a href="#1-单例模式（√）" class="headerlink" title="1.单例模式（√）"></a><a href="/2020/07/09/java/designMode/SingletonPattern">1.单例模式（√）</a></h3><h3 id="2-工厂-抽象工厂模式（√）"><a href="#2-工厂-抽象工厂模式（√）" class="headerlink" title="2.工厂/抽象工厂模式（√）"></a><a href="/2020/07/13/java/designMode/FactoryPattern">2.工厂/抽象工厂模式（√）</a></h3><h3 id="4-建造者模式（√）"><a href="#4-建造者模式（√）" class="headerlink" title="4.建造者模式（√）"></a><a href="/2020/07/27/java/designMode/BuilderPattern">4.建造者模式（√）</a></h3><hr><h3 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5.原型模式"></a>5.原型模式</h3><h1 id="结构型（07）"><a href="#结构型（07）" class="headerlink" title="结构型（07）"></a>结构型（07）</h1><h3 id="6-代理模式"><a href="#6-代理模式" class="headerlink" title="6.代理模式"></a>6.代理模式</h3><h3 id="7-桥接模式（√）"><a href="#7-桥接模式（√）" class="headerlink" title="7.桥接模式（√）"></a><a href="/2020/07/28/java/designMode/BridgePattern">7.桥接模式（√）</a></h3><h3 id="8-装饰者模式（√）"><a href="#8-装饰者模式（√）" class="headerlink" title="8.装饰者模式（√）"></a><a href="/2020/07/30/java/designMode/DecoratorPattern">8.装饰者模式（√）</a></h3><h3 id="9-适配器模式"><a href="#9-适配器模式" class="headerlink" title="9.适配器模式"></a>9.适配器模式</h3><hr><h3 id="10-门面模式"><a href="#10-门面模式" class="headerlink" title="10.门面模式"></a>10.门面模式</h3><h3 id="11-组合模式"><a href="#11-组合模式" class="headerlink" title="11.组合模式"></a>11.组合模式</h3><h3 id="12-享元模式"><a href="#12-享元模式" class="headerlink" title="12.享元模式"></a>12.享元模式</h3><h1 id="行为型-11"><a href="#行为型-11" class="headerlink" title="行为型(11)"></a>行为型(11)</h1><h3 id="13-观察者模式"><a href="#13-观察者模式" class="headerlink" title="13.观察者模式"></a>13.观察者模式</h3><h3 id="14-模板方法模式（√）"><a href="#14-模板方法模式（√）" class="headerlink" title="14.模板方法模式（√）"></a><a href="/2020/07/25/java/designMode/TemplateMethodPattern">14.模板方法模式（√）</a></h3><h3 id="15-策略模式"><a href="#15-策略模式" class="headerlink" title="15.策略模式"></a>15.策略模式</h3><h3 id="16-职责链模式"><a href="#16-职责链模式" class="headerlink" title="16.职责链模式"></a>16.职责链模式</h3><h3 id="17-迭代器模式"><a href="#17-迭代器模式" class="headerlink" title="17.迭代器模式"></a>17.迭代器模式</h3><h3 id="18-状态模式"><a href="#18-状态模式" class="headerlink" title="18.状态模式"></a>18.状态模式</h3><hr><h3 id="19-访问者模式"><a href="#19-访问者模式" class="headerlink" title="19.访问者模式"></a>19.访问者模式</h3><h3 id="20-备忘录模式"><a href="#20-备忘录模式" class="headerlink" title="20.备忘录模式"></a>20.备忘录模式</h3><h3 id="21-命令模式"><a href="#21-命令模式" class="headerlink" title="21.命令模式"></a>21.命令模式</h3><h3 id="22-解释器模式"><a href="#22-解释器模式" class="headerlink" title="22.解释器模式"></a>22.解释器模式</h3><h3 id="23-中介模式"><a href="#23-中介模式" class="headerlink" title="23.中介模式"></a>23.中介模式</h3>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归题集</title>
      <link href="/2020/06/26/java/arithmetic/4/"/>
      <url>/2020/06/26/java/arithmetic/4/</url>
      
        <content type="html"><![CDATA[<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">arithmetic70</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 爬楼梯</span></span><br><span class="line"><span class="comment">     * 题目：https://leetcode-cn.com/problems/climbing-stairs/</span></span><br><span class="line"><span class="comment">     * 题解：https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(climbStairs1(<span class="number">3</span>));</span><br><span class="line">        System.out.println(climbStairs2(<span class="number">3</span>));</span><br><span class="line">        System.out.println(climbStairs3(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            p = q;</span><br><span class="line">            q = r;</span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 傻递归超时</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> climbStairs2(n - <span class="number">1</span>) + climbStairs2(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾递归</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> climbStairs3Course(n, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs3Course</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将上一步的b 传给 a，a + b 传给 b</span></span><br><span class="line">        <span class="keyword">return</span> climbStairs3Course(n - <span class="number">1</span>, b, a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>方法2的递归太傻中间计算了太多的重复的值，递归千万不能这样用。</p><p>方法3中采用了尾递归的形式，相当于把上一步的结果缓存下来，可以重复使用。类似于方法一，这样的递归就很快速。</p></blockquote><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">arithmetic22</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 22. 括号生成</span></span><br><span class="line"><span class="comment">     * 题目：https://leetcode-cn.com/problems/generate-parentheses/</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(generateParenthesis1(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        recursion(n, n, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left   左括号数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right  右括号数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result 字符串结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, String result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左右括号为0，添加结果</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">            resultList.add(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左括号剩余可以添加左括号</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            recursion(left - <span class="number">1</span>, right, result + <span class="string">"("</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里限制右括号数量大于左括号的时候才能添加右括号，若不大于就添加必定不合法</span></span><br><span class="line">        <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">            recursion(left, right - <span class="number">1</span>, result + <span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. 翻转二叉树</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">arithmetic226</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 226. 翻转二叉树</span></span><br><span class="line"><span class="comment">     * 题目：https://leetcode-cn.com/problems/invert-binary-tree/description/</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右子树交换</span></span><br><span class="line">        TreeNode temp = root.right;</span><br><span class="line">        root.right = root.left;</span><br><span class="line">        root.left = temp;</span><br><span class="line">        <span class="comment">// 递归交换当前节点的左子树</span></span><br><span class="line">        invertTree1(root.left);</span><br><span class="line">        <span class="comment">// 递归交换当前节点的右子树</span></span><br><span class="line">        invertTree1(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h2><ol><li>利用二叉树中序遍历的特性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">double</span> min = -Double.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (root.val &lt;= min) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            min = root.val;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></h2><ol><li>递归实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         helper(root, res);</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">             helper(root.left, res);</span><br><span class="line">             res.add(root.val);</span><br><span class="line">             helper(root.right, res);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>栈</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 手动维护一个栈</span></span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        TreeNode treeNode = root;</span><br><span class="line">        <span class="keyword">while</span> (treeNode != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (treeNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(treeNode);</span><br><span class="line">                treeNode = treeNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            treeNode = stack.pop();</span><br><span class="line">            res.add(treeNode.val);</span><br><span class="line">            treeNode = treeNode.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></h2><ol><li>递归实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            helper(root.left, res);</span><br><span class="line">            helper(root.right, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>栈</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        TreeNode treeNode = root;</span><br><span class="line">        stack.push(treeNode);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            treeNode = stack.poll();</span><br><span class="line">            res.add(treeNode.val);</span><br><span class="line">            <span class="keyword">if</span> (treeNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(treeNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (treeNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(treeNode.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="590-N叉树的后序遍历"><a href="#590-N叉树的后序遍历" class="headerlink" title="590. N叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">590. N叉树的后序遍历</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Node cur : root.children) &#123;</span><br><span class="line">            res.addAll(postorder(cur));</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="589-N叉树的前序遍历"><a href="#589-N叉树的前序遍历" class="headerlink" title="589. N叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">589. N叉树的前序遍历</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.children != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">                res.addAll(preorder(child));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429. N叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">429. N叉树的层序遍历</a></h2><p>广度优先搜索</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Node node = queue.remove();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                queue.addAll(root.children);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>优化版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Node&gt; previousLayer = Collections.singletonList(root);</span><br><span class="line">        <span class="keyword">while</span> (!previousLayer.isEmpty()) &#123;</span><br><span class="line">            ArrayList&lt;Node&gt; currentLayer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            ArrayList&lt;Integer&gt; previousValues = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Node node : previousLayer) &#123;</span><br><span class="line">                previousValues.add(node.val);</span><br><span class="line">                currentLayer.addAll(node.children);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(previousValues);</span><br><span class="line">            previousLayer = currentLayer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>每次将新的层赋值给旧的层；</p></blockquote><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftHigh = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightHigh = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftHigh, rightHigh) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. 二叉树的最小深度</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftHigh = minDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightHigh = minDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> root.left == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ? leftHigh + rightHigh + <span class="number">1</span> : Math.min(leftHigh, rightHigh) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="297-二叉树的序列化与反序列化-×"><a href="#297-二叉树的序列化与反序列化-×" class="headerlink" title="297. 二叉树的序列化与反序列化(×)"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">297. 二叉树的序列化与反序列化</a>(×)</h2>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈题集</title>
      <link href="/2020/06/24/java/arithmetic/2/"/>
      <url>/2020/06/24/java/arithmetic/2/</url>
      
        <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 题目：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</span></span><br><span class="line"><span class="comment">     * 题解：</span></span><br><span class="line"><span class="comment">     * https://blog.csdn.net/Zolewit/article/details/88863970</span></span><br><span class="line"><span class="comment">     * https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/</span></span><br><span class="line"><span class="comment">     * https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(largestRectangleArea1(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>&#125;));</span><br><span class="line">        System.out.println(largestRectangleArea2(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法一</span></span><br><span class="line"><span class="comment">     * 固定中间一个找两边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heights</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea1</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heights.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最大面积</span></span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i;</span><br><span class="line">            <span class="keyword">int</span> currentHeight = heights[i];</span><br><span class="line">            <span class="comment">// left &gt; 0 防止为第一个数据；寻找左边最后一个大于currentHeight的下标</span></span><br><span class="line">            <span class="keyword">while</span> (left &gt; <span class="number">0</span> &amp;&amp; heights[left - <span class="number">1</span>] &gt;= currentHeight) &#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> right = i;</span><br><span class="line">            <span class="comment">// right &lt; heights.length - 1 防止为最后一个数据；寻找右边最后一个大于currentHeight的下标</span></span><br><span class="line">            <span class="keyword">while</span> (right &lt; heights.length - <span class="number">1</span> &amp;&amp; heights[right + <span class="number">1</span>] &gt;= currentHeight) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxArea = Math.max(maxArea, (right - left + <span class="number">1</span>) * currentHeight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法二</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heights</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea2</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] newHeights = <span class="keyword">new</span> <span class="keyword">int</span>[heights.length + <span class="number">2</span>];</span><br><span class="line">        System.arraycopy(heights, <span class="number">0</span>, newHeights, <span class="number">1</span>, heights.length);</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;(heights.length);</span><br><span class="line">        deque.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; newHeights.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (newHeights[i] &lt; newHeights[deque.getLast()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> height = newHeights[deque.pollLast()];</span><br><span class="line">                <span class="keyword">int</span> width = i - deque.peekLast() - <span class="number">1</span>;</span><br><span class="line">                maxArea = Math.max(maxArea, height * width);</span><br><span class="line">            &#125;</span><br><span class="line">            deque.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>这个题目的第二种解法真的太妙了，有亿点东西，我在idea中一步步调试才弄明白</strong></p><p><img src="https://image.cclblog.cn/blog/20200624221318.png" alt=""></p></blockquote><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. 滑动窗口最大值</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 题目：https://leetcode-cn.com/problems/sliding-window-maximum/</span></span><br><span class="line"><span class="comment">     * 题解：https://leetcode.com/problems/sliding-window-maximum/discuss/65884/Java-O(n)-solution-using-deque-with-explanation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Arrays.toString(maxSlidingWindow1(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, <span class="number">3</span>)));</span><br><span class="line">        System.out.println(Arrays.toString(maxSlidingWindow2(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, <span class="number">3</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法一：遍历每个滑动窗口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow1(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums.length - k + 1 : 滑动窗口个数</span></span><br><span class="line">        <span class="keyword">int</span>[] rnums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + k; j++) &#123;</span><br><span class="line">                max = Math.max(max, nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            rnums[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rnums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法二：双端队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span> - k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 每当新数进来时，如果发现队列头部的数的下标，是窗口最左边数的下标，则扔掉</span></span><br><span class="line">            <span class="keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.peekFirst() == i - k) &#123;</span><br><span class="line">                deque.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把队列尾部所有比新数小的都扔掉，保证队列是降序的</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加入新数</span></span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">            <span class="comment">// 队列头部就是该窗口内第一大的</span></span><br><span class="line">            <span class="keyword">if</span> ((i + <span class="number">1</span>) &gt;= k) &#123;</span><br><span class="line">                res[i + <span class="number">1</span> - k] = nums[deque.peek()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组题集</title>
      <link href="/2020/06/23/java/arithmetic/1/"/>
      <url>/2020/06/23/java/arithmetic/1/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：https://leetcode-cn.com/problems/container-with-most-water/</span></span><br><span class="line"><span class="comment"> * 题解：https://leetcode-cn.com/problems/container-with-most-water/solution/container-with-most-water-shuang-zhi-zhen-fa-yi-do/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] test = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    System.out.println(maxArea2(test));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴力解法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> height</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea1</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">            maxArea = Math.max(maxArea, Math.min(height[i], height[j]) * (j - i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双指针法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> height</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea2</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = height.length - <span class="number">1</span>, maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        maxArea = height[i] &gt; height[j] ?</span><br><span class="line">                Math.max(maxArea, (j - i) * height[j--]) :</span><br><span class="line">                Math.max(maxArea, (j - i) * height[i++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：https://leetcode-cn.com/problems/move-zeroes/</span></span><br><span class="line"><span class="comment"> * 题解：https://leetcode-cn.com/problems/move-zeroes/solution/dong-hua-yan-shi-283yi-dong-ling-by-wang_ni_ma/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] test = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    moveZeroes1(test);</span><br><span class="line">    moveZeroes2(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 纪录0出现的个数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历数组将非0元素前提</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            nums[count++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 count-nums.length 全部置为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = count; i &lt; nums.length; i++) &#123;</span><br><span class="line">        nums[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(nums));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快慢指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) &#123;</span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">                nums[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Syste.out.println(Arrays.toString(nums));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 题目：https://leetcode-cn.com/problems/climbing-stairs/</span></span><br><span class="line"><span class="comment">    * 题解：https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(climbStairs(<span class="number">3</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           p = q;</span><br><span class="line">           q = r;</span><br><span class="line">           r = p + q;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> r;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 题目：https://leetcode-cn.com/problems/two-sum/</span></span><br><span class="line"><span class="comment">    * 解析：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(Arrays.toString(twoSum1(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>&#125;, <span class="number">6</span>)));</span><br><span class="line">       System.out.println(Arrays.toString(twoSum2(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>&#125;, <span class="number">6</span>)));</span><br><span class="line">       System.out.println(Arrays.toString(twoSum3(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>&#125;, <span class="number">6</span>)));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 暴力求解</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum1(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="comment">// 双重for循环遍历，将所有的可能全部列举，一一与target比较</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 两遍哈希表</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       Map&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="comment">// 遍历数组将数组中的值-下标保存到hashMap中</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           hashMap.put(nums[i], i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 遍历数组，如果hashMap中存在target - nums[i] 这个值&amp;&amp;该值的下标不等于i（防止数组中正好target - nums[i]为其本身，例如6 - 3 = 3），</span></span><br><span class="line">       <span class="comment">// 那么就立即返回结果</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (hashMap.containsKey(target - nums[i]) &amp;&amp; hashMap.get(target - nums[i]) != i) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, hashMap.get(target - nums[i])&#125;;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 一遍哈希表</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum3(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       Map&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="comment">// 一边将元素保存到hashMap中，一边同时进行检查，如果找到符合的条件立即返回</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (hashMap.containsKey(target - nums[i]) &amp;&amp; hashMap.get(target - nums[i]) != i) &#123;</span><br><span class="line">               <span class="comment">// 之所以&#123;hashMap.get(target - nums[i]), i&#125;而不是&#123;i, hashMap.get(target - nums[i])&#125;</span></span><br><span class="line">               <span class="comment">// 是因为hashMap最后的那个元素，i永远比hashMap.get(target - nums[i])大</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;hashMap.get(target - nums[i]), i&#125;;</span><br><span class="line">           &#125;</span><br><span class="line">           hashMap.put(nums[i], i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：https://leetcode-cn.com/problems/3sum/</span></span><br><span class="line"><span class="comment"> * 题解：https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(threeSum(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>&#125;));</span><br><span class="line">    System.out.println(threeSum(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    ArrayList&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">// 数组长度小于三，无意义</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 最小的都大于0，肯定不存在结果 a + b + c = 0;</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i&gt;0 防止i=0的时候 i-1=-1；去重，前一个值等于后一个值已经计算过，不能重复计算</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// l 指向i的前一个位置</span></span><br><span class="line">        <span class="keyword">int</span> l = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// r 指向数组的最后一个位置</span></span><br><span class="line">        <span class="keyword">int</span> r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// l 指针不能大于r</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">// 计算这三个数的值</span></span><br><span class="line">            <span class="keyword">int</span> result = nums[i] + nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 等于0添加到列表中</span></span><br><span class="line">                list.add(Arrays.asList(nums[i], nums[l], nums[r]));</span><br><span class="line">                <span class="comment">// 去重，防止存在重复元素，导致结果重复</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>]) &#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 去重，同理上</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) &#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 左指针++</span></span><br><span class="line">                l++;</span><br><span class="line">                <span class="comment">// 右指针--</span></span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// a + b + c &gt; 0 说明这个 c太大 要减小 自然 r-- 指向c的前一个位置 （注意这是排过序的数组）</span></span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 同理上</span></span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>这个题目真的需要自己去思考，debug调试一下，我写的注释仅仅是我个人理解。</strong></p></blockquote><hr><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题集（第一周）</title>
      <link href="/2020/06/22/java/question/1/"/>
      <url>/2020/06/22/java/question/1/</url>
      
        <content type="html"><![CDATA[<h1 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h1><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p><strong>假如某个JAVA进程的JVM参数配置如下：</strong><br><strong>-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3,</strong><br><strong>请问eden区最终分配的大小是多少？</strong></p><ul><li><strong>A：</strong>64M</li><li><strong>B：</strong>500M</li><li><strong>C：</strong>300M</li><li><strong>D：</strong>100M</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p>-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3,</p><p>-Xms1G    设置Java堆最小值为1G    </p><p>-Xmx2G    设置Java堆最大值为2G</p><p>-Xmn500M    设置新生代大小为500M（一个Eden区，两个Survivor区）</p><p>-XX:MaxPermSize=64M    设置永久代大小为64M</p><p>-XX:+UseConcMarkSweepGC     设置使用CMS收集器</p><p>-XX:SurvivorRatio=3    设置Eden区与Survivor区大小的比例</p><p>本题看新生代大小，新生代为500M，三个区比例为3：1：1，很容易计算出Eden大小为300M</p></blockquote><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p><strong>对于JVM内存配置参数：</strong></p><blockquote><p><strong>-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3</strong></p></blockquote><p><strong>,其最小内存值和Survivor区总大小分别是（）</strong></p><ul><li><strong>A：</strong>5120m，1024m</li><li><strong>B：</strong>5120m，2048m</li><li><strong>C：</strong>10240m，1024m</li><li><strong>D：</strong>10240m，2048m</li></ul><blockquote><p><strong>解析：</strong></p><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p>-Xmx：最大堆大小</p><p>-Xms：初始堆大小</p><p>-Xmn:年轻代大小</p><p>-XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值</p><p>年轻代5120m， Eden：Survivor=3，Survivor区大小=1024m（Survivor区有两个，即将年轻代分为5份，每个Survivor区占一份），总大小为2048m。</p><p>-Xms初始堆大小即最小内存值为10240m</p></blockquote><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p><strong>（多选）关于OutOfMemoryError，下面说法正确的是（）？</strong></p><ul><li>java.lang.OutOfMemoryError: PermGen space 增加-XX:MaxPermSize这个参数的值的话，这个问题通常会得到解决。</li><li>java.lang.OutOfMemoryError: Requested array size exceeds VM limit当你正准备创建一个超过虚拟机允许的大小的数组时，这条错误将会出现</li><li>java.lang.OutOfMemoryError: Java heap space 一般情况下解决这个问题最快的方法就是通过-Xmx参数来增加堆的大小</li><li>java.lang.OutOfMemoryError: nativeGetNewTLA这个异常只有在jRockit虚拟机时才会碰到</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ABC</span></span><p><strong>解析：</strong></p><p>A：属于运行时常量池导致的溢出，设置-XX：MaxPermSize可以解决这个问题，</p><p>B：属于堆空间不足导致的错误，解决方式和C相同，</p><p>C：属于java堆内存问题，一般的手段是通过内存映像分析工具，对Dump出来的堆转储存快照进行分析，重点是确认内存中的对象是否是有必要的，也就是要判断是出现了内存泄漏，还是出现了内存溢出。如果是内存泄露，通过工具检查泄露对象打GC Roots的引用链信息，可以准确的确定出泄露代码的位置，不存在泄露，就应该检查虚拟机的堆参数，如果可以继续调大，可以设置-Xmx解决问题</p><p>D：java.lang.OutOfMemoryError: nativeGetNewTLA指当虚拟机不能分配新的线程本地空间(Thread Local Area）的时候错误信息，此错误是线程申请一个新的TLA时产生的，这个异常一般只会发生在jRockit虚拟机，只有过于绝对。</p></blockquote><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p><strong>下面有关java classloader说法错误的是（）?</strong></p><ul><li><strong>A：</strong> Java默认提供的三个ClassLoader是BootStrap ClassLoader，Extension ClassLoader，App ClassLoader、</li><li><strong>B：</strong>ClassLoader使用的是双亲委托模型来搜索类的</li><li><strong>C：</strong>VM在判定两个class是否相同时，只用判断类名相同即可，和类加载器无关</li><li><strong>D：</strong>ClassLoader就是用来动态加载class文件到内存当中用的</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p>比较两个类是否相等，只有这两个类是由同一个类加载器加载才有意义。否则，即使这两个类是来源于同一个Class文件，只要加载它们的类加载器不同，那么这两个类必定不相等。</p><p>补充：</p><p><strong>1.</strong> <strong>什么是类加载器？</strong></p><p>把类加载的过程放到Java虚拟机外部去实现，让应用程序决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。  </p><p><strong>2.</strong> <strong>有哪些类加载器，分别加载哪些类</strong></p><p>类加载器按照层次，从顶层到底层，分为以下三种：<br>(1)启动类加载器 : 它用来加载 Java 的核心库，比如String、System这些类<br>(2)扩展类加载器 : 它用来加载 Java 的扩展库。</p><p>(3) 应用程序类加载器 : 负责加载用户类路径上所指定的类库，一般来说，Java 应用的类都是由它来完成加载的。</p><p><strong>3.</strong> <strong>双亲委派模型</strong></p><p>我们应用程序都是由以上三种类加载器互相配合进行加载的，还可以加入自己定义的类加载器。称为 <strong>类加载器的双亲委派模型</strong> ，这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用 <strong>组合关系</strong> 来复用父加载器的。</p><p><strong>4.</strong> <strong>双亲委托模型的工作原理</strong></p><p>是当一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法加载这个加载请求的时候，子加载器才会尝试自己去加载。</p><p><strong>5.</strong> <strong>使用双亲委派模型好处？（原因）</strong></p><p>第一：可以避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载。</p><p>第二：考虑到安全因素，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时被加载，所以用户自定义类是无法加载一个自定义的类装载器。</p></blockquote><h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p><strong>（多选）关于Java中的ClassLoader下面的哪些描述是错误的：(   )</strong></p><ul><li><strong>A：</strong>默认情况下，Java应用启动过程涉及三个ClassLoader: Boostrap, Extension, System</li><li><strong>B：</strong>一般的情况不同ClassLoader装载的类是不相同的，但接口类例外，对于同一接口所有类装载器装载所获得的类是相同的</li><li><strong>C：</strong>类装载器需要保证类装载过程的线程安全</li><li><strong>D：</strong>ClassLoader的loadClass在装载一个类时，如果该类不存在它将返回null</li><li><strong>E：</strong>ClassLoader的父子结构中，默认装载采用了父优先</li><li><strong>F：</strong>所有ClassLoader装载的类都来自CLASSPATH环境指定的路径</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BDF</span></span><p><strong>解析：</strong></p><p><strong>A.Java系统提供3种类加载器：启动类加载器（Bootstrap ClassLoader）  扩展类加载器（Extension ClassLoader） 应用程序类加载器（Application ClassLoader）. A正确</strong></p><p><strong>B.《深入理解Java虚拟机》P228：对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类必定不相等。</strong>接口类是一种特殊类，因此对于同一接口不同的类装载器装载所获得的类是不相同的。<strong>B错误</strong></p><p><strong>C.类只需加载一次就行，因此要保证类加载过程线程安全，防止类加载多次。C正确</strong></p><p><strong>D.</strong> <strong>Java程序的类加载器采用双亲委派模型，实现双亲委派的代码集中在java.lang.ClassLoader的loadClass()方法中，此方法实现的大致逻辑是：先检查是否已经被加载，若没有加载则调用父类加载器的loadClass()方法，若父类加载器为空则默认使用启动类加载器作为父类加载器。如果父类加载失败，抛出ClassNotFoundException异常。D错误</strong></p><p><strong>E.双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。E正确</strong></p><p><strong>F.应用程序类加载器（Application ClassLoader）负责加载</strong>用户类路径（ClassPath）上所指定的类库，不是所有的ClassLoader都加载此路径。F错误</p></blockquote><h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><p><strong>以下代码执行的结果显示是多少（）？</strong></p><ul><li><strong>A：</strong>505000</li><li><strong>B：</strong>0</li><li><strong>C：</strong>运行时错误</li><li><strong>D：</strong>5050</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>count = count++  原理是 temp = count； count = count+1 ； count = temp；   因此count始终是0 这仅限于java 与c是不一样的</p><p>count=count++就是先把局部变量表中count的值0放入操作数栈中，然后直接对局部变量表中的count加1，然后再把操作数栈中的0出栈赋值给局部变量表中的count，最终局部变量表中的count值仍为0</p></blockquote><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h4 id="7"><a href="#7" class="headerlink" title="7"></a>7</h4><p><strong>在java中，下列对继承的说法，正确的是（ ）</strong></p><ul><li><strong>A：</strong>子类能继承父类的所有成员</li><li><strong>B：</strong>子类继承父类的非私有方法和状态</li><li><strong>C：</strong>子类只能继承父类的public方法和状态</li><li><strong>D：</strong>子类只能继承父类的方法</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>使用反射可以看出子类是继承了父类的私有方法的(不管是否是final)，只是直接调用父类的私有方法是不可以的，但是利用反射的方式可以调用。字段同理。</p><p><strong>其实private方法是可以继承的，只是不能调用</strong></p></blockquote><h4 id="8"><a href="#8" class="headerlink" title="8"></a>8</h4><p><strong>有如下一段程序：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        Test test=<span class="keyword">new</span> Test();</span><br><span class="line">        Test testObject=<span class="keyword">new</span> Test();</span><br><span class="line">        test.getNext();</span><br><span class="line">        testObject.getNext();</span><br><span class="line">        System.out.println(testObject.getNext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>请问最后打印出来的是什么？（）</strong></p><ul><li><strong>A：</strong>2</li><li><strong>B：</strong>3</li><li><strong>C：</strong>4</li><li><strong>D：</strong>5</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>return i++, 先返回i，然后i+1；</p><p>第一次调用getNext()方法时，返回的是1，但此时i=2；</p><p>第二次调用 getNext()方法时，返回的是2，但此时i=3；</p><p>第三次调用 getNext()方法时，返回的是3，但此时i=4；</p></blockquote><h4 id="9"><a href="#9" class="headerlink" title="9"></a>9</h4><p><strong>（多选）下面的switch语句中，x可以是哪些类型的数据：()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>long</li><li><strong>B：</strong>char</li><li><strong>C：</strong>float</li><li><strong>D：</strong>byte</li><li><strong>E：</strong>double</li><li><strong>F：</strong>Object</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BD</span></span><p><strong>解析：</strong></p><p>jdk1.7之前byte,short ,int ,char</p><p>jdk1.7之后加入String </p></blockquote><h4 id="10"><a href="#10" class="headerlink" title="10"></a>10</h4><p><strong>输出结果为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str =<span class="string">""</span>;</span><br><span class="line">System.out.print(str.split(<span class="string">","</span>).length);</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>0</li><li><strong>B：</strong>1</li><li><strong>C：</strong>出现异常</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>String split() 这个方法默认返回一个数组，如果没有找到分隔符，会把整个字符串当成一个长度为1的字符串数组，返回到结果， 所以此处结果就是1 。</p></blockquote><h4 id="11"><a href="#11" class="headerlink" title="11"></a>11</h4><p><strong>以下程序执行的结果是：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span>&#123;</span><br><span class="line">    Y y=<span class="keyword">new</span> Y();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">X</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"X"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Y</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Y"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Z</span> <span class="keyword">extends</span> <span class="title">X</span></span>&#123;</span><br><span class="line">    Y y=<span class="keyword">new</span> Y();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Z</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Z"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Z();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A：ZYXX</li><li>B：ZYXY</li><li>C：YXYZ</li><li>D：XYZX</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p><strong>java对象初始化顺序</strong><br>先说结论：</p><ol><li>父类静态代码块，父类静态成员变量（同级，按代码顺序执行）</li><li>子类静态代码块，子类静态成员变量（同级，按代码顺序执行）</li><li>父类普通代码块，父类普通成员变量（同级，按代码顺序执行）</li><li>父类构造方法</li><li>子类普通代码块，子类普通成员变量（同级，按代码顺序执行）</li><li>子类构造方法</li></ol><p>注意点：</p><ol><li>静态内容只在类加载时执行一次，之后不再执行。</li><li>默认调用父类的无参构造方法，可以在子类构造方法中利用super指定调用父类的哪个构造方法。</li></ol><hr><p><strong>（1）初始化父类的普通成员变量和代码块，执行  Y y=new</strong> <strong>Y();</strong>  <strong>输出Y</strong> </p><p><strong>（2）再执行父类的构造方法；输出X</strong></p><p><strong>（3）</strong> <strong>初始化子类的普通成员变量和代码块，执行  Y y=new</strong>   <strong>Y();</strong>  <strong>输出Y</strong> </p><p><strong>（4）再执行子类的构造方法；输出Z</strong></p></blockquote><h4 id="12"><a href="#12" class="headerlink" title="12"></a>12</h4><p><strong>设三个整型变量 x = 1 , y = 2 , z = 3，则表达式 y＋＝z－－/＋＋x 的值是( )。</strong></p><ul><li><strong>A：</strong>3</li><li><strong>B：</strong>3.5</li><li><strong>C：</strong>4</li><li><strong>D：</strong>5</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>y是2，返回的结果是2+（z–/++x），再来看z–/++x，结果应该是3/2，但是因为x,y,z都是int型的，所以最后的返回值只能是int，这时候z–/++x的值就是1，那么最终的结果就是2+1=3</p></blockquote><h4 id="13"><a href="#13" class="headerlink" title="13"></a>13</h4><p><strong>instanceof运算符能够用来判断一个对象是否为:</strong></p><ul><li><strong>A：</strong>一个类的实例</li><li><strong>B：</strong>一个实现指定接口的类的实例</li><li><strong>C：</strong>全部正确</li><li><strong>D：</strong>一个子类的实例</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p><strong>instance是java的二元运算符，用来判断他左边的对象是否为右面类（接口，抽象类，父类）的实例</strong></p></blockquote><h4 id="14"><a href="#14" class="headerlink" title="14"></a>14</h4><p><strong>以下代码将打印出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    String classFile = <span class="string">"com.jd."</span>. replaceAll(<span class="string">"."</span>, <span class="string">"/"</span>) + <span class="string">"MyClass.class"</span>;</span><br><span class="line">    System.out.println(classFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>com. jd</li><li><strong>B：</strong>com/jd/MyClass.class</li><li><strong>C：</strong>///////MyClass.class</li><li><strong>D：</strong>com.jd.MyClass</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p>由于replaceAll方法的第一个参数是一个正则表达式，而”.”在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成”/“。如果想替换的只是”.”，那么久要写成”\.”.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1=<span class="number">1</span>,b2=<span class="number">2</span>,b3,b6; </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span> b4=<span class="number">4</span>,b5=<span class="number">6</span>; </span><br><span class="line">b6=b4+b5; </span><br><span class="line">b3=(b1+b2); </span><br><span class="line">System.out.println(b3+b6);</span><br></pre></td></tr></table></figure><h4 id="15"><a href="#15" class="headerlink" title="15"></a>15</h4><p><strong>关于上面代码片段叙述正确的是（）</strong></p><ul><li><strong>A：</strong>输出结果：13</li><li><strong>B：</strong>语句：b6=b4+b5编译出错</li><li><strong>C：</strong>语句：b3=b1+b2编译出错</li><li><strong>D：</strong>运行期抛出异常</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p>被final修饰的变量是常量，这里的b6=b4+b5可以看成是b6=10；在编译时就已经变为b6=10了</p><p>而b1和b2是byte类型，java中进行计算时候将他们提升为int类型，再进行计算，b1+b2计算后已经是int类型，赋值给b3，b3是byte类型，类型不匹配，编译不会通过，需要进行强制转换。</p><p>Java中的byte，short，char进行计算时都会提升为int类型。</p></blockquote><h4 id="16"><a href="#16" class="headerlink" title="16"></a>16</h4><p><strong>下面有关java基本类型的默认值和取值范围，说法错误的是？</strong></p><ul><li><strong>A：</strong>字节型的类型默认值是0，取值范围是-2^7—2^7-1</li><li><strong>B：</strong>boolean类型默认值是false，取值范围是true\false</li><li><strong>C：</strong>字符型类型默认是0，取值范围是-2^15 —2^15-1</li><li><strong>D：</strong>long类型默认是0，取值范围是-2^63—2^63-1</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><table><thead><tr><th></th><th>More Actions  默认值</th><th>存储需求（字节）</th><th>取值范围</th><th>示例</th></tr></thead><tbody><tr><td>byte</td><td>0</td><td>1</td><td>-2^7—2^7-1</td><td>byte b=10;</td></tr><tr><td>char</td><td>‘ \u0000′</td><td>2</td><td>0—2^16-1</td><td>char c=’c’ ;</td></tr><tr><td>short</td><td>0</td><td>2</td><td>-2^15—2^15-1</td><td>short s=10;</td></tr><tr><td>int</td><td>0</td><td>4</td><td>-2^31—2^31-1</td><td>int i=10;</td></tr><tr><td>long</td><td>0</td><td>8</td><td>-2^63—2^63-1</td><td>long o=10L;</td></tr><tr><td>float</td><td>0.0f</td><td>4</td><td>-2^31—2^31-1</td><td>float f=10.0F</td></tr><tr><td>double</td><td>0.0d</td><td>8</td><td>-2^63—2^63-1</td><td>double d=10.0;</td></tr><tr><td>boolean</td><td>false</td><td>1</td><td>true\false</td><td>boolean flag=true;</td></tr></tbody></table></blockquote><h4 id="17"><a href="#17" class="headerlink" title="17"></a>17</h4><p><strong>java有8种基本类型，请问byte、int、long、char、float、double、boolean各占多少个字节？</strong></p><ul><li><strong>A：</strong>1 2 8 2 4 8 1</li><li><strong>B：</strong>1 4 8 2 4 8 1</li><li><strong>C：</strong>1 4 4 2 4 4 2</li><li><strong>D：</strong>1 4 4 2 4 8 2</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span></blockquote><h4 id="18"><a href="#18" class="headerlink" title="18"></a>18</h4><p><strong>对于abstract声明的类，下面说法正确的是</strong></p><ul><li><strong>A：</strong>可以实例化</li><li><strong>B：</strong>不可以被继承</li><li><strong>C：</strong>子类为abstract</li><li><strong>D：</strong>只能被继承</li><li><strong>E：</strong>可以被抽象类继承</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：E</span></span><p><strong>解析：</strong></p><p>A：抽象类不能实例化，因为有抽象方法未实现</p><p>B：可以被继承。派生类可以实现抽象方法</p><p>C：子类可以是抽象的，也可以非抽象的</p><p>D：只能被继承说法太肯定，不正确</p><p>E：可以被抽象类继承，也可以被非抽象类继承</p></blockquote><h4 id="19"><a href="#19" class="headerlink" title="19"></a>19</h4><p><strong>（多选）final、finally和finalize的区别中，下述说法正确的有？</strong></p><ul><li><strong>A：</strong>final用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。</li><li><strong>B：</strong>finally是异常处理语句结构的一部分，表示总是执行。</li><li><strong>C：</strong>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源的回收，例如关闭文件等。</li><li><strong>D：</strong>引用变量被final修饰之后，不能再指向其他对象，它指向的对象的内容也是不可变的。</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AB</span></span><p><strong>解析：</strong></p><p>A，D考的一个知识点，final修饰变量，变量的引用（也就是指向的地址）不可变，但是引用的内容可以变（地址中的内容可变）。</p><p>B，finally表示总是执行。但是其实finally也有不执行的时候，但是这个题不要扣字眼。</p><ol><li><p>在try中调用System.exit(0)，强制退出了程序，finally块不执行。</p></li><li><p>在进入try块前，出现了异常，finally块不执行。</p></li></ol><p>C，finalize方法，这个选项错就错在，<strong>这个方法一个对象只能执行一次，只能在第一次进入被回收的队列，而且对象所属于的类重写了finalize方法才会被执行。</strong>第二次进入回收队列的时候，不会再执行其finalize方法，而是直接被二次标记，在下一次GC的时候被GC。</p></blockquote><h4 id="20"><a href="#20" class="headerlink" title="20"></a>20</h4><p><strong>（多选）以下关于final关键字说法错误的是（）</strong></p><ul><li><strong>A：</strong>final是java中的修饰符，可以修饰类、接口、抽象类、方法和属性</li><li><strong>B：</strong>final修饰的类肯定不能被继承</li><li><strong>C：</strong>final修饰的方法不能被重载</li><li><strong>D：</strong>final修饰的变量不允许被再次赋值</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AC</span></span><p><strong>解析：</strong></p><p>1.final修饰变量，则等同于常量</p><p>2.final修饰方法中的参数，称为最终参数。</p><p>3.final修饰类，则类不能被继承</p><p>4.final修饰方法，则方法不能被重写。</p><p>5.final 不能修饰抽象类</p><p>6.final修饰的方法可以被重载 但不能被重写</p></blockquote><h4 id="21"><a href="#21" class="headerlink" title="21"></a>21</h4><p><strong>（多选）下面属于java包装类的是？</strong></p><ul><li><strong>A：</strong>String</li><li><strong>B：</strong>Long</li><li><strong>C：</strong>Character</li><li><strong>D：</strong>Short</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BCD</span></span><p><strong>解析：</strong></p><p>包装类是针对 <strong>基本数据类型</strong> 的。</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table></blockquote><h4 id="22"><a href="#22" class="headerlink" title="22"></a>22</h4><p><strong>（多选）在java中重写方法应遵循规则的包括（）</strong></p><ul><li><strong>A：</strong>访问修饰符的限制一定要大于被重写方法的访问修饰符</li><li><strong>B：</strong>可以有不同的访问修饰符</li><li><strong>C：</strong>参数列表必须完全与被重写的方法相同</li><li><strong>D：</strong>必须具有不同的参数列表</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BC</span></span><p><strong>解析：</strong></p><p>A：错在访问修饰符还可以相等。</p><p><strong>方法重写的规则：</strong></p><hr><ul><li>​    1）参数列表必须完全与被重写方法的相同；     </li><li>​    2）<strong>返回类型必须完全与被重写方法的返回类型相同；（备注:这条信息是标准的重写方法的规则,但是在java1.5 版本之前返回类型必须一样,1.5(包含) 版本之后java放宽了限制,返回类型必须小于或者等于父类方法的返回类型 才有了子类返回类型小于等于父类方法返回类型。</strong>。    </li><li>​       3）访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。     </li><li>​    4）父类的成员方法只能被它的子类重写。     </li><li>​    5）声明为final的方法不能被重写。     </li><li>​    6）声明为static的方法不能被重写，但是能够被再次声明。     </li><li>​    7）子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。     </li><li>​    8）子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。     </li><li>​       9）重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。     </li><li>​    10）构造方法不能被重写。     </li><li>​    11）如果不能继承一个方法，则不能重写这个方法。</li></ul></blockquote><h4 id="23"><a href="#23" class="headerlink" title="23"></a>23</h4><p><strong>以下代码段执行后的输出结果为()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = -<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y = -<span class="number">12</span>;</span><br><span class="line">System.out.println(y % x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A：-1</li><li>B：2</li><li>C：1</li><li>D：-2</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p>取模运算，结果的符号和被除数符号一致，切记切记</p></blockquote><h4 id="24"><a href="#24" class="headerlink" title="24"></a>24</h4><p><strong>（多选）以下关于final关键字说法错误的是</strong></p><ul><li><strong>A：</strong>final是java中的修饰符，可以修饰类、接口、抽象类、方法和属性</li><li><strong>B：</strong>final修饰的类肯定不能被继承</li><li><strong>C：</strong>final修饰的方法不能被重载</li><li><strong>D：</strong>final修饰的变量不允许被再次赋值</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AC</span></span><p><strong>解析：</strong></p><ul><li><p>final修饰类、方法、属性！不能修饰抽象类，因为抽象类一般都是需要被继承的，final修饰后就不能继承了。</p></li><li><p>final修饰的方法不能被重写而不是重载！ </p></li><li><p>final修饰属性，此属性就是一个常量，不能被再次赋值！ </p></li><li><p>final也不能修饰接口，接口可以只能被public&amp;abstract修饰</p></li><li><p>final如果修饰的是基本类型的变量，那么这个变量就表示为一个常数，只能赋值一次，要么在定义时赋值，要么在初始化时赋值；final修饰应用类型的变量是，变量不能再次被赋值意思是变量的地址（引用）不可以被改变，当变量所指向的内容可以被改变。</p></li></ul></blockquote><h4 id="25"><a href="#25" class="headerlink" title="25"></a>25</h4><p><strong>静态内部类不可以直接访问外围类的非静态数据，而非静态内部类可以直接访问外围类的数据，包括私有数据。（ ）</strong></p><ul><li><strong>A：</strong>正确</li><li><strong>B：</strong>错误</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><ol><li><p><strong>静态内部类：</strong></p><ol><li>静态内部类本身可以访问外部的静态资源，包括静态私有资源。但是不能访问非静态资源，可以不依赖外部类实例而实例化。</li></ol></li><li><p><strong>成员内部类：</strong></p><ol><li>成员内部类本身可以访问外部的所有资源，但是自身不能定义静态资源，因为其实例化本身就还依赖着外部类。</li></ol></li><li><p><strong>局部内部类：</strong></p><ol><li>局部内部类就像一个局部方法，不能被访问修饰符修饰，也不能被static修饰。</li><li>局部内部类只能访问所在代码块或者方法中被定义为final的局部变量。</li></ol></li><li><p><strong>匿名内部类：</strong></p><ol><li>没有类名的内部类，不能使用class，extends和implements，没有构造方法。</li></ol><p>​    2.  多用于GUI中的事件处理。</p><p>​    3.  不能定义静态资源</p><p>​    4.  只能创建一个匿名内部类实例。</p><p>​    5. 一个匿名内部类一定是在new后面的，这个匿名类必须继承一个父类或者实现一个接口。</p><p>​    6. 匿名内部类是局部内部类的特殊形式，所以局部内部类的所有限制对匿名内部类也有效。</p></li></ol></blockquote><h4 id="26"><a href="#26" class="headerlink" title="26"></a>26</h4><p><strong>有如下4条语句：()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i01=<span class="number">59</span>;</span><br><span class="line"><span class="keyword">int</span> i02=<span class="number">59</span>;</span><br><span class="line">Integer i03=Integer.valueOf(<span class="number">59</span>);</span><br><span class="line">Integer i04=<span class="keyword">new</span> Integer(<span class="number">59</span>);</span><br></pre></td></tr></table></figure><p><strong>以下输出结果为false的是:</strong></p><ul><li>System.out.println(i01==i02);</li><li>System.out.println(i01==i03);</li><li>System.out.println(i03==i04);</li><li>System.out.println(i02==i04);</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><ul><li>无论如何，Integer与new Integer不会相等。不会经历拆箱过程，</li><li>两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false；java在编译Integer i2 = 128的时候,被翻译成-&gt; Integer i2 = Integer.valueOf(128);而valueOf()函数会对-128到127之间的数进行缓存</li></ul><blockquote><p>Integer.valueOf方法中也有判断，如果传递的整型变量&gt;= -128并且小于127时会返回IntegerCache类中一个静态数组中的某一个对象， 否则会返回一个新的Integer对象,代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li>两个都是new出来的,都为false</li><li>int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比</li></ul></blockquote><h4 id="27"><a href="#27" class="headerlink" title="27"></a>27</h4><p><strong>定义有StringBuffer s1=new StringBuffer(10);s1.append(“1234”)则s1.length()和s1.capacity()分别是多少?</strong></p><ul><li><strong>A：</strong>4   10</li><li><strong>B：</strong>4   4</li><li><strong>C：</strong>10  10</li><li><strong>D：</strong>10  4</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>StringBuffer s = new StringBuffer(x);  x为初始化容量长度</p><p>s.append(“Y”); “Y”表示长度为y的字符串</p><p>length始终返回当前长度即y；</p><p>对于s.capacity()：</p><p>1.当y&lt;x时，值为x</p><p>以下情况，容器容量需要扩展</p><p>2.当x&lt;y&lt;2<em>x+2时，值为 2</em>x+2</p><p>3.当y&gt;2x+2时，值为y</p></blockquote><h4 id="28"><a href="#28" class="headerlink" title="28"></a>28</h4><p><strong>（多选）有关静态初始化块说法正确的是？</strong></p><ul><li><strong>A：</strong>无法直接调用静态初始化块</li><li><strong>B：</strong>在创建第一个实例前或引用任何静态成员之前，将自动调用静态初始化块来初始化</li><li><strong>C：</strong>静态初始化块既没有访问修饰符，也没有参数</li><li><strong>D：</strong>在程序中，用户可以控制合适执行静态初始化块</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ABC</span></span><p><strong>解析：</strong></p><p><strong>java对象初始化顺序</strong><br>先说结论：</p><ol><li>父类静态代码块，父类静态成员变量（同级，按代码顺序执行）</li><li>子类静态代码块，子类静态成员变量（同级，按代码顺序执行）</li><li>父类普通代码块，父类普通成员变量（同级，按代码顺序执行）</li><li>父类构造方法</li><li>子类普通代码块，子类普通成员变量（同级，按代码顺序执行）</li><li>子类构造方法</li></ol><p>注意点：</p><ol><li>静态内容只在类加载时执行一次，之后不再执行。</li><li>默认调用父类的无参构造方法，可以在子类构造方法中利用super指定调用父类的哪个构造方法。</li></ol></blockquote><h4 id="29"><a href="#29" class="headerlink" title="29"></a>29</h4><p><strong>执行如下程序代码</strong></p><p>char chr = 127;</p><p>int sum = 200;</p><p>chr += 1;</p><p>sum += chr;</p><p>后，sum的值是   ; （     ）</p><p>备注：同时考虑c/c++和Java的情况的话</p><ul><li><strong>A：</strong>72</li><li><strong>B：</strong>99</li><li><strong>C：</strong>328</li><li><strong>D：</strong>327</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span> <p><strong>解析：</strong></p><p>java中只有byte, boolean是一个字节, char是两个字节, 所以对于java来说127不会发生溢出, 输出328</p><p>但是对于c/c++语言来说, char是一个字节, 会发生溢出, 对127加一发生溢出,  0111 1111 –&gt; 1000 0000, 1000 0000为补码-128, 所以结果为200-128=72</p></blockquote><h4 id="30"><a href="#30" class="headerlink" title="30"></a>30</h4><p><strong>下列关于包（package）的描述，正确的是（）</strong></p><ul><li><strong>A：</strong>包（package）是Java中描述操作系统对多个源代码文件组织的一种方式。</li><li><strong>B：</strong>import语句将所对应的Java源文件拷贝到此处执行。</li><li><strong>C：</strong>包（package）是Eclipse组织Java项目特有的一种方式。</li><li><strong>D：</strong>定义在同一个包（package）内的类可以不经过import而直接相互使用。</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span>        <p><strong>解析：</strong></p><p>1、为了更好地组织类，Java提供了包机制。包是类的容器，用于分隔类名空间。如果没有指定包名，所有的示例都属于一个默认的无名包。Java中的包一般均包含相关的类，java是跨平台的，所以java中的包和操作系统没有任何关系，java的包是用来组织文件的一种虚拟文件系统。A错</p><p>2、import语句并没有将对应的java源文件拷贝到此处仅仅是引入，告诉编译器有使用外部文件，编译的时候要去读取这个外部文件。B错<br>3、Java提供的包机制与IDE没有关系。C错<br>4、定义在同一个包（package）内的类可以不经过import而直接相互使用。        </p></blockquote><h4 id="31"><a href="#31" class="headerlink" title="31"></a>31</h4><p><strong>（多选）哪个是不正确的字符常量？</strong></p><ul><li><strong>A：</strong>”\n”</li><li><strong>B：</strong>”1”</li><li><strong>C：</strong>”a”</li><li><strong>D：</strong>”\101”</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ABCD</span></span><p>解析：文字游戏注意是<strong>字符常量（’’）</strong>而不是<strong>字符串常量（””）</strong></p></blockquote><h4 id="32"><a href="#32" class="headerlink" title="32"></a>32</h4><p><strong>（多选）以下关于JAVA语言异常处理描述正确的有？</strong></p><ul><li><strong>A：</strong>throw关键字可以在方法上声明该方法要抛出的异常。</li><li><strong>B：</strong>throws用于抛出异常对象。</li><li><strong>C：</strong>try是用于检测被包住的语句块是否出现异常，如果有异常，则抛出异常，并执行catch语句。</li><li><strong>D：</strong>finally语句块是不管有没有出现异常都要执行的内容。<br>在try块中不可以抛出异常</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：CD</span></span><p><strong>解析：</strong></p><p>Java语言中的异常处理包括声明异常、抛出异常、捕获异常和处理异常四个环节。</p><ul><li><p>throws关键字可以在方法上声明该方法要抛出的异常，然后在方法内部通过throw抛出异常对象。<strong>A选项应该为throws B选项应该为throw</strong>。</p></li><li><p>C选项不严谨，这个异常不是用try抛出来的，而是用了try能检测到底层抛出的异常，然后进行处理。这里应该用“<strong>捕获</strong>”这个异常才对。</p><p>这个“如果有异常，则抛出异常”。在捕获异常的时候使用throw，才会抛出这个异常，否则只是捕获到，而不是抛出。这个是需要显式写出来的。</p><p>但是答案中存在，忽略这个细节。AB错误太明显。</p></li></ul></blockquote><h4 id="33"><a href="#33" class="headerlink" title="33"></a>33</h4><p><strong>下列语句正确的是：</strong></p><ul><li><strong>A：</strong>形式参数可被字段修饰符修饰</li><li><strong>B：</strong>形式参数不可以是对象</li><li><strong>C：</strong>形式参数为方法被调用时真正被传递的参数</li><li><strong>D：</strong>形式参数可被视为local variable</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p><img src="https://image.cclblog.cn/blog/20200623100219.png" alt=""></p></blockquote><h4 id="34"><a href="#34" class="headerlink" title="34"></a>34</h4><p><strong>关于C++/JAVA类中static 成员和对象成员的说法正确的是？</strong></p><ul><li><strong>A：</strong>static 成员变量在对象构造时生成</li><li><strong>B：</strong>static 成员函数在对象成员函数中无法调用</li><li><strong>C：</strong>虚成员函数不可能是static 成员函数</li><li><strong>D：</strong>static 成员函数不能访问static 成员变量</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><ul><li>static为成员变量或函数，在类初始化是加载完成，可以被成员函数调用或访问</li><li>static成员函数既可以通过类名直接调用，也可以通过对象名进行调用</li><li>虚函数是C++中的，虚函数不可能是static的</li><li>static成员函数可以访问static成员变量</li></ul></blockquote><h4 id="35"><a href="#35" class="headerlink" title="35"></a>35</h4><p><strong>给定以下JAVA代码，这段代码运行后输出的结果是（）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aMethod</span><span class="params">(<span class="keyword">int</span> i)</span><span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"exception in a Method"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">"finally"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            aMethod(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.printf(<span class="string">"exception in main"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>exception in main finished</li><li><strong>B：</strong>finally finished</li><li><strong>C：</strong>exception in main finally</li><li><strong>D：</strong>finally exception in main finished</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>题目中是i/10 不是 10/i 绝对不会报异常</p><p>1、finally块一定会执行，无论是否try…catch。</p><p>2、finally前有return，会先执行return语句，并保存下来，再执行finally块，最后return。</p><p>3、finally前有return、finally块中也有return，先执行前面的return，保存下来，再执行finally的return，覆盖之前的结果，并返回。</p></blockquote><h4 id="36"><a href="#36" class="headerlink" title="36"></a>36</h4><p><strong>What is the result?</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.print(c);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] argv )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( foo(<span class="string">'A'</span>); foo(<span class="string">'B'</span>) &amp;&amp; (i &lt; <span class="number">2</span>); foo(<span class="string">'C'</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            i++ ;</span><br><span class="line">            foo(<span class="string">'D'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>ABDCBDCB</li><li><strong>B：</strong>ABCDABCD</li><li><strong>C：</strong>Compilation fails.</li><li><strong>D：</strong>An exception is thrown at runtime.</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>for(条件1;条件2;条件3) {</p><p>​    //语句</p><p>}</p><p>执行顺序是条件1-&gt;条件2-&gt;语句-&gt;条件3-&gt;条件2-&gt;语句-&gt;条件3-&gt;条件2……..</p><p>如果条件2为true，则一直执行。如果条件2位false，则for循环结束21. </p></blockquote><h4 id="37"><a href="#37" class="headerlink" title="37"></a>37</h4><p><strong>Which lines of the following will produce an error?</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="keyword">byte</span> a1 = <span class="number">2</span>, a2 = <span class="number">4</span>, a3;</span><br><span class="line"><span class="number">2</span>. <span class="keyword">short</span> s = <span class="number">16</span>;</span><br><span class="line"><span class="number">3</span>. a2 = s;</span><br><span class="line"><span class="number">4</span>. a3 = a1 * a2;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>Line 3 and Line 4</li><li><strong>B：</strong>Line 1 only</li><li><strong>C：</strong>Line 3 only</li><li><strong>D：</strong>Line 4 only</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>short类型转为byte类型出错</p><p>a1*a2结果为int类型，转为byte类型出错</p><p><strong>java中如果碰到char、byte和short参与运算时，会自动将这些值转换为int类型然后再进行运算。这里a1和a2就自动转为int类型了，结果也为Int类型。把一个int类型赋值给byte需要转型。</strong></p></blockquote><h4 id="38"><a href="#38" class="headerlink" title="38"></a>38</h4><p><strong>What is displayed when the following is executed;</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1=-<span class="number">0.5</span>;</span><br><span class="line">System.out.println(<span class="string">"Ceil d1="</span>+Math.ceil(d1));</span><br><span class="line">System.out.println(<span class="string">"floor d1="</span>+Math.floor(d1));</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>Ceil d1=-0.0<br>floor d1=-1.0</li><li><strong>B：</strong>Ceil d1=0.0<br>floor d1=-1.0</li><li><strong>C：</strong>Ceil d1=-0.0<br>floor d1=-0.0</li><li><strong>D：</strong>Ceil d1=0.0<br>floor d1=0.0</li><li><strong>E：</strong>Ceil d1=0<br>floor d1=-1</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p><strong>ceil：天花板数，向上取整。</strong></p><p><strong>floor：地板数，向下取整</strong></p><p>这里主要是有一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Math.ceil(d1) `</span><br></pre></td></tr></table></figure><p>ceil 方法上有这么一段注释：If the argument value is less than zero but greater than -1.0, then the result is negative zero</p><p>如果参数小于0且大于-1.0，结果为 -0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Math.floor(d1)`</span><br></pre></td></tr></table></figure><p>ceil 和 floor 方法 上都有一句话：If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as  the argument，意思为：如果参数是 NaN、无穷、正 0、负 0，那么结果与参数相同，</p><p>如果是 -0.0，那么其结果是 -0.0</p></blockquote><h4 id="39"><a href="#39" class="headerlink" title="39"></a>39</h4><p><strong>java中将ISO8859-1字符串转成GB2312编码，语句为 ？</strong>  </p><ul><li><strong>A：</strong>new String(“ISO8859-1”.getBytes(“ISO8859-1”),”GB2312”)</li><li><strong>B：</strong>new String(String.getBytes(“GB2312”）, ISO8859-1)</li><li><strong>C：</strong>new String(String.getBytes(“ISO8859-1”))</li><li><strong>D：</strong>new String(String.getBytes(“GB2312”))</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>注意这里”ISO8859-1”是一个普通字符串，不要被迷惑了</p><p>new String(“这是要转换的字符串”.getBytes(“ISO-8859-1”), “GB2312”);</p></blockquote><h4 id="40"><a href="#40" class="headerlink" title="40"></a>40</h4><p><strong>（多选）已知String a=”a”,String b=”b”,String c=a+b,String d=new String(“ab”) 以下操作结果为true的是</strong></p><ul><li><strong>A：</strong>(a+b).equals(c)</li><li><strong>B：</strong>a+b==c</li><li><strong>C：</strong>c==d</li><li><strong>D：</strong>c.equals(d)</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AD</span></span><p><strong>解析：</strong></p><p>1.== 和 equals():</p><p>(1)“==” 用于比较基本数据类型时比较的是值，用于比较引用类型时比较的是引用指向的地址。</p><p>(2)Object 中的equals() 与 “==” 的作用相同，但String类重写了equals()方法，比较的是对象中的内容。</p><p>2.String对象的两种创建方式:</p><p>(1)第一种方式: String str1 = “aaa”;  是在常量池中获取对象(“aaa” 属于字符串字面量，因此编译时期会在常量池中创建一个字符串对象，如果常量池中已经存在该字符串对象则直接引用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>3.String类型的常量池比较特殊。它的主要使用方法有两种</p><p>(1)直接使用双引号声明出来的String对象会直接存储在常量池中。</p><p>(2)如果不是用双引号声明的String对象,可以使用 String 提供的 intern 方法。 String.intern() 是一个 Native 方法，它的作用是： 如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用； 如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"AAA"</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 = <span class="string">"AAA"</span>;</span><br><span class="line">System.out.println(s2);<span class="comment">//AAA</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false，因为一个是堆内存中的String对象一个是常量池中的String对象，</span></span><br><span class="line">System.out.println(s2 == s3);<span class="comment">//true， s1,s2指向常量池中的”AAA“</span></span><br></pre></td></tr></table></figure><p>4字符串拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"a"</span>;</span><br><span class="line">String b = <span class="string">"b"</span>;</span><br><span class="line">  </span><br><span class="line">String str1 = <span class="string">"a"</span> + <span class="string">"b"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">String str2 = a + b; <span class="comment">//在堆上创建的新的对象     </span></span><br><span class="line">String str3 = <span class="string">"ab"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//true </span></span><br><span class="line">System.out.println(str2 == str3);<span class="comment">//false</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="41"><a href="#41" class="headerlink" title="41"></a>41</h4><p><strong>对于java类型变量char c,short s,float f,double d,表达式c*s+f+d的结果类型为（）</strong></p><ul><li><strong>A：</strong>float</li><li><strong>B：</strong>char</li><li><strong>C：</strong>short</li><li><strong>D：</strong>double</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p><strong>基本数据类型的运算，会自动向上转型。boolean不可以和其他基本数据类型相互转换。</strong></p><p><strong>byte-&gt;short,char -&gt; int -&gt; long</strong>      </p><p><strong>float -&gt; double</strong></p><p><strong>int -&gt; float</strong></p><p><strong>long -&gt; double</strong></p><p><img src="https://image.cclblog.cn/blog/20200622161949.png" alt=""></p></blockquote><h4 id="42"><a href="#42" class="headerlink" title="42"></a>42</h4><p><strong>在运行时，由java解释器自动引入，而不用import语句引入的包是()。</strong></p><ul><li><strong>A：</strong>java.lang</li><li><strong>B：</strong>java.system</li><li><strong>C：</strong>java.io</li><li><strong>D：</strong>java.util</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>java.lang包是java语言的核心包，lang是language的缩写</p><p>java.lang包定义了一些基本的类型，包括Integer,String之类的，是java程序必备的包，有解释器自动引入，无需手动导入</p></blockquote><h4 id="43"><a href="#43" class="headerlink" title="43"></a>43</h4><p><strong>由3 个“1”和 5 个“0”组成的 8 位二进制补码，能表示的最小整数（）</strong></p><ul><li><strong>A：</strong>-126</li><li><strong>B：</strong>-125</li><li><strong>C：</strong>-32</li><li><strong>D：</strong>-3</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>既然求最小整数，那肯定先想到负数，则最高位（符号位）一定为1，原码中肯定是1所在的位数越高，值越小，而补码是由原码取反加1（符号位不变）得到的，则在补码中1所在的位数一定要越低，即补码为1000 0011；由补码求得原码：1111 1101=-(64+32+16+8+4+1)=-125;</p></blockquote><h4 id="44"><a href="#44" class="headerlink" title="44"></a>44</h4><p><strong>关于访问权限，说法正确的是？ ( )</strong></p><ul><li><strong>A：</strong>类A和类B在同一包中，类B有个protected的方法testB，类A不是类B的子类（或子类的子类），类A可以访问类B的方法testB</li><li><strong>B：</strong>类A和类B在同一包中，类B有个protected的方法testB，类A不是类B的子类（或子类的子类），类A不可以访问类B的方法testB</li><li><strong>C：</strong>访问权限大小范围：public &gt; 包权限 &gt; protected &gt; private</li><li><strong>D：</strong>访问权限大小范围：public &gt; 包权限 &gt; private &gt; protected</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p><img src="https://image.cclblog.cn/blog/20200622110227.jpg" alt=""></p></blockquote><h4 id="45"><a href="#45" class="headerlink" title="45"></a>45</h4><p><strong>以下程序程序运行后的输出结果是（）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">12</span>,n=<span class="number">34</span>;</span><br><span class="line">    System.out.printf(<span class="string">"%d%d"</span>,m++,++n);</span><br><span class="line">    System.out.printf(<span class="string">"%d%d\n"</span>,n++,++m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>12353514</li><li><strong>B：</strong>12353513</li><li><strong>C：</strong>12343514</li><li><strong>D：</strong>12343513</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p><strong>不要忘记前面已经自加过后，变量的值已经改变了（明白了这个肯定就没问题了）</strong></p><p>​          第一个输出：m++值：12，m的值：13</p><p>​                              ++n值：35，n的值：35</p><p>​          第一个输出：n++值：35，n的值：36</p><p>​                              ++m值：14，n的值：14</p><p>​          故最终输出：12353514</p></blockquote><h4 id="46"><a href="#46" class="headerlink" title="46"></a>46</h4><p><strong>在jdk1.8之前，下列哪一种叙述是正确的（ ）</strong></p><ul><li><strong>A：</strong>abstract修饰符可修饰字段、方法和类</li><li><strong>B：</strong>抽象方法的body部分必须用一对大括号{ }包住</li><li><strong>C：</strong>声明抽象方法，大括号可有可无</li><li><strong>D：</strong>声明抽象方法不可写出大括号</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style=""> 查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p>A:abstract修饰方法和类</p><p>B、C:抽象方法没有方法体，有没有方法体看有没有大括号。</p></blockquote><h4 id="47"><a href="#47" class="headerlink" title="47"></a>47</h4><p><strong>以下不是修饰符final的作用的是( )。</strong></p><ul><li><strong>A：</strong>修饰常量</li><li><strong>B：</strong>修饰不可被继承的类</li><li><strong>C：</strong>修饰不可变类</li><li><strong>D：</strong>修饰不可覆盖的方法</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p>final的作用：</p><p>​    1. 修饰变量，变量的引用地址不可变，但是地址中的内容可以变。</p><p>​    2. 修饰方法，方法不可被重写，但是还是可以重载</p><p>​    3. 修饰类，类不可继承。</p><p><strong>不可变类：</strong>说的是一个类一旦被实例化，就不可改变自身的状态。常见的比如String和基本数据类型的包装类，对于这种不可变类，一旦在进行引用传递的时候，形参一开始就和实际参数指向的不是一个地址，所以在方法中对形参的改变，并不会影响实际参数。</p></blockquote><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h4 id="48"><a href="#48" class="headerlink" title="48"></a>48</h4><p><strong>在一个基于分布式的游戏服务器系统中，不同的服务器之间，哪种通信方式是不可行的（）？</strong></p><ul><li><strong>A：</strong>管道</li><li><strong>B：</strong>消息队列</li><li><strong>C：</strong>高速缓存数据库</li><li><strong>D：</strong>套接字</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p><strong>管道( pipe )：</strong>管道是一种半双工的通信方式，数据只能单向流动，<strong>而且只能在具有亲缘关系的进程间使用</strong>。进程的亲缘关系通常是指父子进程关系。</p><p><strong>既然是不同的服务器之间进行通信，怎么可能会是具有亲缘关系的进程呢？</strong></p></blockquote><h4 id="49"><a href="#49" class="headerlink" title="49"></a>49</h4><p><strong>以下哪个式子有可能在某个进制下成立（）？</strong></p><ul><li><strong>A：</strong>13  * 14=204</li><li><strong>B：</strong>12 * 34=568</li><li><strong>C：</strong>14*14=140</li><li><strong>D：</strong>1+1=3</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>A:  假设为x进制</p><p>13用10进制表示为 1 * x^1 + 3 * x ^ 0 =  x + 3</p><p>同理 14 ：x + 4 </p><p>204：2x^2 + 4</p><p>(x + 3)(x + 4 ) = 2x^2 + 4</p><p>解得 x1 = 8 x2 = -1</p><p>BCD同理可计算</p></blockquote><h4 id="50"><a href="#50" class="headerlink" title="50"></a>50</h4><p><strong>以下JAVA程序代码的输出是</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="number">17</span>^<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>12</li><li><strong>B：</strong>22</li><li><strong>C：</strong>20</li><li><strong>D：</strong>1419857</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p>位异运算符号。</p><p>运算规则是：两个数转为二进制，然后从高位开始比较，如果相同则为0，不相同则为1。</p><p>17：0001 0001 </p><p>5：  0000 0101</p><p>结果：0001 0100 转10进制：20</p></blockquote><h4 id="51"><a href="#51" class="headerlink" title="51"></a>51</h4><p><strong>变量a是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF;变量b是一个64位有符号的整数，初始值用16进制表示为：0x8000000000000000。则a+b的结果用10进制表示为多少？</strong></p><ul><li><strong>A：</strong>1</li><li><strong>B：</strong>-1</li><li><strong>C：</strong>2^63+2^62+…+2^2+2^1+2^0</li><li><strong>D：</strong>–(2^63+2^62+…+2^2+2^1+2^0)</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>0x7FFFFFFFFFFFFFFF +  0x8000000000000000 =  0xFFFFFFFFFFFFFFFF</p><p>（1）a+b的16进制表示为：OxFFFFFFFFFFFFFFF（16位F），转为2进制为111……111（64位1，每个F-&gt;4位2进制）。</p><p>（2）有符号数：是针对二进制来讲的。用最高位作为符号位，“0”代表“+”，“1”代表“-”。所以a+b的结果是一个负数。</p><p>（3）计算机中负数是以补码的形式保存的，将补码转换成原码的计算方式如下：</p><p>​        ①. 对于正数，原码与补码相同。</p><p>​        ②.对于负数：</p><p>​                （1）<strong>符号位保持不变</strong>，按位取反，末位加1，即得到原码。</p><p>​                （2）<strong>符号位保持不变</strong>，先-1，然后其他位按位取反            </p><p>​                    这两种方法都可以    </p><p>（4）a + b = 111……111（64位1）</p><p>​          取反：100……000（1位1，后面63位0）</p><p>​          加一：100……00（中间62位0）</p><p>​      结果10进制：-1。</p></blockquote><h4 id="52"><a href="#52" class="headerlink" title="52"></a>52</h4><p><strong>存根（Stub）与以下哪种技术有关</strong> </p><ul><li><strong>A：</strong>交换</li><li><strong>B：</strong>动态链接</li><li><strong>C：</strong>动态加载</li><li><strong>D：</strong>磁盘调度</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>存根类是一个类，它实现了一个接口，它的作用是：如果一个接口有很多方法，如果要实现这个接口，就要实现所有的方法。但是一个类从业务来说，可能只需要其中一两个方法。如果直接去实现这个接口，除了实现所需的方法，还要实现其他所有的无关方法。而如果通过继承存根类就实现接口，就免去了这种麻烦。<br>RMI 采用stubs 和 skeletons 来进行远程对象(remote object)的通讯。stub 充当远程对象的客户端<strong>，有着和远程对象相同的远程接口，远程对象的调用实际是通过调用该对象的客户端</strong>对象stub来完成的。<br>每个远程对象都包含一个<strong>对象stub，当运行在本地Java虚拟机上的程序调用运行在远程Java虚拟机上的对象方法时，它首先在本地创建该对象的</strong>对象stub, 然后调用对象上匹配的方法。每一个远程对象同时也包含一个skeleton对象，skeleton运行在远程对象所在的虚拟机上，接受来自stub对象的调用。这种方式符合等到程序要运行时将目标文件动态进行链接的思想</p></blockquote><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h4 id="53"><a href="#53" class="headerlink" title="53"></a>53</h4><p><strong>（多选）对Collection和Collections描述正确的是</strong></p><ul><li><strong>A：</strong>Collection是java.util下的类，它包含有各种有关集合操作的静态方法</li><li><strong>B：</strong>Collection是java.util下的接口，它是各种集合结构的父接口</li><li><strong>C：</strong>Collections是java.util下的接口，它是各种集合结构的父接口</li><li><strong>D：</strong>Collections是java.util下的类，它包含有各种有关集合操作的静态方法</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BD</span></span><p><strong>解析：</strong></p><ul><li><p>java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。</p></li><li><p>java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。</p></li></ul></blockquote><h4 id="54"><a href="#54" class="headerlink" title="54"></a>54</h4><p><strong>java8中，下面哪个类用到了解决哈希冲突的开放定址法</strong></p><ul><li><strong>A：</strong>LinkedHashSet</li><li><strong>B：</strong>HashMap</li><li><strong>C：</strong>ThreadLocal</li><li><strong>D：</strong>TreeMap</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p>ThreadLocalMap中使用开放地址法来处理散列冲突，而HashMap中使用的是分离链表法。之所以采用不同的方式主要是因为：在ThreadLocalMap中的散列值分散得十分均匀，很少会出现冲突。并且ThreadLocalMap经常需要清除无用的对象，使用纯数组更加方便。</p></blockquote><h4 id="55"><a href="#55" class="headerlink" title="55"></a>55</h4><p><strong>列表(List)和集合(Set)下面说法正确的是？  ( )</strong></p><ul><li><strong>A：</strong>Set中至多只能有一个空元素</li><li><strong>B：</strong>List中至多只能有一个空元素</li><li><strong>C：</strong>List和Set都可以包含重复元素的有序集合</li><li><strong>D：</strong>List和Set都是有序集合</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><ul><li>Set 不能有重复的元素，且是无序的，要有空值也就只能有一个。因为它不允许重复。 L ist 可以有重复元素，且是有序的，要有空值也可以有多个，因为它可重复。</li><li>java里面讲的有序无序，指的是你按照顺序存进去数据，然后再按照顺序取出来，两者是一样的。比如List(0)我放的是“a”，那么我list.get(0)取出来也是“a”。并不代表我存了打乱顺序存1到10十个数，它会自己给按照升序或者降序给你排好序。</li></ul></blockquote><h4 id="56"><a href="#56" class="headerlink" title="56"></a>56</h4><p><strong>（多选）关于java集合下列说法不正确的有哪些（）</strong></p><ul><li><strong>A：</strong>HashSet 它是线程安全的，不允许存储相同的对象</li><li><strong>B：</strong>ConcurrentHashMap 它是线程安全的，其中存储的键对象可以重复，值对象不能重复</li><li><strong>C：</strong>Collection接口是List接口和Set接口的父接口，通常情况下不被直接使用</li><li><strong>D：</strong>ArrayList线程安全的，允许存放重复对象</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ABD</span></span><p><strong>解析：</strong></p><p><strong>注意：常见并非全部</strong></p><p><strong>线程安全(Thread-safe)的集合对象：</strong></p><ul><li>Vector 线程安全：</li><li>HashTable 线程安全：</li><li>StringBuffer 线程安全：</li></ul><p><strong>非线程安全的集合对象：</strong></p><ul><li>ArrayList ：</li><li>LinkedList：</li><li>HashMap：</li><li>HashSet：</li><li>TreeMap：</li><li>TreeSet：</li><li>StringBulider：</li></ul></blockquote><h4 id="57"><a href="#57" class="headerlink" title="57"></a>57</h4><p><strong>list是一个ArrayList的对象，哪个选项的代码填到//todo delete处，可以在Iterator遍历的过程中正确并安全的删除一个list中保存的对象？（）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = list.iterator();</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">    Object obj = it.next();</span><br><span class="line">    <span class="keyword">if</span> (needDelete(obj))  <span class="comment">//needDelete返回boolean，决定是否要删除</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//todo delete</span></span><br><span class="line">    &#125;</span><br><span class="line">    index ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>it.remove();</li><li><strong>B：</strong>list.remove(obj);</li><li><strong>C：</strong>list.remove(index);</li><li><strong>D：</strong>list.remove(obj,index);</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>源码是这么描述的：<strong>ArrayList</strong> 继承了 <strong>AbstractList，</strong> 其中<strong>AbstractList</strong> 中有个<strong>modCount</strong> 代表了集合修改的次数。在<strong>ArrayList的iterator方法中会判断</strong> <strong>expectedModCount与</strong> <strong>modCount是否相等，如果相等继续执行，不相等报错，只有iterator的remove方在调用自身的remove之后让</strong> <strong>expectedModCount与modCount再相等，所以是安全的。</strong></p></blockquote><h4 id="58"><a href="#58" class="headerlink" title="58"></a>58</h4><p><strong>（多选）Hashtable 和 HashMap 的区别是：</strong></p><ul><li><strong>A：</strong>Hashtable 是一个哈希表，该类继承了 AbstractMap，实现了 Map 接口</li><li><strong>B：</strong>HashMap 是内部基于哈希表实现，该类继承AbstractMap，实现Map接口</li><li><strong>C：</strong>Hashtable 线程安全的，而 HashMap 是线程不安全的</li><li><strong>D：</strong>Properties 类 继承了 Hashtable 类，而 Hashtable 类则继承Dictionary 类</li><li><strong>E：</strong>HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BCDE</span></span><p><strong>解析：</strong></p><p><strong>Hashtable</strong>：</p><p>（1）Hashtable 是一个散列表，它存储的内容是键值对(key-value)映射。</p><p>（2）Hashtable 的函数都是同步的，这意味着它是<strong>线程安全</strong>的。它的key、value都不可以为null。</p><p>（3）HashTable直接使用对象的hashCode。</p><p><strong>HashMap：</strong></p><p>（1）由<strong>数组+链表</strong>(jdk1.8以前)组成的，基于<strong>哈希表的Map</strong>实现，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</p><p>（2）不是线程安全的，HashMap可以接受为null的键(key)和值(value)。</p><p>（3）HashMap重新计算hash值</p><p><strong>Hashtable,HashMap,Properties</strong>继承关系如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Properties</span> <span class="keyword">extends</span> <span class="title">Hashtable</span>&lt;<span class="title">Object</span>,<span class="title">Object</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Objecct</span><br><span class="line">java.util.Dictionary&lt;K,V&gt;</span><br><span class="line"> java.util.Hashtable&lt;Object,Object&gt;</span><br><span class="line">   java.util.Properties </span><br></pre></td></tr></table></figure></blockquote><h4 id="59"><a href="#59" class="headerlink" title="59"></a>59</h4><p><strong>(多选)对</strong> <strong>Map</strong> <strong>的用法，正确的有：</strong></p><ul><li><strong>A：</strong>new java.util.Map().put(“key” , “value”) ;</li><li><strong>B：</strong>new java.util.SortedMap().put(“key” , “value”) ;</li><li><strong>C：</strong>new java.util.HashMap().put( null , null ) ;</li><li><strong>D：</strong>new java.util.TreeMap().put( 0 , null ) ;</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：CD</span></span><p><strong>解析：</strong></p><p>选C、D。考察的是<strong>Map接口</strong>实现类的<strong>创建对象</strong>以及对象类型包含的<strong>方法</strong>。</p><p>A选项<strong>Map属于接口类型</strong>，不可以new的方式创建对象。所以A错误。</p><p>B选项<strong>SortedMap属于接口类型</strong>，不可以new的方式创建对象。所以B错误。</p><p>C选项<strong>HashMap</strong>基于哈希表实现Map接口的类，<strong>并允许null的值和null键</strong>。</p><p>D选项<strong>TreeMap</strong>通过红黑树实现Map接口的类，key不可以为null，会报<strong>NullPointerException</strong>异常,value可以为null。</p></blockquote><h4 id="60"><a href="#60" class="headerlink" title="60"></a>60</h4><p><strong>（多选）以下哪些继承自 Collection 接口（）</strong></p><ul><li><strong>A：</strong>List</li><li><strong>B：</strong>Set</li><li><strong>C：</strong>Map</li><li><strong>D：</strong>Array</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AB</span></span><p><strong>解析：</strong></p><p>├List</p><p>​    │├LinkedList</p><p>​    │├ArrayList</p><p>​    │└Vector</p><p>​        │└Stack</p><p>└Set</p><p>Map</p><p>​    ├Hashtable</p><p>​    ├HashMap</p><p>​    └WeakHashMap</p></blockquote><h4 id="61"><a href="#61" class="headerlink" title="61"></a>61</h4><p><strong>（多选）下面哪些类实现或继承了 Collection 接口？</strong></p><ul><li>A：HashMap</li><li>B：ArrayList</li><li>C：Vector</li><li>D：Iterator</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BC</span></span><p><strong>解析：</strong></p><p><img src="https://image.cclblog.cn/blog/20200623094232.png" alt=""></p></blockquote><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h4 id="62"><a href="#62" class="headerlink" title="62"></a>62</h4><p><strong>（多选）下列哪些操作会使线程释放锁资源？</strong></p><ul><li><strong>A：</strong>sleep()</li><li><strong>B：</strong>wait()</li><li><strong>C：</strong>join()</li><li><strong>D：</strong>yield()</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BC</span></span><p><strong>解析：</strong></p><p>所谓的释放锁资源实际是通知对象内置的monitor对象进行释放，而只有所有对象都有内置的monitor对象才能实现任何对象的锁资源都可以释放。又因为所有类都继承自Object，所以wait(）就成了Object方法，也就是通过wait()来通知对象内置的monitor对象释放，而且事实上因为这涉及对硬件底层的操作，所以wait()方法是native方法，底层是用C写的。</p><p>其他都是Thread所有，所以其他3个是没有资格释放资源的</p><p>而join()有资格释放资源其实是通过调用wait()来实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码如下： </span></span><br><span class="line">wait()方法   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// join()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay); </span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="63"><a href="#63" class="headerlink" title="63"></a>63</h4><p><strong>（多选）在Java线程状态转换时，下列转换不可能发生的有（）？</strong></p><ul><li><strong>A：</strong>初始态-&gt;运行态</li><li><strong>B：</strong>就绪态-&gt;运行态</li><li><strong>C：</strong>阻塞态-&gt;运行态</li><li><strong>D：</strong>运行态-&gt;就绪态</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AC</span></span><p><strong>解析：</strong></p><p><img src="https://image.cclblog.cn/blog/20200624171403.jpg" alt=""></p></blockquote><h4 id="64"><a href="#64" class="headerlink" title="64"></a>64</h4><p><strong>（多选）Java.Thread的方法resume()负责重新开始被以下哪个方法中断的线程的执行（）。</strong></p><ul><li><strong>A：</strong>stop</li><li><strong>B：</strong>sleep</li><li><strong>C：</strong>wait</li><li><strong>D：</strong>suspend</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p>resume与suspended一起使用<br>wait与notify/notifyAll一起使用<br>sleep会让线程暂时不执行</p><p><strong>Thread类的suspend（）和resume（）方法都已经被声明已废弃了</strong></p></blockquote><h4 id="65"><a href="#65" class="headerlink" title="65"></a>65</h4><p><strong>下列程序的运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            pong();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.run();</span><br><span class="line">    System.out.print(<span class="string">"ping"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"pong"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>pingpong</li><li><strong>B：</strong>pongping</li><li><strong>C：</strong>pingpong和pongping都有可能</li><li><strong>D：</strong>都不输出</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>这里需要注意Thread的start和run方法</p><p>用start方法才能真正启动线程，此时线程会处于就绪状态，一旦得到时间片，则会调用线程的run方法进入运行状态。</p><p>而run方法只是普通方法，如果直接调用run方法，程序只会按照顺序执行主线程这一个线程。</p></blockquote><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h4 id="66"><a href="#66" class="headerlink" title="66"></a>66</h4><p><strong>BufferedReader的父类是以下哪个？</strong></p><ul><li><strong>A：</strong>FilterReader</li><li><strong>B：</strong>InputStreamReader</li><li><strong>C：</strong>PipedReader</li><li><strong>D：</strong>Reader</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p><img src="https://image.cclblog.cn/blog/20200625205640.png" alt=""></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 题集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 题集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础习题整理</title>
      <link href="/2020/06/22/java/theme/question/"/>
      <url>/2020/06/22/java/theme/question/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础习题总结（99）"><a href="#Java基础习题总结（99）" class="headerlink" title="Java基础习题总结（99）"></a>Java基础习题总结（99）</h1><h2 id="1、第一周-66-（√）"><a href="#1、第一周-66-（√）" class="headerlink" title="1、第一周(66)（√）"></a><a href="/2020/06/22/java/question/1/">1、第一周(66)（√）</a></h2><h2 id="2、第二周-33-（√）"><a href="#2、第二周-33-（√）" class="headerlink" title="2、第二周(33)（√）"></a><a href="/2020/06/29/java/question/2/">2、第二周(33)（√）</a></h2><hr><p><img src="https://image.cclblog.cn/blog/20200705103225.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这1000多道题全部为基础知识点，其中框架的题目很少有，其中只有structs这个框架的一些题。jsp、图形用户界面的题目这些过时的题目大概100道题目。</p><p>第一周500道题目的正确率大概60%左右。</p><p>第二周500道题目的正确率大概将近70%。</p><p>总的正确率65%左右一般般</p><p><img src="https://image.cclblog.cn/blog/20200705115207.png" alt=""></p><h1 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h1><ul><li><p><strong>抽象类和接口的区别、接口和抽象类的特性：<a href="/2020/06/29/java/javase/17">接口与抽象类的区别</a></strong></p></li><li><p><strong>Java中的各种修饰符的含义：<a href="/2020/06/18/java/javase/3">Java中修饰符大全</a></strong></p></li><li><p><strong>类加载的顺序：<a href="/2020/07/03/java/javase/18">new一个类初始化的顺序</a></strong></p></li><li><p><strong>面向对象语言的特性：<a href="/2020/06/17/java/javase/2">面向对象三大特性：继承、封装、多态</a></strong></p></li><li><p><strong>异常体系结构</strong></p></li><li><p><strong>IO体系结构</strong></p></li><li><p><strong>StringBuffer与StringBuilder的区别：<a href="/2020/07/02/java/javase/4">StringBuffer与StringBuilder</a></strong></p></li><li><p><strong>i++ 与 ++i的题目</strong></p></li></ul><blockquote><p>这个变数特别多，不只是i++是先计算在++，++i先++在计算这么简单。</p></blockquote><ul><li><p><strong>重载，重写的区别和特性：<a href="/2020/06/16/java/javase/1">重载和重写</a></strong></p></li><li><p><strong>Java中的各种内部类：<a href="/2020/06/30/java/javase/6">Java中的内部类</a></strong></p></li><li><p><strong>集合框架相关</strong></p></li><li><p><strong>Java中的基本数据类型、范围、对应的包装数据类型，拆箱装箱以及数据类型的自动转换：<a href="/2020/06/17/java/javase/2">面向对象三大特性：继承、封装、多态</a></strong></p></li><li><p>Java中的关键字、变量命名规则</p></li><li><p>值传递、引用传递</p></li><li><p>switch语法</p></li></ul><blockquote><p>break，是否形成穿透</p></blockquote><ul><li>数组的声明语法</li><li>反射相关</li><li>….</li></ul><p><strong>JVM</strong></p><ul><li>内存结构</li><li>几个常用参数的含义</li><li>垃圾回收相关</li><li>类加载器相关</li><li>关于内存溢出</li></ul><blockquote><p><a href="/2020/06/06/java/theme/jvm"><strong>详解JVM</strong></a></p></blockquote><p><strong>计算机基础</strong></p><ul><li><strong>补码、反码相关的关于二进制的计算</strong></li><li>各种不常用的一些计算符（&gt;&gt; &lt;&lt; | &amp; ^等）</li></ul><p><strong>多线程</strong></p><ul><li><strong>多线程的各个方法的作用</strong></li><li><strong>多线程的各种状态转换</strong></li></ul><h1 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h1><ul><li><strong>千万不要以为多选就是多选，相信自己。</strong></li><li>做题是为了巩固基础，无论正确和错误，都要 看看题目的别人总结的解释，别为了做题而做题。</li><li>这些题目都很基础，如果做的很好也没必要沾沾自喜，做几套公司的题目就知道了，做的不好也没必要难受，很正常，坚持下来就行，先定个小目标先来500道。</li><li>没必要每天刻意去做题，每天抽出1，2个小时就可以。</li><li>做完之后有时间的话可以在尝试做一遍，第二遍会非常快的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> JAVA </category>
          
          <category> 题集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> JAVA </tag>
            
            <tag> 题集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成员变量与局部变量</title>
      <link href="/2020/06/21/java/javase/15/"/>
      <url>/2020/06/21/java/javase/15/</url>
      
        <content type="html"><![CDATA[<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ol><li><p><strong>成员变量</strong>是独立于方法外的变量，<strong>局部变量</strong>是方法中的变量。</p></li><li><p>成员变量：包括<strong>实例变量</strong>和<strong>类变量</strong>，用static修饰的是类变量，不用static修饰的是实例变量，所有类的成员变量可以通过this来引用。</p><p>局部变量：包括<strong>形参</strong>，<strong>方法局部变量</strong>，<strong>代码局部变量</strong>，存在于方法的参数列表和方法定义中以及代码块中。</p></li><li><p><strong>成员变量</strong>存储在<strong>堆</strong>，<strong>局部变量</strong>存储在<strong>栈</strong>。<strong>局部变量</strong>的<strong>作用域</strong>仅限于<strong>定义它的方法</strong>，在该方法的外部无法访问它。<strong>成员变量</strong>的<strong>作用域</strong>在<strong>整个类内部都</strong>是可见的，所有成员方法都可以使用它。如果访问权限允许，还可以在类外部使用成员变量。</p></li><li><p><strong>局部变量的生存周期与方法的生存周期相同</strong>。当方法执行到定义局部变量的语句时，局部变量被创建；执行到它所在的作用域的最后一条语句时局部变量将被销毁。<strong>类的成员变量如果是实例成员变量，它和对象对象的生命周期相同</strong>。<strong>而静态成员变量的生存期则是整个程序运行期。</strong></p></li><li><p>成员变量在累加或实例创建时，系统自动分配内存空间，并在分配空间后自动为成员变量指定初始化值，初始化值为默认值，<strong>基本数据类型byte、short、char、int、long默认值0，float、double默认为0.0，String等引用数据类型默认赋值为null。</strong>（被final修饰且没有static修饰的必须显示赋值），局部变量必须经过显示初始化后才能使用，系统不会为局部变量执行初始化。</p></li><li><p><strong>局部变量可以和成员变量同名，</strong>且在使用时，<strong>局部变量具有更高的优先级，直接使用同名访问，访问的是局部变量，如需访问成员变量可以使用this.变量名访问。</strong></p></li></ol><blockquote><p><strong>this不但可以引用实例变量也可以引用静态变量。</strong>因为类变量属于整个类，this代表当前对象，也可以使用整个类的方法与属性。但是一般来说，我们不会使用this来引用类变量，因为不管在实例方法还是类方法中，类变量都可以直接引用（在其他类中调用本类的类方法需要加类名），不需要加this。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动装箱与拆箱</title>
      <link href="/2020/06/20/java/javase/5/"/>
      <url>/2020/06/20/java/javase/5/</url>
      
        <content type="html"><![CDATA[<h1 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>自动装箱：</strong>就是自动将基本数据类型包装为包装器类型；</p><p><strong>自动拆箱：</strong>就是自动将包装器类型转换为基本数据类型；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Interger i = <span class="number">1</span>; <span class="comment">// 拆箱</span></span><br><span class="line"><span class="keyword">int</span> n = i; <span class="comment">// 装箱</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>这个装箱拆箱操作是jdk5的新特性</strong> </p><ul><li>JDK5之前的方式：比如Integer i = Integer.valueof(5);（这里5为基本类型int，Integer包装类利用valueof()方法将其转换为Integer类型）或者int i = i.intValue();（这里基本类型利用intValue()方法将Integer类型转换为基本类型int）。</li><li>JDK5之后的方式：比如①Integer i = 5;或者②int i = new Integer(100);，这里基本类型与包装类之间可直接操作，而①的操作就是自动装箱，②的操作就是自动拆箱。</li></ul></blockquote><table><thead><tr><th></th><th>More Actions  默认值</th><th>存储需求（字节）</th><th>取值范围</th><th>示例</th><th>包装类型</th></tr></thead><tbody><tr><td>byte</td><td>0</td><td>1</td><td>-2^7—2^7-1</td><td>byte b=10;</td><td><strong>Byte</strong></td></tr><tr><td>char</td><td>‘ \u0000′</td><td>2</td><td>0—2^16-1</td><td>char c=’c’ ;</td><td><strong>Character</strong></td></tr><tr><td>short</td><td>0</td><td>2</td><td>-2^15—2^15-1</td><td>short s=10;</td><td><strong>Short</strong></td></tr><tr><td>int</td><td>0</td><td>4</td><td>-2^31—2^31-1</td><td>int i=10;</td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>0</td><td>8</td><td>-2^63—2^63-1</td><td>long o=10L;</td><td><strong>Long</strong></td></tr><tr><td>float</td><td>0.0f</td><td>4</td><td>-2^31—2^31-1</td><td>float f=10.0F</td><td><strong>Float</strong></td></tr><tr><td>double</td><td>0.0d</td><td>8</td><td>-2^63—2^63-1</td><td>double d=10.0;</td><td><strong>Double</strong></td></tr><tr><td>boolean</td><td>false</td><td>不确定</td><td>true\false</td><td>boolean flag=true;</td><td><strong>Boolean</strong></td></tr></tbody></table><blockquote><p>boolean的大小java规范并没有明确给出具体查看：</p><p><a href="">https://www.cnblogs.com/wangtianze/p/6690665.html</a></p></blockquote><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><strong>1、有如下4条语句：()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i01=<span class="number">59</span>;</span><br><span class="line"><span class="keyword">int</span> i02=<span class="number">59</span>;</span><br><span class="line">Integer i03=Integer.valueOf(<span class="number">59</span>);</span><br><span class="line">Integer i04=<span class="keyword">new</span> Integer(<span class="number">59</span>);</span><br></pre></td></tr></table></figure><p><strong>以下输出结果为false的是:</strong></p><ul><li>System.out.println(i01==i02);</li><li>System.out.println(i01==i03);</li><li>System.out.println(i03==i04);</li><li>System.out.println(i02==i04);</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><ul><li>无论如何，Integer与new Integer不会相等。不会经历拆箱过程。</li><li>两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false；java在编译Integer i2 = 128的时候,被翻译成-&gt; Integer i2 = Integer.valueOf(128);而valueOf()函数会对-128到127之间的数进行缓存。</li></ul><blockquote><p>Integer.valueOf方法中也有判断，如果传递的整型变量&gt;= -128并且小于127时会返回IntegerCache类中一个静态数组中的某一个对象， 否则会返回一个新的Integer对象,代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">     <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">         <span class="keyword">return</span> IntegerCache.[i + (-IntegerCache.low)];</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li><strong>两个都是new出来的,都为false</strong></li><li><strong>int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比</strong></li></ul></blockquote><blockquote><p>我认为理论看的再多也不如实际的去做题，理论知道的多，题目不一定做得对，做题可以巩固自己的理论知识。</p></blockquote><p><strong>2、下面程序的输出结果是什么？（这个是我引用参考链接中第二个链接中的一个例子）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        Long h = <span class="number">2L</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(c==d); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(e==f); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(c==(a+b)); <span class="comment">// 3</span></span><br><span class="line">        System.out.println(c.equals(a+b)); <span class="comment">// 4</span></span><br><span class="line">        System.out.println(g==(a+b)); <span class="comment">// 5</span></span><br><span class="line">        System.out.println(g.equals(a+b)); <span class="comment">// 6 </span></span><br><span class="line">        System.out.println(g.equals(a+h)); <span class="comment">// 7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：1.true 2.false 3.true 4.true 5.true 6.false 7.true</span></span><p><strong>解析：</strong></p><ol><li>c==d：因为Integer中缓存的存在，如果数在[-128,127] (包括边界)，则是true,否则为false</li><li>e==f：同1</li><li>c=(a + b)：a + b 这个操作会自动拆箱结果为int</li><li>c.equals(a+b)：无需解释</li><li>(g==(a+b))：同3 a+b=&gt; int g为Long自动拆箱为long 然后int类型自动提升为long </li><li>g.equals(a+b)：a+b 为int 类型，Long 与 相同值的 包装类 用equals比较时，如果传入的类型不是Long,那么全部返回false，Long类中的equals()源码：</li></ol><p><img src="https://image.cclblog.cn/blog/20200628122339.png" alt=""></p><ol start="7"><li>g.equals(a+b)：true a+h 结果会向精度大的转换 为long类型</li></ol></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="比较值"><a href="#比较值" class="headerlink" title="比较值"></a>比较值</h3><ol><li>基本数据类型与引用数据类型进行比较时，引用数据类型会进行拆箱，然后与基本数据类型进行值的比较</li></ol><blockquote><p>int i = 12;<br>Integer j = new Integer(12);<br>i == j 返回的是true</p></blockquote><p>二、引用数据类型与基本数据类型进行比较（equals方法），基本数据类型会进行自动装箱，与引用数据类型进行比较，Object中的equals方法比较的是地址，但是Integer类已经重写了equals方法，只要两个对象的值相同，则可视为同一对象，具体看API文档，所以这归根到底也是值的比较！</p><blockquote><p>int i = 12;<br>Integer j = new Integer(12);<br>j.equals(i) 返回的是true</p></blockquote><h3 id="比较地址"><a href="#比较地址" class="headerlink" title="比较地址"></a>比较地址</h3><ol><li>如果引用数据类型是这样 Integer i = 12;直接从<strong>常量池</strong>取对象，这是如果数值是在-128与127之间，则视为同一对象，否则视为不同对象</li></ol><blockquote><p>Integer i = 12; Integer j = 12; i == j 返回的是true<br>Integer i = 128; Integer j = 128; i == j 返回的是false</p></blockquote><ol start="2"><li>如果引用数据类型是直接new的话，不管值是否相同，这时两个对象都是不相同的，因为都会各自在堆内存中开辟一块空间</li></ol><blockquote><p>Integer i =new Integer(12);<br>Integer j = new Integer(12);<br>i == j 这时返回的是false</p></blockquote><ol start="3"><li><strong>从常量池取对象跟new出来的对象也是不同的</strong></li></ol><blockquote><p>举例：<br>Integer i = 12; // 这个常量池中的<br>Integer j = new Integer(12) // 这个是堆中创建的<br>i == j 这时返回的是false</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="">https://www.cnblogs.com/wang-yaz/p/8516151.html</a></p><p><a href="">https://www.cnblogs.com/dolphin0520/p/3780005.html</a></p><blockquote><p><strong>这两篇文章从源码以及jvm分析了原理，并且写的很好，我就不再说明了。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法区</title>
      <link href="/2020/06/20/java/jvm/2-7/"/>
      <url>/2020/06/20/java/jvm/2-7/</url>
      
        <content type="html"><![CDATA[<h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法区</title>
      <link href="/2020/06/19/java/jvm/2-6/"/>
      <url>/2020/06/19/java/jvm/2-6/</url>
      
        <content type="html"><![CDATA[<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><ul><li>方法区（Method Area）和Java堆一样，是各个线程共享的内存区域。</li><li>《Java虚拟机规范》当中把方法区描述为堆的一个逻辑部分，但是它有一个别名叫<strong>“非堆”</strong>，目的是与Java堆区分开来。</li><li>jdk7以前，把方法区称为永久代。jdk8开始，使用元空间取代了永久代。</li></ul><blockquote><p>jdk7把原本存放在永久代的字符串常量池，静态变量等移到了堆中，直到jdk8才用元空间（Metaspace）替代了永久代，元空间在本地内存中。之所以放入本地内存我感觉就是加大了方法区的内存，避免了很多由于类加载过多导致的OOM。</p></blockquote><ul><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，就会导致OOM。</li><li>方法区同样存在垃圾收集。</li></ul><blockquote><p>这个垃圾收集的条件很苛刻也就为什么说是永久代一样，永久存在了，后续说明。</p></blockquote><h2 id="方法区大小设置"><a href="#方法区大小设置" class="headerlink" title="方法区大小设置"></a>方法区大小设置</h2><p><strong>jdk7以前：</strong></p><ul><li><p>-XX:PermSize来设置永久代初始内存大小 默认20.75M</p></li><li><p>-XX:MaxPermiSize来设置永久代最大可分配空间。32位机器默认64M，64位机器82M</p></li></ul><blockquote><p>JVM加载的类信息容量超出最大值会报OutOfMemoryError:PermGen space</p></blockquote><p><strong>jdk8以后：</strong></p><ul><li>-XX:MetspaceSize和-XX:MaxMetaspaceSize设置元数据区大小。</li></ul><blockquote><p>windows下，-XX:MetspaceSize 默认为21M，-XX:MaxMetaspaceSize默认为<strong>-1</strong>就是没有限制。(这个-1我参考网上的都说的-1，但是我看自己的程序的默认参数不是-1。反正这个了解就好，没必要去记这个)</p><p>内存溢出错误<strong>java.lang.OutOfMemoryError:Metaspace</strong></p></blockquote><p><img src="https://image.cclblog.cn/blog/20200619153032.png" alt=""></p><h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><p>方法区保存着被加载过的每一个类的信息，这些信息由类加载器在加载类的时候，从类的源文件抽取出来。</p><blockquote><p>方法区保存的起始就是每个类的一个模板，Class的元数据。</p></blockquote><p><strong>这些信息有：</strong></p><p><img src="https://image.cclblog.cn/blog/20200619202435.png" alt=""></p><blockquote><p><strong>这些信息没有一个统一的标准，网上说什么的都有，这是我自己综合整理，我感觉这个比较全面。仅供参考啊</strong></p></blockquote><h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>对于每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p><ul><li>类的完整有效名称（包名.类名）</li></ul><blockquote><p>比如java.lang.String</p></blockquote><ul><li><p>类的直接父类的完整有效名</p></li><li><p>类型直接实现接口的有序列表</p></li></ul><blockquote><p>一个类实现的接口可能有多个，多以存放在有序列表中。</p></blockquote><ul><li>类的修饰符</li></ul><blockquote><p>比如public abstract</p></blockquote><hr><blockquote><p>这个就像是查户口一样，看一下你家的详细地址（类的完整有效名称），你的父亲是谁（父类完整有效名称），你的工作（你实现的哪些接口），还有你是什么人（类的修饰符）。</p></blockquote><h3 id="字段信息"><a href="#字段信息" class="headerlink" title="字段信息"></a>字段信息</h3><ul><li>字段修饰符（public、protect、private、default）</li><li>字段声明的顺序</li><li>字段的类型</li><li>字段的名称</li></ul><h3 id="方法信息"><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h3><ul><li>方法名称</li><li>方法的返回类型（包括void）</li><li>方法参数的类型、数目和顺序</li><li>方法的修饰符（public、private、protected、static、final、synchronized、native、abstract）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外）</li></ul><blockquote><p>前面从未说过异常表这次详细分析</p><p>包括异常处理的<strong>开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获异常类的常量池索引</strong></p></blockquote><p><img src="https://image.cclblog.cn/blog/20200619164030.png" alt=""></p><h3 id="类的常量池-运行时常量池"><a href="#类的常量池-运行时常量池" class="headerlink" title="类的常量池/运行时常量池"></a>类的常量池/运行时常量池</h3><p><img src="https://image.cclblog.cn/blog/20200619173204.png" alt=""></p><h4 id="类常量池-静态常量池"><a href="#类常量池-静态常量池" class="headerlink" title="类常量池(静态常量池)"></a>类常量池(静态常量池)</h4><p><img src="https://image.cclblog.cn/blog/20200619180101.png" alt=""></p><ul><li>class常量池用于存储编译器生成的各种<strong>字面量</strong>和<strong>符号引用</strong>。 </li></ul><p><img src="https://image.cclblog.cn/blog/20200619201759.png" alt=""></p><blockquote><p>红色的这几个我仅仅了解，无法说清楚，待我日后补充，其它的三种是网上常见的，并且只有这三种，基本上都是这样，我是参考《深入理解Java虚拟机》第三版 p218。</p></blockquote><ul><li>每个class文件都有一个class常量池。</li></ul><h4 id="运行时常量池-动态常量池"><a href="#运行时常量池-动态常量池" class="headerlink" title="运行时常量池(动态常量池)"></a>运行时常量池(动态常量池)</h4><ul><li>方法区的一部分</li><li>常量池表是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。</li><li>运行时常量池包含多种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里变为了真实地址。</li></ul><blockquote><p>实际上在解析阶段只有能确定唯一版本的方法才能将符号引用直接替换为直接引用，这里也就是前面的章节说过的非虚方法。</p><p>Byte，Short，Integer，Long，Character，Boolean这5中包装类默认创建了数值[-128,127]的相应类型的缓存数据，但是超过此范围仍然回去创建新的对象。这也就是包装类比较是否相等要使用equals()。（Double，Float没有实现常量池技术）</p></blockquote><ul><li>运行时常量池相对于Class文件常量池的另外一个特征就是具备动态性。</li></ul><blockquote><p>String.intern()方法 </p></blockquote><h3 id="非final修饰的类变量"><a href="#非final修饰的类变量" class="headerlink" title="非final修饰的类变量"></a>非final修饰的类变量</h3><ul><li>静态变量和类是关联在一起的，随着类的加载而加载。</li><li>类变量被类的所有实例共享，即使没有类实例时也可以访问。</li></ul><blockquote><p><strong>final型变量的值是在编译期就被确定了，因此被保存在常量池中。</strong></p></blockquote><h3 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h3><ul><li><p>jvm必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么jvm会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。</p></li><li><p>jvm在动态链接的时候需要这个信息。当解析一个类型到另一个类型的引用的时候，jvm需要保证这两个类型的类加载器是相同的。这对jvm区分名字空间的方式是至关重要的。</p></li><li><p>比较两个类是否相等也需要比较类加载器是否是相同的。</p></li><li><p>垃圾收集的时候也需要参考这个类的加载器是否不再使用！</p></li></ul><h3 id="对Class类的引用"><a href="#对Class类的引用" class="headerlink" title="对Class类的引用"></a>对Class类的引用</h3><p>jvm为每个加载的类都创建一个java.lang.Class的实例（<strong>存储在堆上</strong>）。而jvm必须以某种方式把Class的这个实例和存储在方法区中的类型数据联系起来， 因此，类的元数据里面保存了一个Class对象的引用；</p><h3 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h3><blockquote><p><strong>引用：</strong></p><p>为了提高访问效率，必须仔细的设计存储在方法区中的数据信息结构。除了以上讨论的结构，jvm的实现者还可以添加一些其他的数据结构，如方法表。jvm对每个加载的非虚拟类的类型信息中都添加了一个方法表，方法表是一组对类实例方法的直接引用(包括从父类继承的方法。jvm可以通过方法表快速激活实例方法。(译者：这里的方法表与C++中的虚拟函数表一样，但java方法全都 是virtual的，自然也不用虚拟二字了。正像java宣称没有 指针了，其实java里全是指针。更安全只是加了更完备的检查机制，但这都是以牺牲效率为代价的,个人认为java的设计者 始终是把安全放在效率之上的，所有java才更适合于网络开发)</p></blockquote><h2 id="栈、堆、方法区的交互"><a href="#栈、堆、方法区的交互" class="headerlink" title="栈、堆、方法区的交互"></a>栈、堆、方法区的交互</h2><p><img src="https://image.cclblog.cn/blog/20200619211848.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java修饰符大全</title>
      <link href="/2020/06/18/java/javase/3/"/>
      <url>/2020/06/18/java/javase/3/</url>
      
        <content type="html"><![CDATA[<h1 id="Java修饰符大全"><a href="#Java修饰符大全" class="headerlink" title="Java修饰符大全"></a>Java修饰符大全</h1><ul><li>访问修饰符</li><li>非访问修饰符</li></ul><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><ul><li><strong>public：</strong>公有访问。对所有类都可见。</li><li><strong>protected：</strong>保护型访问，对同一个包可见，<strong>对不同的包的子类不可见</strong>。</li><li><strong>default：</strong>默认访问权限。只对同一个包可见，<strong>注意对不同的包的子类不可见</strong>。</li><li><strong>private：</strong>私有访问。只对同一个类可见，其余都不可见。</li></ul><blockquote><p><strong>这里也就注意一下default默认和protected对不同包的子类是否可见。</strong></p></blockquote><table><thead><tr><th>修饰符</th><th>同类</th><th>同包</th><th>子类</th><th>其它包</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>default</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h2 id="非权限访问修饰符"><a href="#非权限访问修饰符" class="headerlink" title="非权限访问修饰符"></a>非权限访问修饰符</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>static关键字可以用来修饰类（静态内部类）、方法（静态方法）、变量（静态变量）和代码块（静态代码块）。</strong></p><ul><li><p><strong>修饰类</strong></p><p><strong><a href="/2020/06/30/java/javase/6">Java中的内部类</a></strong></p></li><li><p><strong>修饰方法</strong></p></li></ul><ol><li>静态方法可以直接通过类名调用，任何的实例也都可以调用。</li></ol><blockquote><p><strong>new 一个对象的实例同样可以调用这个静态方法。</strong></p></blockquote><ol start="2"><li>静态方法中不能用this和super关键字。</li></ol><blockquote><p>学过jvm的就知道，静态方法的局部变量表中都没有this，所以不能使用。</p><p>this表示这个类的当前实例，super表示父类的当前实例，static修饰的是类的一个级别的，肯定不能用this，和super。</p><p>这个原因和jvm具体的类加载内存分配有关，可以看我写的jvm那些，或者百度。</p></blockquote><ol start="3"><li>不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。</li></ol><ul><li><strong>修饰变量</strong></li></ul><ol><li>对于静态变量在内存中只有一个拷贝（节省内存），JVM只分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问，当然也可以通过对象来访问。</li></ol><blockquote><p>这个就像HashSet底层是HashMap的key来存储元素的吗，它的value是一个默认的值，这个PRESENT声明为静态类型，所有的value共用这个变量。不这样做的话也太浪费空间了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><strong>修饰代码块</strong></p><p><strong><a href="/2020/07/03/java/javase/18">new一个类初始化的顺序</a></strong></p></li></ul><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul><li>final修饰类、方法、属性！不能修饰抽象类，因为抽象类一般都是需要被继承的，final修饰后就不能继承了。</li><li>final修饰的方法不能被重写而不是重载！ </li><li>final修饰属性，此属性就是一个常量，不能被再次赋值！ </li><li>final也不能修饰接口，接口可以只能被public&amp;abstract修饰</li><li>final如果修饰的是基本类型的变量，那么这个变量就表示为一个常数，只能赋值一次，要么在定义时赋值，要么在初始化时赋值；final修饰应用类型的变量是，变量不能再次被赋值意思是变量的地址（引用）不可以被改变，当变量所指向的内容可以被改变。</li></ul><blockquote><p><strong>final关键字不能用来抽象类和接口（这个很重要）</strong>  </p></blockquote><p><strong>final关键字可以用来修饰类、方法、变量。</strong></p><ul><li><strong>修饰类(class)。</strong> </li></ul><ol><li>该类不能被继承。 </li><li>类中的方法不会被覆盖，因此默认都是final的。 </li><li>用途：设计类时，如果该类不需要有子类，不必要被扩展，类的实现细节不允许被改变，那么就设计成final类</li></ol><ul><li><strong>修饰方法(method)</strong> </li></ul><ol><li>该方法可以被继承，但是不能被覆盖。</li><li>用途：一个类不允许子类覆盖该方法，则用final来修饰 </li><li>好处：可以防止继承它的子类修改该方法的意义和实现；更为高效，编译器在遇到调用final方法转入内嵌机制，提高了执行效率。 </li><li><strong>注意：</strong>父类中的private成员方法不能被子类覆盖，因此，private方法默认是final型的(可以查看编译后的class文件)</li></ol><ul><li><strong>修饰变量(variable)</strong> </li></ul><ol><li>用final修饰后变为常量。包括静态变量、实例变量和局部变量这三种。</li><li><strong>特点：</strong>可以先声明，不给初值，这种叫做final空白。但是使用前必须被初始化。一旦被赋值，将不能再被改变。</li></ol><blockquote><p>final修饰基本数据类型那基本数据类型的值就不能修改，要是引用数据类型指的是指向这个引用数据类型的地址不能被修改，但是这个引用数据类型中的数据是可以被修改的。</p></blockquote><ul><li><strong>修饰参数(arguments)</strong> </li></ul><ol><li>用final修饰参数时，称为最终参数，可以读取该参数，但是不能对其作出修改。</li></ol><h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p><strong>abstract可以用来修饰类（抽象类），和方法（抽象方法）。</strong></p><ul><li><strong>修饰类</strong></li></ul><ol><li>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</li></ol><blockquote><p><strong>抽象类不能实例化！！！！！！！！！！！！！！！！</strong></p></blockquote><ol start="2"><li>可以被继承。可以被抽象类继承，也可以被非抽象类继承。派生类可以实现抽象方法，并且也必须实现，除非是派生类也是抽象类。</li><li>抽象类不一定包含抽象方法，但是有抽象方法的类必定是抽象类。抽象类中既可以有抽象方法，也可以有普通方法。</li><li><strong>构造方法和类方法，不能声明为抽象方法。</strong></li></ol><ul><li><strong>修饰方法</strong></li></ul><ol><li>抽象方法只包含一个方法名，而没有方法体。</li><li>抽象方法没有定义，<strong>方法名后面直接跟一个分号，而不是花括号。</strong></li></ol><blockquote><p><strong>一个非抽象类继承abstract类必须实现其中的抽象方法，那么注意这个final关键字不可能和这个abstract一块使用。</strong></p></blockquote><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>用于多线程的同步。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>修饰的成员变量防止指令重排序，保持了这个变量在多线程间的可见性，不保证原子性。</p><blockquote><p>synchronized保证了多线程的顺序，可见和原子性。volatile不保证原子性。这里只是十分简单的说了一下这两个关键字。</p></blockquote><blockquote><p>这两个关键字的区别和具体在多线程中说明。太多了。。</p></blockquote><h3 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h3><p><strong>transient只能用来修饰变量。</strong></p><ul><li><strong>修饰变量</strong></li></ul><ol><li><p>一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</p></li><li><p>transient关键字只能修饰变量，而<strong>不能修饰方法和类</strong>。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。</p></li></ol><blockquote><p>成员变量(实例变量，属性)</p><p>局部变量（本地变量）</p><p>类变量（静态属性）</p></blockquote><ol start="3"><li>被transient关键字修饰的变量不再能被序列化，<strong>一个静态变量不管是否被transient修饰，均不能被序列化。</strong></li></ol><blockquote><p>静态变量属于类级别，不能被序列化。具体可以百度。</p></blockquote><h3 id="native"><a href="#native" class="headerlink" title="native"></a>native</h3><p>本地修饰符，指定此方法的方法体，是由其它语言在程序外部编写的。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识点总结</title>
      <link href="/2020/06/18/java/theme/javase/"/>
      <url>/2020/06/18/java/theme/javase/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础知识点"><a href="#Java基础知识点" class="headerlink" title="Java基础知识点"></a>Java基础知识点</h1><h2 id="1、重载和重写（√）"><a href="#1、重载和重写（√）" class="headerlink" title="1、重载和重写（√）"></a><a href="/2020/06/16/java/javase/1">1、重载和重写（√）</a></h2><h2 id="2、面向对象三大特性：继承、封装、多态（√）"><a href="#2、面向对象三大特性：继承、封装、多态（√）" class="headerlink" title="2、面向对象三大特性：继承、封装、多态（√）"></a><a href="/2020/06/17/java/javase/2">2、面向对象三大特性：继承、封装、多态（√）</a></h2><h2 id="3、Java中修饰符大全（√）"><a href="#3、Java中修饰符大全（√）" class="headerlink" title="3、Java中修饰符大全（√）"></a><a href="/2020/06/18/java/javase/3">3、Java中修饰符大全（√）</a></h2><h2 id="4、StringBuffer与StringBuilder（√）"><a href="#4、StringBuffer与StringBuilder（√）" class="headerlink" title="4、StringBuffer与StringBuilder（√）"></a><a href="/2020/07/02/java/javase/4">4、StringBuffer与StringBuilder（√）</a></h2><h2 id="5、自动装箱与拆箱（√）"><a href="#5、自动装箱与拆箱（√）" class="headerlink" title="5、自动装箱与拆箱（√）"></a><a href="/2020/06/20/java/javase/5">5、自动装箱与拆箱（√）</a></h2><h2 id="6、Java中的内部类（√）"><a href="#6、Java中的内部类（√）" class="headerlink" title="6、Java中的内部类（√）"></a><a href="/2020/06/30/java/javase/6">6、Java中的内部类（√）</a></h2><h2 id="7、-与equals"><a href="#7、-与equals" class="headerlink" title="7、==与equals()"></a>7、==与equals()</h2><h2 id="8、值传递与引用传递"><a href="#8、值传递与引用传递" class="headerlink" title="8、值传递与引用传递"></a>8、值传递与引用传递</h2><h2 id="9、Java中异常体系结构"><a href="#9、Java中异常体系结构" class="headerlink" title="9、Java中异常体系结构"></a>9、Java中异常体系结构</h2><h2 id="10、深拷贝与浅拷贝"><a href="#10、深拷贝与浅拷贝" class="headerlink" title="10、深拷贝与浅拷贝"></a>10、深拷贝与浅拷贝</h2><h2 id="11、Lambda表达式（√）"><a href="#11、Lambda表达式（√）" class="headerlink" title="11、Lambda表达式（√）"></a><a href="/2020/06/30/java/javase/11">11、Lambda表达式（√）</a></h2><h2 id="12、泛型"><a href="#12、泛型" class="headerlink" title="12、泛型"></a>12、泛型</h2><h2 id="13、深入理解i-与-i"><a href="#13、深入理解i-与-i" class="headerlink" title="13、深入理解i++与++i"></a>13、深入理解i++与++i</h2><h2 id="14、反射"><a href="#14、反射" class="headerlink" title="14、反射"></a>14、反射</h2><h2 id="15、成员变量和局部变量（√）"><a href="#15、成员变量和局部变量（√）" class="headerlink" title="15、成员变量和局部变量（√）"></a><a href="/2020/06/21/java/javase/15">15、成员变量和局部变量（√）</a></h2><h2 id="16、Java中各种特殊计算符"><a href="#16、Java中各种特殊计算符" class="headerlink" title="16、Java中各种特殊计算符"></a>16、Java中各种特殊计算符</h2><h2 id="17、接口与抽象类的区别（√）"><a href="#17、接口与抽象类的区别（√）" class="headerlink" title="17、接口与抽象类的区别（√）"></a><a href="/2020/06/29/java/javase/17">17、接口与抽象类的区别（√）</a></h2><h2 id="18、new一个类初始化的顺序（√）"><a href="#18、new一个类初始化的顺序（√）" class="headerlink" title="18、new一个类初始化的顺序（√）"></a><a href="/2020/07/03/java/javase/18">18、new一个类初始化的顺序（√）</a></h2>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机栈</title>
      <link href="/2020/06/17/java/jvm/2-3/"/>
      <url>/2020/06/17/java/jvm/2-3/</url>
      
        <content type="html"><![CDATA[<h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><ul><li>本地方法栈与虚拟机栈所发挥的作用是非常相似的，区别就是虚拟机栈执行Java方法，本地方法栈为本地（Native）方法服务。</li></ul><blockquote><p>native方法是Java通过JNI（java native interface）直接调用本地C/C++库，这个就相当于C/C++暴露给Java的一个接口，Java 通过调用这个接口从而调用到 C/C++ 方法。</p></blockquote><ul><li>本地方法栈线程私有的。</li><li>本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。</li><li>它的具体做法就是本地方法栈登记native方法，在执行引擎执行时候加载本地方法库。</li></ul><blockquote><p>当调用的是 native 方法时，虚拟机会保持 Java 虚拟机栈不变，也不会向 Java 虚拟机栈中压入新的栈帧，虚拟机只是简单地动态连接并直接调用指定的 native 方法</p></blockquote><ul><li><strong>Hotspot虚拟机中，直接将本地方法栈和虚拟机栈合二为一。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆</title>
      <link href="/2020/06/17/java/jvm/2-5/"/>
      <url>/2020/06/17/java/jvm/2-5/</url>
      
        <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><ul><li>Java堆是虚拟机所管理内存最大的一块区域，并且一个JVM实例只有一个堆，堆是Java内存管理的核心区域。</li><li>Java堆是被所有线程共享的，但是Java堆中还可以划分线程私有的缓冲区（Thread Local Allocation Buffer， TLAB），用来提高对象分配时的效率。</li><li><strong>Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</strong></li><li>Java的程序中，“几乎”所有的对象实例都在这里分配内存。</li></ul><blockquote><p>这里有特殊情况 逃逸分析技术的日渐强大 <strong>栈上分配、标量替换</strong>（后续说明）导致了”几乎”这一情况的发生</p></blockquote><ul><li>方法结束后，堆中的对象不会马上移除，仅仅在垃圾收集的时候才会被移除。</li><li>堆是垃圾收集的重点对象。</li></ul><p><img src="https://image.cclblog.cn/blog/20200617172417.png" alt=""></p><h2 id="堆空间内部结构"><a href="#堆空间内部结构" class="headerlink" title="堆空间内部结构"></a>堆空间内部结构</h2><p><img src="https://image.cclblog.cn/blog/20200617174629.png" alt=""></p><blockquote><p>我认为之所以这种分代设置都是为了方便垃圾收集，基于分代思想，一个应用程序中对象的声明周期不尽相同，每次垃圾回收肯定不能堆空间全部扫描，这样效率太低了，所以才有了对象分代这个思想，不是为了分代而分代，而是为了程序更好的性能，就像不是为了多线程而去盲目使用多线程，而是根据实际情况来使用，一切都要考虑实际情况。</p></blockquote><p><strong>这里不讨论永久代（元空间）！</strong></p><h3 id="年轻代、老年代"><a href="#年轻代、老年代" class="headerlink" title="年轻代、老年代"></a>年轻代、老年代</h3><blockquote><p>存储在JVM中的Java对象有两类：</p><ol><li>一类是生命周期特别短，就像是你写的普通方法中声明的局部变量，大部分都是这样的情况，这类对象创建和消亡都十分迅速。</li><li>另一类对象的声明周期十分的长，这样的对象一般存放在老年代。</li></ol></blockquote><ul><li>几乎所有的Java对象都是在Eden区被new出来的。</li><li>绝大部分的Java对象的销毁都是在新生代进行的。</li><li>“-Xmn参数可以设置新生代最大内存大小”</li></ul><h2 id="设置堆内存大小"><a href="#设置堆内存大小" class="headerlink" title="设置堆内存大小"></a>设置堆内存大小</h2><ul><li>堆的大小在JVM启动时就已经设定好了，可以通过选项“-Xmx”和“-Xms”来进行设置。</li></ul><blockquote><p>“-Xms”用于表示堆区的起始内存，等价于-XX:InittalHeapSize</p><p>“-Xmx”用于表示堆区的最大内存，等价于-XX:MaxHeapSize</p></blockquote><ul><li><p>堆中的内存大小超过“-Xmx“指定的最大内存的时候，就会抛出OutOfMemoryError异常。</p></li><li><p><strong>一般会将-Xms和-Xmx两个参数配置相同的值，目的是为了能够在java垃圾回收机制清理完堆区后不需要重新计算堆区的大小，从而提高性能。</strong></p></li><li><p>默认情况下，初始内存大小：物理电脑内存大小/64；最大内存大小：物理电脑内存大小/4；</p></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Test&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Test());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/blog/20200617181558.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200617181719.png" alt=""></p><blockquote><p>这个结果很明显了正常情况下程序肯定不会OOM -Xms -Xmx 改变了堆的大小，导致这一情况发生。</p></blockquote><h2 id="对象分配的过程"><a href="#对象分配的过程" class="headerlink" title="对象分配的过程"></a>对象分配的过程</h2><ol><li>new的对象先放到Eden区，如果超大对象直接分配到老年代。</li><li>当Eden区空间填满时，创建新的对象，就会触发JVM的垃圾回收机制，对新生区进行垃圾回收（Minor GC），然后在加载新的对象放到Eden区。</li><li>将Eden区中剩余的对象移动到幸存者0区。</li><li>如果再次触发垃圾回收机制，幸存的对象（包括幸存者0区的对象）会全部放入幸存者1区。如此反复</li><li>当一个对象经历15次这样的操作后，历经磨难，就会进入养老区。</li></ol><blockquote><p>15次只是JVM一个默认值，-XX:MaxTenuringThreshold= 这个参数可以设置 15次在Hotspot虚拟机中是最大值。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200617182949.png" alt=""></p><blockquote><p>上面的描述实际上很不全面，你有可能会想：</p><p><strong>进行垃圾回收之后Eden还是空间不足怎么办？</strong></p><p><strong>垃圾回收后将存活的对象移动到其中的一个幸存区的时候内存不够怎么办？</strong></p><p><strong>新对象难道必须经过15次洗礼才能进入到老年区养老吗？</strong></p><p>利用具体的流程图来解释</p></blockquote><p><strong>具体的流程图：</strong></p><p><img src="https://image.cclblog.cn/blog/20200617203602.png" alt=""></p><blockquote><p>这个图算是比较详细的，解释了上面的几个问题。</p></blockquote><h2 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h2><p>JVM在进行GC的时候，肯定不是这三个区域一块回收，要是这样分代有什么意义。大部分回收的是新生代。</p><hr><p>Minor GC/Young GC：只是新生代的垃圾收集。</p><p>Major GC/Old GC：只是老年代的垃圾收集</p><blockquote><p>只有CMS GC会有单独收集老年代的行为。其它的情况就是Full GC。</p><p>还有一种混合收集（Mined GC）只有G1会有这种行为，G1这个垃圾收集器组成很特殊。</p></blockquote><p>Full GC：收集整个java堆和方法区的垃圾。</p><h3 id="GC触发机制"><a href="#GC触发机制" class="headerlink" title="GC触发机制"></a>GC触发机制</h3><h4 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h4><ol><li>当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor区满不会触发GC。Survivor区只能等待Eden区被动清理。这个清理会清理整个新生代。</li><li>Minor GC十分频繁（这里的频繁是相对来说的），回收速度非常快。</li><li>Minor GC会导致STW，暂停用户线程，等待垃圾回收结束，用户线程才恢复运行。</li></ol><h4 id="Major-GC、Full-GC"><a href="#Major-GC、Full-GC" class="headerlink" title="Major GC、Full GC"></a>Major GC、Full GC</h4><ol><li>出现Major GC，一般会伴随至少一次的Minor GC（大部分垃圾收集器都是这样Parallel Scavenge这个比较特殊）。</li><li>如果Major GC后内存还不足，那就完蛋，直接OOM。</li><li>Major GC 很慢，STW时间很长（相对Minor GC）。</li></ol><h2 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>对象的创建在堆中十分频繁，因为堆是线程共享的，在并发的环境下在堆区中划分内存空间是线程不安全的，为了避免多个线程操作同一地址，需要使用加锁的机制，这导致了分配速度有所影响，但是TLAB是堆中开辟的每个线程私有的，就缓解了这个问题。</p><blockquote><p>上面之所以说的缓解是因为并不是全部的对象都是这种方式分配内存的，也不可能这样，这个TLAB的空间非常小，仅仅为Eden空间的1%，-XX:TLABWasteTargetPercent可以设置，虽然只是缓解，但是这也是JVM分配内存的一个首选方式。</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p><strong>TLAB是JVM为每个线程分配的一个私有缓存区域，这个区域在Eden空间内。</strong></p></li><li><p>TLAB快速分配内存，这种内存分配方式称为<strong>快速分配策略。</strong></p></li><li><p>-XX:UseTLAB 设置是否开启TLAB。</p></li><li><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p></li></ul><blockquote><p>分配内存的方式在垃圾那章节说明！</p></blockquote><h2 id="堆空间各种参数总结"><a href="#堆空间各种参数总结" class="headerlink" title="堆空间各种参数总结"></a>堆空间各种参数总结</h2><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>-XX: +PrintFlageInitial</td><td>查看所有的参数的默认初始值</td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>设置新生代对象最大年龄</td></tr><tr><td><strong>-Xms</strong></td><td>初始堆空间内存（默认本机物理内存1/64）</td></tr><tr><td><strong>-Xmx</strong></td><td>最大堆空间内存（默认本机物理内存1/4）</td></tr><tr><td>-Xmn</td><td>设置新生代大小</td></tr><tr><td>-XX:NewRatio</td><td>配置新生代与老年代在堆结构的占比</td></tr><tr><td>-XX:SurvivorRatio</td><td>设置新生代中Eden和s0/s1空间比例</td></tr><tr><td><strong>-XX:+PringGCDetails</strong></td><td>输出详细的GC处理日志</td></tr><tr><td>-XX:HandlePromotionFailure</td><td>是否设置空间分配担保（具体百度这个参数我仅仅了解）</td></tr></tbody></table><h3 id="jinfo查看默认参数"><a href="#jinfo查看默认参数" class="headerlink" title="jinfo查看默认参数"></a>jinfo查看默认参数</h3><p><img src="https://image.cclblog.cn/blog/20200617222501.png" alt=""></p><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>这个博客写的不错：我确实对这个理解不够，不做总结。</p><p><a href="https://www.jianshu.com/p/580f17760f6e" target="_blank" rel="noopener">https://www.jianshu.com/p/580f17760f6e</a> </p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><blockquote><p>平常写代码的时候能使用局部变量的，就不要使用在方法外定义。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC</title>
      <link href="/2020/06/17/java/theme/juc/"/>
      <url>/2020/06/17/java/theme/juc/</url>
      
        <content type="html"><![CDATA[<h1 id="AQS解析"><a href="#AQS解析" class="headerlink" title="AQS解析"></a>AQS解析</h1><h2 id="ReentrantLock加锁过程（√）"><a href="#ReentrantLock加锁过程（√）" class="headerlink" title="ReentrantLock加锁过程（√）"></a><a href="/2020/07/16/java/juc/reentrantLock-lock">ReentrantLock加锁过程（√）</a></h2><h2 id="ReentrantLock解锁过程（√）"><a href="#ReentrantLock解锁过程（√）" class="headerlink" title="ReentrantLock解锁过程（√）"></a><a href="/2020/07/20/java/juc/reentrantLock-unlock">ReentrantLock解锁过程（√）</a></h2><h2 id="ReentrantReadWriteLock共享部分加锁过程"><a href="#ReentrantReadWriteLock共享部分加锁过程" class="headerlink" title="ReentrantReadWriteLock共享部分加锁过程"></a>ReentrantReadWriteLock共享部分加锁过程</h2><h2 id="ReentrantReadWriteLock共享部分解锁过程"><a href="#ReentrantReadWriteLock共享部分解锁过程" class="headerlink" title="ReentrantReadWriteLock共享部分解锁过程"></a>ReentrantReadWriteLock共享部分解锁过程</h2><h2 id="await-过程"><a href="#await-过程" class="headerlink" title="await()过程"></a>await()过程</h2><h2 id="signal-过程"><a href="#signal-过程" class="headerlink" title="signal()过程"></a>signal()过程</h2><h1 id="JUC常用工具类"><a href="#JUC常用工具类" class="headerlink" title="JUC常用工具类"></a>JUC常用工具类</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="ThrealPool"><a href="#ThrealPool" class="headerlink" title="ThrealPool"></a>ThrealPool</h2><h2 id="TreadLocal"><a href="#TreadLocal" class="headerlink" title="TreadLocal"></a>TreadLocal</h2><h2 id="……"><a href="#……" class="headerlink" title="……"></a>……</h2>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> JAVA </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> JAVA </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承、封装、多态</title>
      <link href="/2020/06/17/java/javase/2/"/>
      <url>/2020/06/17/java/javase/2/</url>
      
        <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h3 id="概念（is-a）"><a href="#概念（is-a）" class="headerlink" title="概念（is-a）"></a>概念（is-a）</h3><p>继承是类与类之间的一种关系，继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><h3 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h3><ul><li>子类拥有父类非private的属性、方法。</li><li>子类可以拥有自己的属性和方法，也就是子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（重写）</li><li><strong>Java中类只能单继承；接口可以多继承</strong></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">god</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"女娲创造了人类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person吃饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person睡觉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Man狼吞虎咽的吃饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Man负责挣钱"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">god</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"什么女娲创造了人类？"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Woman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Woman</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spendMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Woman负责花钱"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Man(<span class="string">"伏羲"</span>, <span class="number">11</span>);</span><br><span class="line">        person1.eat(); <span class="comment">// man 中重写了person中的eat方法</span></span><br><span class="line">        Man man = <span class="keyword">new</span> Man(<span class="string">"男人"</span>, <span class="number">20</span>);</span><br><span class="line">        man.makeMoney();</span><br><span class="line">        man.god();</span><br><span class="line"></span><br><span class="line">        Woman woman = <span class="keyword">new</span> Woman(<span class="string">"女娲"</span>, <span class="number">12</span>);</span><br><span class="line">        woman.eat(); <span class="comment">// woman 中未重写调用的是person的eat</span></span><br><span class="line">        woman.spendMoney();</span><br><span class="line">        <span class="comment">//woman.god(); // 无法访问父类的私有方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/blog/20200627112158.png" alt=""></p><blockquote><ol><li><p>一个类中如果不声明构造函数，也会默认存在一个无参的构造函数，除非手动声明后，这个默认无参构造函数也就不存在了。</p></li><li><p>构造函数没有返回值，并且不能用void修饰符来修饰。</p></li><li><p>子类的构造函数中会默认调用父类的无参构造函数，如果父类中存在有参的构造函数，那么子类就需要显示的调用了。</p></li><li><p>注意super()和this()不能同时存在，它们是冲突的，并且都必须在第一行来进行调用。</p><p><strong>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</strong></p><p><strong>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</strong></p></li><li><p><strong>用父类来声明子类的时候，比如Person person = new Man()则person无法调用子类中特有的那些方法，编译器编译的时候默认的认为你这个类型就是Person类型的，虽然无法调用子类中特有的方法，但是重写这个特性还是存在的，如果子类重写了父类的方法，并不会去调用父类的方法，这个应该因为重写是动态分派的一种，在运行期才能决定调用哪个方法，编译阶段无法知道你具体调用的哪个方法，自然不会让你编译通过。</strong></p></li></ol></blockquote><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><blockquote><ul><li>我理解的继承就是使程序的设计变得简单了，它的一个最大的好处就是代码复用，我感觉有了继承这个属性，才是真正面向对象的灵魂，真正的抽象出生活中的各种模型，比如，人，男人，女人，都能吃饭，睡觉，但是男人与女人又有不同，通过继承可以非常好的对此进行描述，大大简化了程序的编写。</li><li>过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。为了了解一个类的功能，我们不仅需要查看这个类的代码，还需要按照继承关系一层一层地往上查看“父类、父类的父类……”的代码。还有，子类和父类高度耦合，修改父类的代码，会直接影响到子类。 <strong>多用组合少用继承。</strong> </li></ul></blockquote><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>封装就是把对象的属性和操作结合为一个独立的整体，并尽可能的隐藏对象内部的实现细节。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>良好的封装能够减少耦合。</li><li>类内部的结构可以自由的修改</li></ul><blockquote><p>封装就是你只管提供接口，就像打印机，我打印东西只需点击打印即可，具体的实现我不去管。<strong>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</strong></p></blockquote><ul><li>可以对成员变量进行更精确的控制。</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><blockquote><p>我认为封装就是给你提供接口，让你来使用，你无需知道具体的实现是怎么样的，比如你是一个付费用户，给你提供的接口功能就比免费用户多。不能破坏程序的封装性，破坏了你不是vip成员但是能够使用vip的功能，这个就不好了。</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>多态是同一个行为具有多个不同表现形式或形态的能力。</strong></p><blockquote><p>这个就好比，键盘的快捷键，相同的按键在不同的应用程序中体现出来的效果也不一样。</p><p>就比如ctrl + Y 在idea中是删除快捷键，在eclipse中就可能是别的操作了。</p></blockquote><p>这个多态和虚函数（我在jvm中详细说到这个虚函数非虚函数）。</p><h3 id="多态的三个必要条件"><a href="#多态的三个必要条件" class="headerlink" title="多态的三个必要条件"></a>多态的三个必要条件</h3><ol><li>继承</li><li>重写</li><li>父类引用指向子类对象</li></ol><blockquote><p>就像继承中的例子那样Person person = new Man()这样</p></blockquote><h3 id="重载与多态的区别（重载与多态无关）"><a href="#重载与多态的区别（重载与多态无关）" class="headerlink" title="重载与多态的区别（重载与多态无关）"></a>重载与多态的区别（重载与多态无关）</h3><ol><li>多态是建立在重写的基础之上的，是类与类之间的关系，是发生在不同的类之间的，子类重写父类的方法。实现不同的子类，不同的实现形态。</li><li>而重载是类的内部的方法构型上的不同，是发生在同一个类里面的。同一个函数名称，参数不同的多个方法，实现同一类型的功能。</li></ol><p>具体可以看：</p><p><a href="/java/javase/2020/06/16/1"><strong>重载和重写</strong></a></p><p><a href="/java/jvm/2020/06/16/2-2-1"><strong>深入理解重载和重写</strong></a></p><blockquote><p>知识点之间都是相关的，一开始学的时候只是知道有这个东西，然后随着慢慢的探索就会发现更深入的东西。</p></blockquote><h3 id="多态的表现形式"><a href="#多态的表现形式" class="headerlink" title="多态的表现形式"></a>多态的表现形式</h3><ol><li>重写</li><li>接口</li><li>抽象类抽象方法</li></ol><blockquote><p>这些都很好理解接口只是定义一些规则，每个实现接口的类，实现方式并不相同，抽象类也是这样，继承抽象类的，实现其中的抽象方法，肯定也不一定相同的。</p><p>比如：接口是非机动车靠边行驶。这个在中国的具体实现就是靠右行，在外国就不一定了。这个就是多态。</p></blockquote><h2 id="–"><a href="#–" class="headerlink" title="–"></a>–</h2><blockquote><p><strong>目前我对面向对象的理解还很浅显，或许几年过后，再回头看，会对面向对象有更深层次的理解。</strong></p><p>还有一个这里我没写封装，封装这个属性比较特殊，常常不被称为面向对象变成的<strong>特性</strong>。就是这个思想太过广泛。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重载与重写规则</title>
      <link href="/2020/06/16/java/javase/1/"/>
      <url>/2020/06/16/java/javase/1/</url>
      
        <content type="html"><![CDATA[<h1 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h1><ul><li><strong>被重载的方法必须改变参数列表(参数个数或类型不一样)；</strong></li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li><strong>无法以返回值类型作为重载函数的区分标准。</strong></li></ul><h1 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写(Override)"></a>重写(Override)</h1><ul><li><p><strong>参数列表必须完全与被重写方法的相同。</strong></p></li><li><p>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</p></li><li><p>访问权限不能比父类中被重写的方法的访问权限更低。</p><blockquote><p> 例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</p></blockquote></li><li><p>父类的成员方法只能被它的子类重写。</p></li><li><p>声明为 final 的方法不能被重写。</p></li><li><p>声明为 static 的方法不能被重写，但是能够被再次声明。</p></li><li><p>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</p></li><li><p>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</p></li><li><p>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</p></li><li><p>构造方法不能被重写。</p></li><li><p>如果不能继承一个方法，则不能重写这个方法。</p></li></ul><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><blockquote><p>重载：</p><ol><li>​    编译时的多态</li><li>​    重载发生在同一个类中</li><li>​    函数名相同，参数列表不同(参数的类型，顺序，个数 和参数名没有关系)  和方法的返回值类型无关   (因为编译器 并不知道 调用哪一个函数)</li><li>可以抛出不同的异常，可以有不同修饰符</li></ol><p>重写：</p><ol><li>​    运行时的多态</li><li>​    重载发生在子类与父类中</li><li>​    遵循两同两小一大 </li></ol><p>​            两同：</p><p>​                        函数名<strong>相同</strong></p><p>​                        参数列表<strong>相同</strong></p><p>​            两小：</p><p>​                        子类被重写方法的返回值类型<strong>小于</strong>父类被重写方法的返回值</p><p>​                        子类被重写方法抛出异常的类型<strong>小于</strong>父类被重写方法抛出异常的类型</p><p>​            一大：</p><p>​                        <strong>子类被重写方法的访问权限大于等于父类被重写方法的访问权限</strong></p><p>​        4.构造方法不能被重写，声明为 final 的方法不能被重写，声明为 static 的方法不能被重写（隐藏），但是能够被再次声明，父类的私有方法，子类可以继承 但是子类不能访问，子类不能重写父类的私有方法。</p></blockquote><table><thead><tr><th align="left">区别点</th><th align="left">重载方法</th><th align="left">重写方法</th></tr></thead><tbody><tr><td align="left">参数列表</td><td align="left">必须修改</td><td align="left">一定不能修改</td></tr><tr><td align="left">返回类型</td><td align="left">可以修改</td><td align="left">一定不能修改</td></tr><tr><td align="left">异常</td><td align="left">可以修改</td><td align="left">可以减少或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td align="left">访问</td><td align="left">可以修改</td><td align="left">一定不能做更严格的限制（可以降低限制）</td></tr></tbody></table><blockquote><p><strong>重载是静态分配的表现，重写则是动态分派的表现。</strong></p></blockquote><p><a href="/2020/06/16/java/jvm/2-2-1"><strong>深入理解重载和重写</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分派</title>
      <link href="/2020/06/16/java/jvm/2-2-1/"/>
      <url>/2020/06/16/java/jvm/2-2-1/</url>
      
        <content type="html"><![CDATA[<h1 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h1><h2 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h2><ul><li><p>所有依赖<strong>静态类型</strong>来决定方法执行版本的<strong>分派</strong>动作，都成为静态分派。</p></li><li><p>静态分配的最典型应用表现就是<strong>方法重载。</strong></p></li><li><p>静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。</p></li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Magpie</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(Bird bird)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是鸟！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(Sparrow human)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是鸟中的麻雀！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(Magpie human)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是鸟中的喜鹊！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bird sparrow = <span class="keyword">new</span> Sparrow();</span><br><span class="line">        Bird magpie = <span class="keyword">new</span> Magpie();</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.talk(sparrow);</span><br><span class="line">        test.talk(magpie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><blockquote><p>我是鸟！<br>我是鸟！</p></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><img src="https://image.cclblog.cn/blog/20200616205136.png" alt=""></p><blockquote><p>理解这个要明白<strong>重载是根据<code>静态类型</code>而不是<code>实际类型</code>来判断选择哪个方法的。</strong></p><p>Bird sparrow = new Sparrow();</p><p>这个Bird 称为变量的 <strong>“静态类型”</strong>，而Sparrow 则是 变量的 <strong>“实际类型”</strong>。变量本身的静态类型是不会发生变化的，在编译期是可知的，上图也说明了这一点，程序还未运行便知道要调用的方法。实际类型变化的结果是在运行期间才可以确定的。编译器在编译程序的时候并不知道一个对象的实际类型是什么。</p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void String(Object param) &#123;</span><br><span class="line">        System.out.println(&quot;object&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test(int param) &#123;</span><br><span class="line">        System.out.println(&quot;int&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test.test(&#39;a&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个代码输出什么？</strong></p><p><img src="https://image.cclblog.cn/blog/20200616210755.png" alt=""></p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><blockquote><p>这说明了重载的版本并不是唯一的，但是往往必须确定一个<strong>“相对更加合适的”</strong>版本。</p><p>‘a’是char类型，就去寻找char类型的重载方法，如果此方法不存在，他就会自动进行类型转换’a’也可以代表数字97。所以他就会去执行int类型的重载方法了。</p></blockquote><h2 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h2><ul><li>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</li></ul><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是鸟！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是鸟中的麻雀！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Magpie</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是鸟中的喜鹊！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bird sparrow = <span class="keyword">new</span> Sparrow();</span><br><span class="line">        Bird magpie = <span class="keyword">new</span> Magpie();</span><br><span class="line">        sparrow.talk();</span><br><span class="line">        magpie.talk();</span><br><span class="line">        sparrow = <span class="keyword">new</span> Magpie();</span><br><span class="line">        sparrow.talk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><blockquote><p>我是鸟中的麻雀！<br>我是鸟中的喜鹊！<br>我是鸟中的喜鹊！</p></blockquote><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><blockquote><p>显然重写不是根据静态类型确定调用哪个方法的，而是根据实际类型。子类重写了父类的方法不同的子类必然产生的动作不同，这肯定就不能依靠静态类型来确定了。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200616212607.png" alt=""></p><p><strong>分析main()方法中的字节码:</strong></p><p><img src="https://image.cclblog.cn/blog/20200616214243.png" alt=""></p><h4 id="invokevirtual"><a href="#invokevirtual" class="headerlink" title="invokevirtual"></a>invokevirtual</h4><p>运行时解析过程</p><ol><li><strong>找到操作数栈顶的第一个元素所指向的对象的实际类型，记做C</strong></li><li><strong>如果在类型C中找到与常量中描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；</strong>不通过则返回java.lang.IllegalAccessError异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstartMethodError异常。</li></ol><blockquote><p>这个说的很明白了，第1步不就找到实际类型吗！！<strong>这个过程就是Java语言中方法重写的本质。</strong></p></blockquote><p>既然这种多态性的根源是和invokevirtual这个指令有关，那么这个只能对方法生效对字段是无效的，因为字段并不使用这个指令，<strong>字段永远没有多态这个特性至少目前还没有(jdk14)</strong>。</p><h2 id="彻底理解多态"><a href="#彻底理解多态" class="headerlink" title="彻底理解多态"></a>彻底理解多态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> B().getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span> <span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">            setValue(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value= value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                value ++;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.setValue(value);</span><br><span class="line">                System.out.println(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(<span class="number">5</span>);</span><br><span class="line">            setValue(getValue()- <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.setValue(<span class="number">2</span> * value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看输出结果  </a><span class="hide-content">答案：22 34 17</span></span><p><strong>解析：</strong></p><p>​    <strong>执行对象实例化过程中遵循多态特性，调用的方法都是将要实例化的子类中的重写方法，只有明确调用了super.xxx关键词或者是子类中没有该方法时，才会去调用父类相同的同名方法。</strong></p><ol><li>new B()构造一个B类的实例</li><li>B的构造函数中super(5)中显示调用父类A的构造函数</li><li>执行A (int v) =&gt; setValue(v)</li><li>虽然构造函数是A类的构造函数，但此刻正在初始化的对象是B的一个实例，<strong>因此这里调用的实际是B类的setValue方法</strong>，于是调用B类中的setValue方法，而B类中setValue方法显示调用父类的setValue方法，将B实例的value值设置为2 x 5 = <strong>10</strong>。</li><li>至此super(5)这条语句执行完成，紧接着执行setValue(getValue() - 3)</li><li>由于B类中没有重写getValue方法，因此调用父类A的getValue方法。</li><li>value++ 此时B的成员变量value=11，<strong>11这个返回值会先暂存起来</strong>，return value，跳过，先执行finally中的方法。</li><li>this.setValue(value)；调用的是B类的setValue方法，因为此刻正在初始化的是B类的一个对象（运行时多态），然后super.setValue(11 * 2)这里显示调用A类的setValue方法，将B的value设置为了22</li><li>然后System.out.println(value) 因此第一个打印的值为22。</li><li>finally语句执行完毕，会把刚才暂存的11返回出去，也就是说这么经历了这些处理，getValue方法最终的返回值是11。</li><li>setValue(11 - 3) =&gt; setValue(8)</li><li>执行setValue(8)执行的肯定是B类的setValue方法，然后value就变成了16。</li><li>到此new B()构造完毕</li><li>然后执行new B().getValue()方法，B中不存在此方法，所以调用的是A类的此方法。</li><li>value++，B的成员变量value值为17，此时执行到return语句，先暂存，然后执行finally中语句，和之前原理一样，打印出34。</li><li>然后把value = 17返回出去，导致System.out.println(new B().getValue)就打印出17</li><li><strong>所以最终的打印结果就是22 34 17</strong></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序计数器</title>
      <link href="/2020/06/12/java/jvm/2-4/"/>
      <url>/2020/06/12/java/jvm/2-4/</url>
      
        <content type="html"><![CDATA[<h1 id="程序计数器（PC寄存器）"><a href="#程序计数器（PC寄存器）" class="headerlink" title="程序计数器（PC寄存器）"></a>程序计数器（PC寄存器）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>程序计数器是一个记录着当前线程所执行的字节码的行号指示器。</code></p><p>程序计数器（Program Counter Register）是一个非常小的空间，可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><p><strong>如果程序正在执行的是本地（Native）方法，这个计数器的值就为空（Undefined）。</strong>native方法是java通过JNI直接调用C/C++库，相当于C/C++暴露给java的一个接口，java调用这个接口就相当于C/C++去执行相应的代码，肯定不会产生相应的字节码，既然没有字节码，那程序计数器不就没得记录。</p></li><li><p><strong>线程私有，每个线程都存在一个程序计数器。</strong></p></li><li><p><strong>此内存区域是唯一一个不存在OOM情况的区域。</strong></p></li><li><p>占用内存非常小，可以忽略不计。</p></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后</p><p><img src="https://image.cclblog.cn/blog/20200612175746.png" alt=""></p><p>我是用的idea的Jclasslib插件进行反编译的，也可以使用javap来反编译。</p><p>这个类似于行号的就是字节码指令的地址，程序计数器中就是要记录这些地址。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li><strong>为什么使用程序计数器来记录当前线程的执行地址呢？（程序计数器的作用？）</strong></li></ol><blockquote><p>因为CPU需要不停的切换各个线程，这时候CPU切换回需要执行的线程后，就得知道接着从哪开始继续执行。</p><p>JVM的字节码解释器需要通过改变程序计数器的值来明确下一条应该执行什么样的字节码指令。</p></blockquote><ol start="2"><li><strong>程序计数器为什么被设定为线程私有？</strong></li></ol><blockquote><p>JVM的多线程是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的。也就是说，某个线程在执行过程中可能会因为时间片耗尽而被挂起，而另一个线程获取到时间片开始执行。当被挂起的线程重新获取到时间片的时候，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置，在JVM中，通过程序计数器来记录某个线程的字节码执行位置。因此，程序计数器是具备线程隔离的特性，也就是说，每个线程工作时都要有属于自己的独立计数器。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机栈</title>
      <link href="/2020/06/12/java/jvm/2-2/"/>
      <url>/2020/06/12/java/jvm/2-2/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>Java虚拟机栈线程私有，生命周期与线程相同。描述的是Java方法执行的线程内存模型。</p></li><li><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够内存会抛出OutOfMemoryError异常。</p></li></ul><blockquote><p>栈是运行时的单位，而堆是存储的单位。栈解决程序的运行问题，即程序如何执行，数据如何处理。堆解决的是数据的存储问题，即数据怎么放。</p><p>栈就好比你程序中的业务代码，而堆就是存储数据的数据库，数据一个程序是灵魂，如果数据不做处理、可视化，完全是死的数据，我认为是完全没有意义的。</p></blockquote><h3 id="设置栈的大小"><a href="#设置栈的大小" class="headerlink" title="设置栈的大小"></a>设置栈的大小</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码就会导致StackOverflowError异常。递归调用操作不当十分容易导致栈溢出。</p><p><img src="https://image.cclblog.cn/blog/20200613161704.png" alt=""></p><p>test2()这个方法执行了10271次才溢出，可以通过<code>-Xss</code>选项来设置线程的最大栈空间，这个栈空间的大小直接决定了函数的调用的最大深度。</p><p><img src="https://image.cclblog.cn/blog/20200613162335.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200613162909.png" alt=""></p><p>发现test2()方法只运行了541次，得出<code>-Xss</code>改变了栈空间的大小。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>栈是一种快速有效的分配方式，访问速度仅次于程序计数器。</li><li>对于栈来说不存在垃圾回收的问题。</li></ul><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p><strong>栈的存储单位就是栈桢。</strong></p><p>每个方法被执行的时候，java虚拟机都会同步创建一个栈桢用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法从被调用到执行完毕的过程，就对应着一个栈桢在虚拟机中从入栈到出栈的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个程序main()方法中调用test1()，test1()调用test2()，test2()调用test3()。</p></blockquote><p>将程序在test1()处打个断点，平时写代码调试的时候，经常接触栈栈桢，只是有可能不知道这是而已。</p><p><img src="https://image.cclblog.cn/blog/20200613164510.png" alt=""></p><p>然后步入接着执行程序</p><p><img src="https://image.cclblog.cn/blog/20200613164755.png" alt=""></p><p>继续步入执行</p><p><img src="https://image.cclblog.cn/blog/20200613165010.png" alt=""></p><p>test3()方法执行完毕后开始出栈。</p><p><img src="https://image.cclblog.cn/blog/20200613165154.png" alt=""></p><p>之后就是test2出栈test1出栈最后main出栈，程序执行结束。</p><p>这里如果调试的时候执行了下一步怎么返回上一步执行，退回去重新操作。idea提供了丢帧的操作。</p><p><img src="https://image.cclblog.cn/blog/20200613165543.png" alt=""></p><p>抛弃test1()后就回到main()这个栈桢了。</p><p><img src="https://image.cclblog.cn/blog/20200613172005.gif" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200613172046.gif" alt=""></p><blockquote><p>这个就像你写的程序一个方法中调用另一个方法，就相当于妈妈让你爸爸去买醋，然后你爸爸让你去买醋，你买回来后高速你爸爸我买回来了，然后就没你的事情了，然后你爸爸高速你妈妈，买回来了。。。当然你也可以直接告诉你妈妈，，但是程序不行啊。这就是一个入栈出栈的过程，如果你爸爸告诉你去买，你告诉你爸爸去买，无限循环，不就导致错误了吗。</p></blockquote><h2 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h2><ul><li>不同线程中包含的栈桢是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li><li>java方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用return命令；另外一种是抛出异常；</strong>不管使用哪种方式，都会导致栈帧被弹出。</li></ul><h2 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h2><ul><li><strong>局部变量表（*）</strong></li><li><strong>操作数栈（*）</strong></li><li>动态连接</li><li>方法返回地址</li><li>一些附加的信息</li></ul><p><img src="https://image.cclblog.cn/blog/20200613180052.png" alt=""></p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><ul><li><p>局部变量表(Local Variables Table)是一组变量值的存储空间，用于存放<strong>方法参数</strong>和<strong>方法内部定义的局部变量</strong>这些数据类型包括各大基本数据类型、对象引用（reference），以及returnAddress类型。</p><blockquote><p>基本数据类型无需多言，reference就是一个对象实例的引用。returnAddress是为了字节码指令jsr、jsr_w和ret服务的，指向一条字节码指令的地址，目前已经很少使用。</p></blockquote></li><li><p>由于局部变量表在栈帧之中，因此，如果函数的参数和局部变量很多，会使得局部变量表膨胀，因此，每一次函数调用，其局部变量表会占用更多的栈空间，最终导致函数的嵌套调用的次数减少。</p><blockquote><p><strong>栈大小固定，栈中存放栈帧，栈帧中有局部变量表，局部变量表存放局部变量，局部变量很多，占用空间就大，导致栈中可以存放的栈桢变少，自然函数嵌套的次数也就减少</strong></p></blockquote></li><li><p>局部变量表是建立在线程的栈上，是线程的私有数据，<strong>不存在数据安全问题。</strong></p></li><li><p><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，存储在方法的Code属性的maximum local variables数据项中。（后续会说明）在方法运行期间是不会改变局部变量表的大小的。</p></li></ul><blockquote><p>局部变量表中的容量的意思是你这个方法中有多少局部变量，和方法参数，这个肯定是确定的啊，在编译期间就确定的。你自己都能数一数一个方法中有多少变量和参数，更别说编译器了。</p></blockquote><ul><li>局部变量表中的变量只在当前方法中有效。当在方法执行的时候，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也随之销毁。</strong></li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">short</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> d = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">float</span> e = <span class="number">11.2F</span>;</span><br><span class="line">    <span class="keyword">double</span> f = <span class="number">1.1</span>;</span><br><span class="line">    <span class="keyword">char</span> g = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">boolean</span> i = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    String h = <span class="string">"aa"</span>;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析test1()方法的局部变量表：</strong></p><p><img src="https://image.cclblog.cn/blog/20200613220859.png" alt=""></p><p><strong>因为这是静态方法所以并不存在该对象的引用this，如果不是静态方法，index为0的位置就是隐藏的this。</strong></p><p><img src="https://image.cclblog.cn/blog/20200613222439.png" alt=""></p><h4 id="变量槽Slot"><a href="#变量槽Slot" class="headerlink" title="变量槽Slot"></a>变量槽Slot</h4><ul><li>局部变量表，最基本的存储单元是变量槽</li><li>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</li></ul><blockquote><p>byte、short、char在存储前会被转换为int，boolean也被转换为int，0为false，非0表示true。</p><p><strong>long和double占据两个变量槽。</strong></p></blockquote><ul><li>JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量的值。</li><li><strong>如果要访问局部变量表中的一个64bit（long、double）的局部变量值时，只需要使用前一个索引即可。这也是JVM规定必须的。</strong></li><li><strong>如果一个方法不是静态方法，那么该对象的引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。</strong></li><li><strong>变量槽（Slot）可以重复利用</strong></li></ul><h5 id="变量槽的重复利用"><a href="#变量槽的重复利用" class="headerlink" title="变量槽的重复利用"></a>变量槽的重复利用</h5><p>栈帧中的局部变量表中的槽位是可以重复利用的，如果一个局部变量出了它的作用域，那么在其作用域之后申明的局部变量就会复用过期局部变量的槽位，从而达到节省资源的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/blog/20200613224813.png" alt=""></p><blockquote><p>这个代码不是静态代码，所以肯定存在一个this这个对象的引用，为什么是2个槽位，而不是3个槽位，代码中b这个变量出了代码块后，这个变量槽就没必要存储它了，然后a也没必要在重开一个槽位，就相当于占用了b的槽位，把b替换了。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200613225335.png" alt=""></p><blockquote><p>这是你可能会想，如果a是long或者double类型的占用2个槽位，但是b只空出一个槽位，那该怎么算？如果这样的话，槽位就会变成3，而不是4，照样重用那个槽位，然后在添加上一个槽位就可以了。</p></blockquote><p> <img src="https://image.cclblog.cn/blog/20200614154741.png" alt=""></p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><ul><li><p>后入先出（Last In First Out）栈，也常被称作操作栈。</p></li><li><p>同局部变量表一样，操作数栈的最大深度也在编译的时候被写入Code属性的max_stacks数据项之中。</p></li><li><p>栈中的任何一个元素都是可以任意的Java数据类型。<strong>32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。</strong></p></li><li><p>操作数栈<strong>不是采用访问索引的方式来进行数据访问的</strong>，而是只能通过标准的入栈(push)和出栈(pop)操作来完成一次数据访问。</p></li><li><p>操作数栈中元素类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器必须严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。</p></li><li><p><strong>Java虚拟机的解释执行引擎被称为“基于栈的执行引擎”，里面的“栈”就是操作数栈。</strong></p></li></ul><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/blog/20200615162713.png" alt=""></p><p><strong>编译的时候局部变量表和操作数栈的大小和深度就是确定的。</strong></p><p><img src="https://image.cclblog.cn/blog/20200615164022.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164049.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164109.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164158.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164159.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164200.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164302.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164301.png" alt=""></p><h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><ul><li>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现<strong>动态连接。</strong></li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。比如：描述一个方法调用另外的其他方法时候，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态连接的作用就是为了将这些符号引用转换为调用方法的直接引用。</strong></li></ul><blockquote><p>具体描述在方法调用中说明。</p></blockquote><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><ul><li>方法调用阶段的唯一任务就是确定被调用方法到底是哪个方法。一切方法调用在Class文件里面存储的都只是<strong>符号引用</strong>，而不是<strong>方法在运行时内存布局中入口地址（这个就是直接引用）</strong>。</li><li>某些调用需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</li></ul><p><strong>例如</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"琦玉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main()方法中调用了test1()方法，它的字节码为</p><p><img src="https://image.cclblog.cn/blog/20200616155943.png" alt=""></p><p>在java虚拟机中支持以下5条方法调用字节码指令：</p><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td><strong>invokestatic</strong></td><td>用于调用静态方法</td></tr><tr><td><strong>invokespecial</strong></td><td>用于调用实例构造方法<code>&lt;init&gt;()</code>、私有方法和父类中的方法</td></tr><tr><td><strong>invokevirtual</strong></td><td>用于调用所有的<strong>虚方法</strong></td></tr><tr><td><strong>invokeInterface</strong></td><td>用于调用接口方法，会在运行时再确定一个实现该接口的对象</td></tr><tr><td><strong>invokedynamic</strong></td><td><strong>这个最为特殊，具体说明。</strong></td></tr></tbody></table><h4 id="虚方法、非虚方法"><a href="#虚方法、非虚方法" class="headerlink" title="虚方法、非虚方法"></a>虚方法、非虚方法</h4><ul><li>只要是能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，java语言里符合这个条件的方法有<strong>静态方法、私有方法、实例构造器、父类方法</strong>这4种，再加上被final修饰的方法（尽管它是使用invokevirtual指令调用），这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为<code>非虚方法</code>与之相反就是<strong>虚方法</strong>。</li></ul><blockquote><p>静态方法、私有方法、实例构造器、父类方法还有被final修饰的方法有一个共同的特点就是它们都不能通过继承或别的方式重写，之所以叫做非虚我认为就是十分确定的，你调用这些方法能特别肯定的，你的程序中只有一个地方有该方法，是十分确定的，不像有些方法可以重写，重载一样，你调用一个方法系统不知道调用哪个，必须等到程序真正运行调用的时候才能知道，虚无缥缈，所以就叫做虚方法了。</p></blockquote><h4 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h4><p><a href="/2020/06/12/2-2-1">通过分派彻底理解重载和重写</a></p><h4 id="invokedynamic"><a href="#invokedynamic" class="headerlink" title="invokedynamic"></a>invokedynamic</h4><ul><li><p>jdk7中增加的一个指令，<strong>这个指令是为了实现动态类型语言支持而做出的改进。</strong></p></li><li><p>每一处含有invokedynamic指令的位置都被称作“动态调用点”，虽然这个指令是jdk7引用的，但是并没有提供直接生成该指令的方法。<strong>直到java8中的Lambda表达式的出现，invokedynamic指令的生成，在java中才有了直接的生成方式。</strong></p></li></ul><p><strong>动态类型、静态类型语言</strong></p><p>动态语言的特征是它的类型检查的主体过程是在运行期间而不是编译期进行的（例如js、php、python等）相对的在编译期间就进行类型检查过程的语言，例如c++、java就是最常用的静态类型语言。</p><blockquote><p>a = 1; 这个语句在python中就可以执行，但是在java中就会报错，静态语言是对a变量的检查，而动态语言是对1这个值的检查，根据这个值来确定变量a的类型。一个运行时确定，一个编译期确定。</p></blockquote><p><strong>这两个类型的语言各自优点？</strong></p><blockquote><p><strong>静态语言：</strong>能够在编译期确定变量类型，十分严谨，利于系统的稳定性。</p><p><strong>动态语言：</strong>运行时才确定类型，十分灵活，并且静态类型花费很多代码才能实现的功能，动态语言可能很简洁就能实现，提高了开发的效率。</p></blockquote><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>当一个方法开始执行后只有两种方法可以退出这个方法：</p><ol><li>执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层方法的调用者，这种退出的方式为“正常调用完成”。</li></ol><blockquote><p>ireturn(返回值是boolean，byte，char，short和int时使用)、lreturn、freturn、dreturn、areturn（引用类型）、return（void类型）</p></blockquote><ol start="2"><li>方法在执行的过程中遇到了异常，并且这个异常并未在方法内进行处理，这种退出方法的方式称为“异常调用完成”。</li></ol><blockquote><p>一个方法使用异常完成出口的方式退出，是不会给它的上层调用者提供任何返回值的。</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p><strong>方法退出的过程就等同于当前栈帧出栈。这是需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</strong></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clinit()与init()</title>
      <link href="/2020/06/10/java/jvm/2-1-1/"/>
      <url>/2020/06/10/java/jvm/2-1-1/</url>
      
        <content type="html"><![CDATA[<h2 id="lt-clinit-gt-与-lt-init-gt"><a href="#lt-clinit-gt-与-lt-init-gt" class="headerlink" title="&lt;clinit&gt;()与&lt;init&gt;()"></a><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code></h2><h3 id="lt-clinit-gt"><a href="#lt-clinit-gt" class="headerlink" title="&lt;clinit&gt;()"></a><code>&lt;clinit&gt;()</code></h3><ul><li><code>&lt;clinit&gt;()</code>的执行时期为类初始化阶段，并且该方法只能被jvm使用，专门负责类变量的初始化工作。</li><li>Java 类加载的初始化过程中，编译器<strong>按语句在源文件中出现的顺序</strong>，依次自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并产生 <code>&lt;clinit&gt;()</code>方法。 如果类中没有静态语句和静态代码块，那可以不生成该方法。</li><li><code>&lt;clinit&gt;()</code> 不需要显式调用父类（接口除外，接口不需要调用父接口的初始化方法，只有使用到父接口中的静态变量时才需要调用）的初始化方法 <code>&lt;clinit&gt;()</code>，虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。</li></ul><p><strong>类何时进行初始化？（主动引用）</strong></p><blockquote><ol><li>使用new关键字实例化对象的时候；读取或设置一个类型的静态字段（被final修饰的除外，因为已在编译期将结果放入了常量池）；调用一个静态方法。</li><li>使用反射调用。</li><li>初始化类的时候，发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li><li><strong>当使用JDK7新加入的动态语言支持时。（后续在字节码章节详细讲解）</strong></li><li>当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果这个接口的实现类发生了初始化，那么该接口要在其之前被初始化。</li></ol><p><strong>以上的条件是当类或接口未初始化过，即是第一次初始化，才会执行。并且有且只有这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型都不会触发初始化，称为被动引用</strong></p></blockquote><p><strong>被动引用</strong></p><ol><li><p>通过子类引用父类的静态字段，不会导致子类初始化，只会触发父类的初始化。</p></li><li><p>通过数组定义来引用类。</p></li></ol><blockquote><p>假如有一个Student类</p><p>Student[] studentArray = new Student[10];</p><p>这种情况并不会导致Student类进行初始化。你并没有使用Student类中的任何，但是你声明数组，必然会导致和数组相关的类进行了初始化，[Lorg.fenixsoft.classloading.SuperClass 这个类发生了初始化，这是个与一维数组相关的类，具体不做详细介绍。</p></blockquote><ol start="3"><li>使用类中的被final修饰的静态常量。</li></ol><blockquote><p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p></blockquote><h3 id="lt-init-gt"><a href="#lt-init-gt" class="headerlink" title="&lt;init&gt;()"></a><code>&lt;init&gt;()</code></h3><ul><li><p>执行时期：对象的初始化阶段。</p></li><li><p>执行构造器，以及非静态初始化块中的代码。</p></li></ul><p><strong>实例化一个类的四种途径:</strong></p><ol><li>调用 new 操作符</li><li>调用 Class 或 java.lang.reflect.Constructor 对象的newInstance()方法(反射)</li><li>调用任何现有对象的clone()方法</li><li>通过 java.io.ObjectInputStream 类的 getObject() 方法反序列化</li></ol><h3 id="lt-clinit-gt-与-lt-init-gt-执行顺序案例"><a href="#lt-clinit-gt-与-lt-init-gt-执行顺序案例" class="headerlink" title="&lt;clinit&gt;()与&lt;init&gt;()执行顺序案例"></a><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code>执行顺序案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test instance; <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// &lt;clinit&gt;()</span></span><br><span class="line">        System.out.println(<span class="string">"static开始"</span>);</span><br><span class="line">        instance = <span class="keyword">new</span> Test();</span><br><span class="line">        System.out.println(<span class="string">"static结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// &lt;init&gt;()</span></span><br><span class="line">        System.out.println(<span class="string">"构造器开始"</span>);</span><br><span class="line">        System.out.println(<span class="string">"x="</span> + x + <span class="string">";y="</span> + y);</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        System.out.println(<span class="string">"x="</span> + x + <span class="string">";y="</span> + y);</span><br><span class="line">        System.out.println(<span class="string">"构造器结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">1</span>; <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> y; <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test.getInstance();</span><br><span class="line">        System.out.println(<span class="string">"x="</span> + x);</span><br><span class="line">        System.out.println(<span class="string">"y="</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><blockquote><p>static开始<br>构造器开始<br>x=0;y=0<br>x=1;y=1<br>构造器结束<br>static结束<br>x=1<br>y=1</p></blockquote><blockquote><p>从结果中可以看出静态代码块先执行，如果静态代码块中执行了其它方法，则先去执行，然后在回来继续执行，静态代码，这就说明了<code>&lt;clinit&gt;()</code>方法在<code>&lt;init&gt;()</code>之前执行。</p></blockquote><blockquote><p><code>&lt;clinit&gt;()</code>方法就是将一个类中的所有的静态代码块以及类变量整合到一块，注意这里是有顺序的执行，如果其中调用了其它非静态方法，就会执行完后接着执行，如果有父类的话当然执行父类的静态代码块以及类变量，就像下图一样，<strong>把父类和子类的这些静态代码块，类变量全部整合到一块，按照代码编写的顺序来执行。</strong></p><p><code>&lt;init&gt;()</code>也是如此，不过整合的是普通代码块和普通的成员变量了。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200610133639.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载子系统</title>
      <link href="/2020/06/09/java/jvm/2-1/"/>
      <url>/2020/06/09/java/jvm/2-1/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><h3 id="一个类的生命周期"><a href="#一个类的生命周期" class="headerlink" title="一个类的生命周期"></a>一个类的生命周期</h3><p><img src="https://image.cclblog.cn/blog/20200609204057.png" alt=""></p><p>其中加载，验证，准备，初始化，和卸载这五个阶段顺序是确定的，解析阶段则不一定，在某些情况下可以在初始化阶段之后再进行，这是为了支持java语言的运行时绑定特性。</p><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载阶段，java虚拟机需要完成：</p><ol><li><p>通过一个类的全限定名来获取定义此类的二进制字节流。</p></li><li><p>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构。</p></li><li><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p></li></ol><blockquote><p><strong>这个java.lang.Class对象，将相当于一个模具，假如你在家里面自制雪糕，必须有个模具吧，用这个模具来生产雪糕，假如你这个模具是塑料的。</strong></p><p><strong>1.中的字节流就相当于这个模具的第一道加工，把塑料的原料加工成塑料</strong></p><p><strong>2.中的就是相当于第二道加工，塑料模具基本成型，然后运输到方法区</strong></p><p><strong>3.就相当于这个模具上色美化等，真正的成为了一个可以使用的模具了，然后你就可以用它来制作雪糕，你制作的每个雪糕就是一个个对象，他们的形状是一样的，但是具体的内容即原料颜色等可能不一样，这也就是对象的具体内容可能不同</strong></p></blockquote><p><img src="https://image.cclblog.cn/blog/20200609204148.png" alt=""></p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ol><li><strong>文件格式验证</strong>，验证字节流是否符合Class文件格式规范。</li></ol><blockquote><p><strong>就是看看你这个文件是不是符合我要加载的，就相当于一个图片还有各种格式.jpg.png，不能你把随便一个文件的后缀名改成.class就加载你吧。</strong></p></blockquote><ol start="2"><li><strong>元数据验证</strong>，对字节码描述的信息进行验证，保证描述的信息符合，比如一个类是否继承了被final修饰的类，如果一个类不是抽象类，是否实现了其父类或接口中要求实现的方法等。</li></ol><blockquote><p><strong>就是看看程序中代码是否做了规定以外的事情，这个规定就好java的语言规范，就相当于一个人要遵守法律一样，就相当于查一下你有没有犯法，做了规定以外的事情。比如你不是我老婆，我和你睡在了一块？？？</strong></p></blockquote><ol start="3"><li><strong>字节码验证</strong>，验证程序语义是否为合法的，符合逻辑的。</li></ol><blockquote><p><strong>就是详细的检查程序代码是否是安全的，会不会对虚拟机造成威胁，这个阶段最为复杂，三言两语很难说清，要检查的东西有很多</strong></p></blockquote><ol start="4"><li><strong>符号引用验证</strong>，验证一个类是否缺少或者被禁止访问它依赖的某些外部类、方法等。</li></ol><blockquote><p><strong>就是我依赖的类，我能不能访问。比如买了一个苹果手机，看一下我能不能使用它，不能使用的话不就出问题了</strong></p></blockquote><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值阶段。</p><p>例如一个变量定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>那变量在准备阶段过后的初始值为0而不是123，真正把value赋值的操作是在类的初始化阶段才会被执行。</p><p>但是如果 value被声明为 <strong>final</strong>那么在准备阶段就会给value赋值为123</p><p><strong>例如</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test2 instance = Test2.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test2 test2 = <span class="keyword">new</span> Test2();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a="</span> + a);</span><br><span class="line">        System.out.println(<span class="string">"b="</span> + b);</span><br><span class="line">        <span class="keyword">return</span> test2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序的输出结果为 a=1 b=0 并不是a=1 b=1</strong></p><blockquote><p>分析：</p><ol><li>准备阶段，会将静态变量从上到下设置为默认值，a=0,test2=null,b=0</li><li>当调用一个类的静态变量或静态方法会导致该类初始化，并设置成实际的默认值</li><li>此时a还是0，因为它并没有默认值，然后test2 赋值，调用了Test2()构造方法，对a++,b++ ,此时a = 1 b = 1</li><li>然后给b赋值默认值0，这样就导致了覆盖了前面的1，导致最后b=0</li></ol><p>如果变成private static int b = 0;private static Test2 test2 = new Test2();那最后的结果就变成了a=1 b=1了，和代码的顺序有关。</p></blockquote><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。这个阶段很重要，需要了解Class文件的类文件结构。后续会详细讲解。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类的初始化是类加载过程的最后一个步骤，直到初始化阶段，Java虚拟机才真正开始执行类中编写的java程序代码。</p><p>这个阶段是为静态变量赋予正确的初始值，执行静态代码块，执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。</p><p><strong>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，可以赋值但是不能访问。例如：</strong></p><p><img src="https://image.cclblog.cn/blog/20200609204234.png" alt="">    </p><p><strong>java虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。这个说明父类中定义的静态语句块肯定优先于子类执行。例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a =  <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Test1.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果为2，这不就说明了Test父类中的静态代码块被执行了吗。</p><p><strong>如果一个类中没有静态语句块，也没有对变量的赋值操作，编译器就不会生成<code>&lt;clinit&gt;()</code>方法。</strong></p><p><strong>执行接口的<code>&lt;clint&gt;()</code>方法无需先执行父类的<code>&lt;clinit&gt;()</code>方法</strong>，因为当只有父接口中定义的变量被使用时，父接口才会被初始化。接口的实现类在初始化时也不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p><p><strong><code>&lt;clinit&gt;()</code>在多线程环境下是安全的，并且只会被执行一次</strong>，只会有一个线程去执行，其它线程阻塞，直到执行完该方法后，其它线程才能操作，否则一直阻塞，并且<code>&lt;clinit&gt;()</code>只会被多个线程执行一次，执行完后，其它线程将不会再次执行。</p><blockquote><p><strong>这就好比你的目的是制作一辆汽车（一个类的模板），你有必要去生产两个车壳子（其中的静态代码块，赋值操作）吗？程序中只需要一个类模板就行了，<code>&lt;clinit&gt;()</code>方法就相当于类模板的装饰，装饰这个类一开始有哪些属性，也就是出厂设置吧。其他你初始化赋值<code>&lt;init&gt;()</code>方法，就是你自定义的值了。你开多个线程，就相当于多个工厂，一旦其中一个工厂接下了这份活，你得赶紧通知其他的工厂不要做了，如果几个工厂都生产的话，你总不能只给一份钱吧（浪费系统资源）。</strong></p></blockquote><p>这就相当于生产一个汽车零件，你的目的只是制作一辆汽车，你完全没有必要去生产</p><h4 id="lt-clinit-gt-与-lt-init-gt-方法"><a href="#lt-clinit-gt-与-lt-init-gt-方法" class="headerlink" title="&lt;clinit&gt;()与&lt;init&gt;()方法"></a><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code>方法</h4><p>详情见 <strong><a href="/2020/06/10/java/jvm/2-1-1/"><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code>详解</a></strong></p><h3 id="类加载器ClassLoader"><a href="#类加载器ClassLoader" class="headerlink" title="类加载器ClassLoader"></a>类加载器ClassLoader</h3><p><img src="https://image.cclblog.cn/blog/20200611160308.png" alt=""></p><ul><li>启动类加载器（Bootstrap Class Loader）</li></ul><blockquote><ol><li>这个类加载器使用C/C++语言实现的，嵌套在JVM内部。所以java程序中是获取不到的。</li><li>负责加载放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，并且必须被java虚拟机识别（按照文件名识别，.jar），名字不符合即使放在此目录下也不能加载。</li><li>不继承自java.lang.ClassLoader，没有父加载器</li><li>出于安全考虑，只能加载包名为java、javax、sun等开头的类</li></ol></blockquote><ul><li>扩展类加载器（Extension Class Loader）</li></ul><blockquote><ol><li>这个类加载器是在sun.misc.Launcher$ExtClassLoader中以java代码的形式实现的。</li><li>负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li></ol></blockquote><ul><li>应用程序类加载器（Application Class Loader）</li></ul><blockquote><p>这个类加载器由sun.misc.Launcher$AppClassLoader来实现。它负责加载用户类路径上所有的类库。如果应用程序中没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p></blockquote><h4 id="自定义类加载器步骤"><a href="#自定义类加载器步骤" class="headerlink" title="自定义类加载器步骤"></a>自定义类加载器步骤</h4><ol><li>继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器。</li><li>jdk1.2之前，继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载，之后不在建议这样做，而是建议把自定义的类加载逻辑写在findClass()方法中。</li><li>在编写自定义类加载器时，如果需求简单，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，可以使自定义类加载器编写更加简洁。</li></ol><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><blockquote><p>JVM对class文件采用的是<strong>按需加载</strong>的方式，当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，JVM采用的是<strong>双亲委派机制</strong>。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200611134915.png" alt=""></p><p><strong>双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的类加载器中，只有当父加载器反馈自己无法完成这个加载请求时（它的搜索范围内没有找到所需的类）时，子加载器才会尝试自己去完成加载。</strong></p><blockquote><p>双亲委派机制就是：<code>自底向上检查类是否已经加载，自顶向下尝试是否可以加载类</code></p></blockquote><p><strong>类加载流程图：</strong></p><p><img src="https://image.cclblog.cn/blog/20200611143430.jfif" alt=""></p><p><strong>使用双亲委派机制的优势？（为什么要使用双亲委派机制？优点有哪些？）</strong></p><blockquote><ol><li>避免类的重复加载。</li><li>保护核心API被随意篡改。通过委托方式，不会去篡改核心<code>.class</code>，即使篡改也不会去加载，即使加载也不会是同一个<code>.class</code>对象了。不同的加载器加载同一个<code>.class</code>也不是同一个<code>Class</code>对象。这样保证了<code>Class</code>执行安全。</li></ol></blockquote><p><strong>弊端：</strong></p><blockquote><p>双亲委派模型是单向的，永远是子加载器请求父加载器，这就造成了上层的类加载器无法访问下层类加载器所加载的类。例如常见的JDBC就是这样，JDBC在java.sql.Driver中只定义了接口，具体的实现是由具体的数据库厂商来实现的，例如你使用msql，mysql肯定实现了Driver中的接口，但是它的jar在你的目录下，系统类加载器无法识别，你要是用mysql的话就会出现问题，自然就会出现解决的办法。线程上下文类加载器，和jdk6提供的java.util.ServiceLoader类具体不过多介绍。</p></blockquote><h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><p>当父加载器去委托子加载器去加载类的时候就破坏了这个双亲委派模型，双亲委派模型有三次被破坏，具体不做说明。</p><p>这两篇文章写得挺好。</p><p><a href="https://blog.csdn.net/awake_lqh/article/details/106171219" target="_blank" rel="noopener">双亲委派模型的破坏(JDBC例子)</a></p><p><a href="https://blog.csdn.net/sinat_34976604/article/details/86723663" target="_blank" rel="noopener">双亲委派模式破坏-JDBC</a></p><h4 id="jdk9下发生的变化（简）"><a href="#jdk9下发生的变化（简）" class="headerlink" title="jdk9下发生的变化（简）"></a>jdk9下发生的变化（简）</h4><p>jdk9对java进行了模块化，是一次重大的变化，这个模型也随之而变。</p><p><img src="https://image.cclblog.cn/blog/20200611152410.png" alt=""></p><ol><li>扩展类加载器被平台类加载器替代。</li><li>它们都不在派生自java.net.URLClassLoader，而是全部继承于jdk.internal.loader.BuiltinClassLoader。</li><li>这个双亲委派模型发生了变化。</li></ol><blockquote><p>jdk9相当于对java核心代码进行了重构，变成模块化，启动类加载器，平台类加载器，应用程序类加载器，都被明确规定了加载哪些模块的类，这样类的加载过程就变成了，在委派给父类加载器的时候首先看自己是否可以加载此类，这个变化可以说破坏了双亲委派的这个模型。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM简介</title>
      <link href="/2020/06/08/java/jvm/1-1/"/>
      <url>/2020/06/08/java/jvm/1-1/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM（Hotspot）"><a href="#JVM（Hotspot）" class="headerlink" title="JVM（Hotspot）"></a>JVM（Hotspot）</h2><p><img src="https://image.cclblog.cn/blog/20200612162656.png" alt=""></p><p><code>java虚拟机是运行在操作系统之上的，它与硬件没有直接的交互！！！</code></p><h3 id="程序运行的过程"><a href="#程序运行的过程" class="headerlink" title="程序运行的过程"></a>程序运行的过程</h3><p><img src="https://image.cclblog.cn/blog/20200611155155.png" alt=""></p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p><img src="https://image.cclblog.cn/blog/20200611160308.png" alt=""></p><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p><img src="https://image.cclblog.cn/blog/20200611161129.png" alt=""></p><ul><li>99%的垃圾回收操作都是在堆上，所谓的JVM调优实际上就是在对堆的一个调优！！！</li></ul><h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><p><img src="https://image.cclblog.cn/blog/20200611170207.png" alt=""></p><h3 id="JDK不同版本JVM变化"><a href="#JDK不同版本JVM变化" class="headerlink" title="JDK不同版本JVM变化"></a>JDK不同版本JVM变化</h3><ul><li><p>jdk6：存在永久代，静态变量存放在永久代。</p></li><li><p>jdk7：存在永久代，逐步去永久代；将<strong>字符串常量池</strong>和<strong>静态变量</strong>移动到了堆空间中。</p></li><li><p>jdk8：永久代，类型信息、字段、方法、常量保存在本地内存的元空间（Metaspace），字符串常量池、静态变量仍然在堆中。</p></li></ul><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol><li><p>为什么将字符串常量池移入到堆中？（为什么去永久代，改为元空间？）</p><blockquote><ol><li>字符串存在永久代中，容易出现性能问题和内存溢出，因为字符串应该是程序中非常常用的。</li><li>类及方法的信息等比较难确定大小，因此对于永久代的大小指定比较困难。</li><li>永久代会为GC带来不必要的复杂度，并且回收效率很低。</li><li>Oracle将HotSpot与JRockit合二为一，借鉴了后者虚拟机的优点。</li></ol></blockquote></li></ol><h3 id="其他虚拟机"><a href="#其他虚拟机" class="headerlink" title="其他虚拟机"></a>其他虚拟机</h3><p>BEA JRockit，IBM J9不做过多介绍。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2020/06/06/java/theme/arithmetic/"/>
      <url>/2020/06/06/java/theme/arithmetic/</url>
      
        <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="数组、链表"><a href="#数组、链表" class="headerlink" title="数组、链表"></a><a href="/2020/06/23/java/arithmetic/1/">数组、链表</a></h2><h2 id="栈、队列、优先队列、双端队列"><a href="#栈、队列、优先队列、双端队列" class="headerlink" title="栈、队列、优先队列、双端队列"></a><a href="/2020/06/23/java/arithmetic/2/">栈、队列、优先队列、双端队列</a></h2><h2 id="哈希表、映射、集合"><a href="#哈希表、映射、集合" class="headerlink" title="哈希表、映射、集合"></a>哈希表、映射、集合</h2><h2 id="树、二叉树、二叉搜索树"><a href="#树、二叉树、二叉搜索树" class="headerlink" title="树、二叉树、二叉搜索树"></a>树、二叉树、二叉搜索树</h2><h2 id="泛型递归、树的递归"><a href="#泛型递归、树的递归" class="headerlink" title="泛型递归、树的递归"></a><a href="/2020/06/26/java/arithmetic/4/">泛型递归、树的递归</a></h2><h2 id="分治、回溯"><a href="#分治、回溯" class="headerlink" title="分治、回溯"></a>分治、回溯</h2><h2 id="深度优先搜索、广度优先搜索"><a href="#深度优先搜索、广度优先搜索" class="headerlink" title="深度优先搜索、广度优先搜索"></a>深度优先搜索、广度优先搜索</h2><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> JAVA </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> JAVA </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2020/06/06/java/theme/jvm/"/>
      <url>/2020/06/06/java/theme/jvm/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h3 id="1、JVM简介（√）"><a href="#1、JVM简介（√）" class="headerlink" title="1、JVM简介（√）"></a><a href="/2020/06/08/java/jvm/1-1/">1、JVM简介（√）</a></h3><hr><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><h3 id="1、类加载子系统（√）"><a href="#1、类加载子系统（√）" class="headerlink" title="1、类加载子系统（√）"></a><a href="/2020/06/09/java/jvm/2-1/">1、类加载子系统（√）</a></h3><h3 id="2、虚拟机栈（√）"><a href="#2、虚拟机栈（√）" class="headerlink" title="2、虚拟机栈（√）"></a><a href="/2020/06/12/java/jvm/2-2/">2、虚拟机栈（√）</a></h3><h3 id="3、本地方法栈（√）"><a href="#3、本地方法栈（√）" class="headerlink" title="3、本地方法栈（√）"></a><a href="/2020/06/17/java/jvm/2-3/">3、本地方法栈（√）</a></h3><h3 id="4、程序计数器（√）"><a href="#4、程序计数器（√）" class="headerlink" title="4、程序计数器（√）"></a><a href="/2020/06/12/java/jvm/2-4/">4、程序计数器（√）</a></h3><h3 id="5、堆（√）"><a href="#5、堆（√）" class="headerlink" title="5、堆（√）"></a><a href="/2020/06/17/java/jvm/2-5/">5、堆（√）</a></h3><h3 id="6、方法区（√）"><a href="#6、方法区（√）" class="headerlink" title="6、方法区（√）"></a><a href="/2020/06/19/java/jvm/2-6/">6、方法区（√）</a></h3><hr><h3 id="7、执行引擎（√）"><a href="#7、执行引擎（√）" class="headerlink" title="7、执行引擎（√）"></a><a href="/2020/06/20/java/jvm/2-7/">7、执行引擎（√）</a></h3><h2 id="8、本地方法接口（略）"><a href="#8、本地方法接口（略）" class="headerlink" title="8、本地方法接口（略）"></a>8、本地方法接口（略）</h2><hr><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="1、垃圾收集器"><a href="#1、垃圾收集器" class="headerlink" title="1、垃圾收集器"></a>1、垃圾收集器</h3><h3 id="2、内存分配策略"><a href="#2、内存分配策略" class="headerlink" title="2、内存分配策略"></a>2、内存分配策略</h3><h2 id="性能监控与调优"><a href="#性能监控与调优" class="headerlink" title="性能监控与调优"></a>性能监控与调优</h2><h3 id="1、性能监控"><a href="#1、性能监控" class="headerlink" title="1、性能监控"></a>1、性能监控</h3><h3 id="2、性能调优"><a href="#2、性能调优" class="headerlink" title="2、性能调优"></a>2、性能调优</h3><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="1、StringTable"><a href="#1、StringTable" class="headerlink" title="1、StringTable"></a>1、StringTable</h3><h3 id="2、字节码"><a href="#2、字节码" class="headerlink" title="2、字节码"></a>2、字节码</h3>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>感悟</title>
      <link href="/2020/06/06/life/life/"/>
      <url>/2020/06/06/life/life/</url>
      
        <content type="html"><![CDATA[<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol><li>初心！</li></ol>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> 感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
            <tag> 主题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
