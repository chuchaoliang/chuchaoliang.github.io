<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>new一个类初始化的顺序</title>
      <link href="/2020/07/03/java/javase/18/"/>
      <url>/2020/07/03/java/javase/18/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StringBuffer与StringBuilder</title>
      <link href="/2020/07/02/java/javase/4/"/>
      <url>/2020/07/02/java/javase/4/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li><strong>StringBuffer</strong>就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类，提供append和add方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个线程安全的可修改的字符序列，把所有修改数据的方法都加上synchronized。但是保证了线程安全是需要性能的代价的。</li><li><strong>StringBuilder</strong>是JDK1.5发布的，它和<strong>StringBuffer</strong>本质上并没有什么区别，就是去掉了保证线程安全的那部分，减少了开销。</li></ul><h1 id="相同点、不同点"><a href="#相同点、不同点" class="headerlink" title="相同点、不同点"></a>相同点、不同点</h1><p><img src="https://image.cclblog.cn/blog/20200702174359.png" alt=""></p><blockquote><p>实际上StringBuffer就是一个加锁的StringBuilder，其它的除了那个缓冲区，没什么区别，他们就相当于一个壳子，实际上调用的是他们父类中的方法，来进行操作那个char[]数组的。</p></blockquote><h1 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h1><p><strong>这个要明白String是final修饰的，正是因为它的不可变性，所以例如拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"a"</span> + <span class="string">"b"</span> + <span class="string">"c"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/blog/20200702174739.png" alt=""></p><blockquote><p>这种情况编译器会直接带代码进行优化为 String a = “abc” 无需额外的操作，看字节码astore就知道直接存入局部变量表1的位置。（0的位置是args数组）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"a"</span>;</span><br><span class="line">        String b = <span class="string">"b"</span>;</span><br><span class="line">        String c = <span class="string">"c"</span>;</span><br><span class="line">        String d = a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/blog/20200702175310.png" alt=""></p><blockquote><p>这种编译器自然就没办法进行优化，但是JVM会帮助你做相关的优化，字节码中可以看出JVM中new StringBuilder操作append()方法拼接的字符串。</p><p><strong>这里并未出现new多次StringBuilder这个现象，我看网上的好多都说这个操作会出现new 多个StringBuilder对象，这个？？？？？。难道是JVM更加的优化了这个，还是有的我并不了解，待研究，遇到操作字符串拼接还是老老实实new StringBuilder吧</strong></p></blockquote><hr><blockquote><p><strong>突然想到循环，如果再循环内的话这个操作应该就会出现问题！！！</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"a"</span>;</span><br><span class="line">        String d = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            d += a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"a"</span>;</span><br><span class="line">        String d = <span class="string">""</span>;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            d = stringBuilder.append(a).toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/blog/20200702180455.png" alt=""></p><blockquote><p>百度需谨慎啊啊！！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的内部类</title>
      <link href="/2020/06/30/java/javase/6/"/>
      <url>/2020/06/30/java/javase/6/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在Java中，可以将一个类定义在另一个类里面或者一个方法里边，这样的类称为内部类，广泛意义上的内部类一般包括四种：</p><ul><li><p><strong>成员内部类</strong></p></li><li><p><strong>局部内部类</strong></p></li><li><p><strong>匿名内部类</strong></p></li><li><p><strong>静态内部类</strong> </p></li></ul><h1 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h1><ul><li><p><strong>该类像是外部类的一个成员，可以无条件的访问外部类的所有成员属性和成员方法（包括private成员和静态成员）</strong>；</p></li><li><p>成员内部类拥有与外部类同名的成员变量时，会发生隐藏现象，即默认情况下访问的是成员内部类中的成员。如果要访问外部类中的成员，需要以下形式访问：【外部类.this.成员变量  或  外部类.this.成员方法】；</p></li><li><p>在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问；</p></li><li><p>成员内部类是依附外部类而存在的，也就是说，<strong>如果要创建成员内部类的对象，前提是必须存在一个外部类的对象；</strong></p></li><li><p>内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。如果成员内部类用private修饰，则只能在外部类的内部访问；如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。<strong>外部类只能被public和包访问两种权限修饰。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String testStr = <span class="string">"琦玉"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterClass</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员内部类（普通内部类）</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 成员内部类不可以定义静态的属性和方法</span></span><br><span class="line">        <span class="comment">//private static String str;</span></span><br><span class="line">        <span class="keyword">private</span> String str;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.str = str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">testArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试内部类中和外部类出现同名方法</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 在内部类中出现和外部类同名方法，默认调用本类中的方法</span></span><br><span class="line">            <span class="comment">//testArea();</span></span><br><span class="line">            <span class="comment">// 外部类名.this.方法名/类名 可以调用外部方法</span></span><br><span class="line">            <span class="comment">// 无条件的访问外部类所有成员属性，和成员方法（即使是private，或者static）</span></span><br><span class="line">            System.out.println(OuterClass.<span class="keyword">this</span>.str); <span class="comment">// 外部类</span></span><br><span class="line">            System.out.println(testStr); <span class="comment">// 琦玉</span></span><br><span class="line">            <span class="keyword">return</span> OuterClass.<span class="keyword">this</span>.testArea();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass(<span class="string">"外部类"</span>);</span><br><span class="line">        InnerClass innerClass = outerClass.<span class="keyword">new</span> InnerClass(<span class="string">"局部内部类"</span>);</span><br><span class="line">        System.out.println(outerClass.testArea()); <span class="comment">// 打印 外部类</span></span><br><span class="line">        System.out.println(innerClass.test()); <span class="comment">// 打印 外部类 通过（外部类名.this.方法名）可以调用外部方法调用了外部类中方法</span></span><br><span class="line">        System.out.println(innerClass.testArea()); <span class="comment">// 打印 局部外部类</span></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出结果：</span></span><br><span class="line"><span class="comment">         * 外部类</span></span><br><span class="line"><span class="comment">         * 外部类</span></span><br><span class="line"><span class="comment">         * 琦玉</span></span><br><span class="line"><span class="comment">         * 局部外部类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h1><ul><li>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内；</li><li>局部内部类就像是方法里面的一个局部变量一样，是<strong>不能有public、protected、private以及static修饰符的。</strong></li></ul><blockquote><p>这个局部内部类太鸡肋了，应该都不怎么使用，定义的时候和普通的class是一样的，除了不能用修饰符，还有作用域太小了吧，谁没事在代码块中定义一个局部内部类啊。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">memberFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不可用修饰符修饰</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">PartInnerClass</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = <span class="string">"aaa"</span>;</span><br><span class="line">            <span class="keyword">private</span> String str1 = <span class="string">"sss"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">PartInnerClass</span><span class="params">(String str1)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.str1 = str1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> str1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        PartInnerClass innerClass = <span class="keyword">new</span> PartInnerClass(<span class="string">"局部内部类"</span>);</span><br><span class="line">        System.out.println(innerClass.test());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 局部内部类出了作用域就无法使用了！！！</span></span><br><span class="line">        <span class="comment">//new PartInnerClass("sss");</span></span><br><span class="line">        memberFunction();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出结果：</span></span><br><span class="line"><span class="comment">         * 局部内部类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><ul><li><p>一般使用匿名内部类的方法来编写事件监听代码；</p></li><li><p>匿名内部类不能定义静态成员、方法和类；</p></li><li><p><strong>匿名内部类是不能有访问修饰符和static修饰符的；</strong></p></li><li><p><strong>匿名内部类是唯一一种没有构造器的类；</strong></p></li><li><p>匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p></li></ul><blockquote><p><strong>因为匿名内部类为局部内部类，所以局部内部类的所有限制都对其生效。</strong></p></blockquote><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ul><li><strong>继承一个类，重写其方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = <span class="string">"匿名内部类通过继承实现"</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.run();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出结果：</span></span><br><span class="line"><span class="comment">         * 匿名内部类通过继承实现</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>实现一个接口（可以是多个），实现其方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = <span class="string">"匿名内部类通过接口实现"</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        runnable.run();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 匿名内部类通过接口实现</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h1><ul><li><p>静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似；</p></li><li><p>不能使用外部类的非static成员变量或者方法。</p></li></ul><blockquote><p>静态内部类如果去掉关键字static就变成了成员内部类，成员内部类是非静态内部类它可以自由的引用外部类的属性和方法，无论这些属性和方法是静态的还是非静态的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String testStr = <span class="string">"琦玉"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterClass</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员内部类（普通内部类）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String str;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以定义静态的参数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String str1 = <span class="string">"静态内部类的静态参数"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.str = str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试内部类中和外部类出现同名方法</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 只能访问外部类的静态成员变量，或者方法</span></span><br><span class="line">            System.out.println(testStr); <span class="comment">// 琦玉</span></span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 静态内部类不依赖外部类，直接声明就可以</span></span><br><span class="line">        InnerClass innerClass = <span class="keyword">new</span> InnerClass(<span class="string">"静态内部类"</span>);</span><br><span class="line">        System.out.println(innerClass.test()); <span class="comment">// 打印 静态内部类</span></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出结果：</span></span><br><span class="line"><span class="comment">         * 琦玉</span></span><br><span class="line"><span class="comment">         * 静态内部类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><blockquote><p>这些内部类根本不用记，从名字上就可以知道意思；</p><p><strong>成员内部类：</strong>这个就想成类的成员变量，成员变量能被各种访问符修饰，这个自然可以，成员变量依赖类的实例化，这个也依赖于外部类啊。</p><p><strong>静态内部类：</strong>了解了成员内部类，加一个static修饰就是静态内部类了啊，就相当于普通的成员变量，加一个static修饰不就变成，类变量了，类变量，类方法不依赖类的实例变量，只能调用类中静态方法和静态变量，那么这个静态内部类也不就一样，就不依赖于外部类，直接new，只能用外部类的静态方法和静态变量。</p><p><strong>局部内部类：</strong>局部内部类这个更加见名知意了，局部的，在一个方法中，或者代码块中，仅仅在这个中生效，就想象成方法中定义的一个<strong>局部变量</strong>，怎么可能用修饰符修饰。</p><p><strong>匿名内部类：</strong>这个也见名知意，就是没有名字的内部类，为什么没有名字，肯定是new xxx() {} 重写方法或者实现接口中的方法，这个用的比较多应该熟悉。</p></blockquote><ul><li>成员内部类===》类的成员变量</li><li>静态内部类===》类的类变量</li><li>局部内部类===》方法的局部变量</li><li>匿名内部类===》。。。。</li></ul><hr><blockquote><p>实际上我感觉对普通的程序员来说这些内部类就偶尔用一用匿名内部类吧，看那jdk源码中发现用了很多成员内部类，和静态内部类。我反正没怎么用过，比较low，<strong>我对内部类的理解仅此而已，仅仅是知道些特性，到底该怎么用，何时去用还差一点感觉。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类VS接口</title>
      <link href="/2020/06/29/java/javase/17/"/>
      <url>/2020/06/29/java/javase/17/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是抽象类和接口？"><a href="#什么是抽象类和接口？" class="headerlink" title="什么是抽象类和接口？"></a>什么是抽象类和接口？</h1><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><strong>abstract修饰的类。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">int</span> 方法名(参数列表); <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>抽象的方法没有方法体。需要注意的是在抽象类中既可以有抽象方法，也可以有普通方法。</li></ul><blockquote><p><strong>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</strong></p></blockquote><ul><li><p>抽象类不能被实例化，如果被实例化，编译就无法通过。</p></li><li><p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p></li><li><p><strong>构造方法和类方法不能声明为抽象方法。</strong></p></li><li><p>抽象方法必须用public、或者protected修饰（不能使用private，子类无法重写，无意义）默认缺省为 public。</p></li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><strong>interface关键字声明接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名 </span>&#123;</span><br><span class="line">    返回值 方法名(参数列表); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><ul><li>接口中每一个方法都是隐式抽象的，<strong>接口中的方法会被隐式的指定为public abstract并且只能是。</strong></li></ul><ul><li>接口中可以含有成员变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法（java8存在变化）。</li></ul><h3 id="java8之后接口的变化"><a href="#java8之后接口的变化" class="headerlink" title="java8之后接口的变化"></a>java8之后接口的变化</h3><p>在JDK1.8之前的版本（不包括JDK1.8），接口中不能有静态方法，抽象类中因为有普通方法，故也可以有静态方法。</p><p>在JDK1.8后（包括JDK1.8），在抽象类中依旧可以有静态方法，同时在接口中也可以定义静态方法了。</p><p>以下代码在JDK1.8之后是没有问题的（可以通过接口名来调用静态方法  ：Main.prinf(); ）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JDK1.7，接口中只包含抽象方法，使用public abstract  修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在JDK1.8，接口中新加了默认方法和静态方法：</strong></p><p>​        <strong>默认方法：</strong>使用default修饰，在接口的实现类中，可以直接调用该方法，也可以重写该方法。</p><p>​        <strong>静态方法：</strong>使用static修饰，通过接口直接调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;    </span><br><span class="line">    <span class="comment">//默认方法    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">"default method..."</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//静态方法    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">"static method..."</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在JDK1.9，接口中新加了私有方法，使用private修饰，私有方法供接口内的默认方法和静态方法调用。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口与抽象类区别？"><a href="#接口与抽象类区别？" class="headerlink" title="接口与抽象类区别？"></a>接口与抽象类区别？</h1><ul><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li><li>抽象类只能单继承，接口可以多继承。</li><li>抽象类中可以有普通成员变量，接口中没有普通成员变量。 </li><li>抽象类可以有构造方法，接口不能有构造方法。</li><li>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，<strong>但接口中定义的变量只是public static final 类型，并且默认即为 public static final 类型。</strong></li><li>….</li></ul><blockquote><p>接口和抽象类之间的区别真的要硬说真的还有很多，从各个方面，抽象类是is-a关系，接口是has-a关系；还有他们的使用场景也不同，等等。。这个了解就好。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题集（第二周）</title>
      <link href="/2020/06/29/java/question/2/"/>
      <url>/2020/06/29/java/question/2/</url>
      
        <content type="html"><![CDATA[<h1 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><strong>抽象类方法的访问权限默认都是public。（  ）</strong></p><ul><li><strong>A：</strong>正确</li><li><strong>B：</strong>错误</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p><strong>关于抽象类</strong></p><p>JDK 1.8以前，抽象类的方法默认访问权限为protected</p><p>JDK 1.8时，抽象类的方法默认访问权限变为default</p><p><strong>关于接口</strong></p><p>JDK 1.8以前，接口中的方法必须是public的</p><p>JDK 1.8时，接口中的方法可以是public的，也可以是default的</p><p>JDK 1.9时，接口中的方法可以是private的</p></blockquote><p><strong>（多选）Java创建对象的说法正确的有（）</strong></p><ul><li><strong>A：</strong>用new语句创建对象，是最常见的创建对象的方法。</li><li><strong>B：</strong>运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。</li><li><strong>C：</strong>调用对象的clone()方法。</li><li><strong>D：</strong>运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ABCD</span></span><p><strong>解析：</strong></p><p>Java有5种方式来创建对象：</p><ol><li>使用 new 关键字（最常用）： ObjectName obj = new ObjectName();</li><li>使用反射的Class类的newInstance()方法： ObjectName obj = ObjectName.class.newInstance(); </li><li>使用反射的Constructor类的newInstance()方法： ObjectName obj = ObjectName.class.getConstructor.newInstance();</li><li>使用对象克隆clone()方法： ObjectName obj = obj.clone(); </li><li>使用反序列化（ObjectInputStream）的readObject()方法： try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FILE_NAME))) { ObjectName obj = ois.readObject(); }</li></ol></blockquote><p><strong>（多选）关于Java中的数组，下面的一些描述，哪些描述是准确的：（  ）</strong></p><ul><li><strong>A：</strong>数组是一个对象，不同类型的数组具有不同的类</li><li><strong>B：</strong>数组长度是可以动态调整的</li><li><strong>C：</strong>数组是一个连续的存储结构</li><li><strong>D：</strong>一个固定长度的数组可类似这样定义: int array[100]</li><li><strong>E：</strong>两个数组用equals方法比较时，会逐个便利其中的元素，对每个元素进行比较</li><li><strong>F：</strong>可以二维数组，且可以有多维数组，都是在Java中合法的</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ACF</span></span><p><strong>解析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] i = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] j = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] k = i;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">double</span>[] array_1 = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">100</span>];</span><br><span class="line">        System.out.println(array);</span><br><span class="line">        System.out.println(array_1);</span><br><span class="line">        System.out.println(i.equals(j));</span><br><span class="line">        System.out.println(i.equals(k));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[I@<span class="number">6</span>d6f6e28</span><br><span class="line">[D@<span class="number">135f</span>baa4</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>A 数组是对象，因为可以调用方法，从上面的输出结果可以看出不同类型的数组具有不同的类</p><p>B 数组长度是不能动态调整的</p><p>C Java中的数组中的数据是连续存储在一块内存中的，所以可以通过下标(即偏移量)的方式访问</p><p>D 固定长度的数组定义如上</p><p>E 查看源码可以知道数组的equals方法是object的equals，比较的是内存地址，Arrays.equal()可以比较数组元素。</p><p>F java可以有多维数组</p></blockquote><p><strong>以下JAVA程序的运行结果是什么(  )</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Object o1 = <span class="keyword">true</span> ? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">Object o2;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">             o2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">o2 = <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(o1);</span><br><span class="line">System.out.print(<span class="string">" "</span>);         </span><br><span class="line">System.out.print(o2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>1 1</li><li><strong>B：</strong>1.0 1.0</li><li><strong>C：</strong>1 1.0</li><li><strong>D：</strong>1.0 1</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p>三元操作符类型的转换规则：</p><ol><li><p>若两个操作数不可转换，则不做转换，返回值为Object类型</p></li><li><p>若两个操作数是明确类型的表达式（比如变量），则按照正常的二进制数字来转换，int类型转换为long类型，long类型转换为float类型等。</p></li><li><p>若两个操作数中有一个是数字S,另外一个是表达式，且其类型标示为T，那么，若数字S在T的范围内，则转换为T类型；若S超出了T类型的范围，则T转换为S类型。</p></li><li><p>若两个操作数都是直接量数字，则返回值类型为范围较大者</p></li></ol></blockquote><p><strong>以下关于Object类的说法正确的是（）</strong></p><ul><li><strong>A：</strong>Java中所有的类都直接或间接继承自Object，无论是否明确的指明，无论其是否是抽象类。</li><li><strong>B：</strong>Java中的接口(interface)也继承了Object类</li><li><strong>C：</strong>利用“==”比较两个对象时，Java调用继承自Object的equals方法，判断是否相等。</li><li><strong>D：</strong>如果类的定义中没有重新定义toString()方法，则该类创建的对象无法使用toStrig()方法。</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p><strong>A：</strong>Object 是基类 Java中的所有的类都直接或间接的继承；所以A对<br><strong>B：</strong>从一个class派生的必然是另一个class。Object是一个class，如果interface继承自Object，那么interface必然是一个class，所以B错<br><strong>C：</strong>利用equals()方法进行比较时 会调用== 可以看equals()方法的源码，可以这样说， == 比equal更加强大，所以C错<br><strong>D：</strong>toString()方法是Object类中 即使不重写也能使用 所以D错</p></blockquote><p><strong>（多选）Java类Demo中存在方法func0、func1、func2、func3和func4，请问该方法中，哪些是不合法的定义？( )</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">float</span> <span class="title">func0</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　　<span class="keyword">byte</span> i=<span class="number">1</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">float</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　　<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">　　　　<span class="keyword">return</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">float</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　　<span class="keyword">short</span> i=<span class="number">2</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">float</span> <span class="title">func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　　<span class="keyword">long</span> i=<span class="number">3</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">float</span> <span class="title">func4</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　　<span class="keyword">double</span> i=<span class="number">4</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>func1</li><li><strong>B：</strong>func2</li><li><strong>C：</strong>func3</li><li><strong>D：</strong>func4</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AD</span></span><p><strong>解析：</strong></p><p>数据类型的转换，分为自动转换和强制转换。自动转换是程序在执行过程中 “ 悄然 ” 进行的转换，不需要用户提前声明，一般是从位数低的类型向位数高的类型转换；强制类型转换则必须在代码中声明，转换顺序不受限制。</p><p><strong>自动数据类型转换</strong></p><p>自动转换按从低到高的顺序转换。不同类型数据间的优先关系如下：<br>低 ———————————————&gt; 高<br>byte,short,char-&gt; int -&gt; long -&gt; float -&gt; double</p><p>运算中，不同类型的数据先转化为同一类型，然后进行运算，转换规则如下：</p><table><thead><tr><th><strong>操作数 1</strong> <strong>类型</strong></th><th><strong>操作数 2</strong> <strong>类型</strong></th><th><strong>转换后的类型</strong></th></tr></thead><tbody><tr><td>byte 、 short 、 char</td><td>int</td><td>int</td></tr><tr><td>byte 、 short 、 char 、 int</td><td>long</td><td>long</td></tr><tr><td>byte 、 short 、 char 、 int 、 long</td><td>float</td><td>float</td></tr><tr><td>byte 、 short 、 char 、 int 、 long 、 float</td><td>double</td><td>double</td></tr></tbody></table><p><strong>强制数据类型转换</strong></p><p>强制转换的格式是在需要转型的数据前加上 “( )” ，然后在括号内加入需要转化的数据类型。有的数据经过转型运算后，精度会丢失，而有的会更加精确</p></blockquote><p><strong>Consider the following code:</strong></p><p><strong>String s=null;</strong></p><p><strong>Which code fragments cause an object of type NullPointerException to be thrown?</strong></p><ul><li><strong>A：</strong>if((s!=null)&amp;(s.length()&gt;0))</li><li><strong>B：</strong>if((s!=null)&amp;&amp;(s.length()&gt;0))</li><li><strong>C：</strong>if((s == null)|(s.length()==0))</li><li><strong>D：</strong>if((s == null)||(s.length()==0))</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AC</span></span><p><strong>解析：</strong></p><p>s为null，因此只要调用了s.length()都会抛出空指针异常。因此这个题目就是考察if语句的后半部分会不会执行。<br>A：单个与操作的符号&amp; 用在整数上是按位与，用在布尔型变量上跟&amp;&amp;功能类似，但是区别是无论前面是否为真，后面必定执行，因此抛出异常<br>B：与操作，前半部分判断为假，后面不再执行<br>C：这里跟 &amp; 和&amp;&amp; 的区别类似，后面必定执行，因此抛出异常<br>D：或语句，前面为真，整个结果必定为真，后面不执行</p></blockquote><p><strong>（重要）下面代码的输出是什么？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String baseName = <span class="string">"base"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        callName();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System. out. println(baseName);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String baseName = <span class="string">"sub"</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System. out. println (baseName) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Base b = <span class="keyword">new</span> Sub();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>null</li><li><strong>B：</strong>sub</li><li><strong>C：</strong>base</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>1.首先，需要明白<strong>类的加载顺序</strong>。</p><p>(1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)</p><p>(2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )</p><p>(3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )</p><p>(4) 父类构造函数</p><p>(5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )</p><p>(6) 子类构造函数</p><p>其中：类中静态块按照声明顺序执行，并且(1)和(2)不需要调用new类实例的时候就执行了(意思就是在类加载到方法区的时候执行的)</p><p>2.其次，需要理解子类覆盖父类方法的问题，也就是<strong>方法重写实现多态</strong>问题。</p><p>Base b = new Sub();<strong>它为多态的一种表现形式，声明是Base,实现是Sub类，</strong> <strong>理解为</strong> <strong>b</strong> <strong>编译时表现为Base类特性，运行时表现为Sub类特性（这个非常重要）。</strong></p><p>当子类覆盖了父类的方法后，意思是父类的方法已经被重写，<strong>题中</strong> <strong>父类初始化调用的方法为子类实现的方法，子类实现的方法中调用的baseName为子类中的私有属性。</strong></p><p>由1.可知，此时只执行到步骤4.,子类非静态代码块和初始化步骤还没有到，子类中的baseName还没有被初始化。所以此时 baseName为空。 所以为null。</p></blockquote><p><strong>设有下面两个赋值语句：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = Integer.parseInt(<span class="string">"1024"</span>);</span><br><span class="line">b = Integer.valueOf(<span class="string">"1024"</span>).intValue();</span><br></pre></td></tr></table></figure><p><strong>下述说法正确的是（）</strong></p><ul><li><strong>A：</strong>a是整数类型变量，b是整数类对象。</li><li><strong>B：</strong>a是整数类对象，b是整数类型变量。</li><li><strong>C：</strong>a和b都是整数类对象并且它们的值相等。</li><li><strong>D：</strong>a和b都是整数类型变量并且它们的值相等。</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p>intValue()是把Integer对象类型变成int的基础数据类型；<br>parseInt()是把String 变成int的基础数据类型；<br>Valueof()是把String 转化成Integer对象类型；（现在JDK版本支持自动装箱拆箱了。）<br>本题：parseInt得到的是基础数据类型int，valueof得到的是装箱数据类型Integer，然后再通过intValue转换成int，所以选择D</p></blockquote><p><strong>A 是抽象父类或接口， B ， C 派生自 A ，或实现 A ，现在 Java 源代码中有如下声明：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. A  a0 = <span class="keyword">new</span>  A();</span><br><span class="line"><span class="number">2</span>. A  a1 = <span class="keyword">new</span>  B();</span><br><span class="line"><span class="number">3</span>. A  a2 = <span class="keyword">new</span>  C();</span><br></pre></td></tr></table></figure><p><strong>问以下哪个说法是正确的？（ ）</strong></p><ul><li><strong>A：</strong>第1行不能通过编译</li><li><strong>B：</strong>第1、2行能通过编译，但第3行编译出错</li><li><strong>C：</strong>第1、2、3行能通过编译，但第2、3行运行时出错</li><li><strong>D：</strong>第1行、第2行和第3行的声明都是正确的</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p><strong>抽象类和接口不能实例化了</strong>这个我竟然没注意。。。</p></blockquote><p><strong>以下代码执行后输出结果为（ ）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Test t1 = <span class="keyword">new</span> Test();</span><br><span class="line">    &#123;</span><br><span class="line">         System.out.println(<span class="string">"blockA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"blockB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Test t2 = <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>blockAblockBblockA</li><li><strong>B：</strong>blockAblockAblockB</li><li><strong>C</strong>：blockBblockBblockA</li><li><strong>D</strong>：blockBblockAblockB</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>首先区别<clinit>是类初始化，<init>是实例初始化</p><p>类装载准备阶段-&gt;类初始化clinit阶段</p><p>类装载准备阶段：变量赋系统要求的初始值（0或者null等），final变量会在此时赋用户定义的初始值</p><p>类初始化<clinit>过程：</p><p>Step1 编译器收集t1的赋值动作，static语句块，main方法语句块</p><p>Step2 执行收集好的语句块：</p><p>Step2.1 执行t1 = new Test，发现clinit过程已经调用，于是可以开始触发init过程，执行成员变量的初始化（此处没有），以及非静态代码块，输出blockA，最后调用构造函数（此处没有）</p><p>Step2.2 按照顺序，执行static语句块，输出blockB</p><p>Step2.3 按照顺序，执行main方法语句块，执行t2 = new Test，触发init方法，执行非静态代码块,输出blockA</p><p><strong>其实这题很简单，第一你要搞懂，这程序是怎么走的，从上往下。第二你要知道静态块和构造块，静态块是程序走到静态快的位置就自动执行，仅且执行一次，构造块是创建类对象（实例化）操作时就加载一次。最后把题目从上往下执行，遵循第一和第二，就得到答案了。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String word=<span class="string">" "</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWord</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.word=word;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setI</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        Data0bject. i=I;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建一个如下方式的DataObject:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataObject object=<span class="keyword">new</span> Data0bject ( );</span><br><span class="line">object. setWord(<span class="string">"123"</span>);</span><br><span class="line">object. setI(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>将此对象序列化为文件，并在另外一个JVM中读取文件，进行反序列化，请问此时读出的Data0bject对象中的word和i的值分别为：</strong></p><ul><li><strong>A：</strong>“”, 0</li><li><strong>B：</strong>“”, 2</li><li><strong>C：</strong>“123”, 2</li><li><strong>D：</strong>“123”, 0</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p><strong>Java在序列化时不会实例化static变量和transient修饰的变量，因为static代表类的成员，transient代表对象的临时数据，被声明这两种类型的数据成员不能被序列化。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1=<span class="number">1</span>,b2=<span class="number">2</span>,b3,b6,b8;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span> b4=<span class="number">4</span>,b5=<span class="number">6</span>,b7;</span><br><span class="line">b3=(b1+b2);  <span class="comment">/*语句1*/</span></span><br><span class="line">b6=b4+b5;    <span class="comment">/*语句2*/</span></span><br><span class="line">b8=(b1+b4);  <span class="comment">/*语句3*/</span></span><br><span class="line">b7=(b2+b5);  <span class="comment">/*语句4*/</span></span><br><span class="line">System.out.println(b3+b6);</span><br></pre></td></tr></table></figure><p><strong>（多选）下列代码片段中，存在编译错误的语句是()</strong></p><ul><li><strong>A：</strong>语句2</li><li><strong>B：</strong>语句1</li><li><strong>C：</strong>语句3</li><li><strong>D：</strong>语句4</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BCD</span></span><p><strong>解析：</strong></p><p>Java表达式转型规则<strong>由低到高转换</strong>：</p><p>1、所有的byte,short,char型的值将被提升为int型；</p><p>2、如果有一个操作数是long型，计算结果是long型；</p><p>3、如果有一个操作数是float型，计算结果是float型；</p><p>4、如果有一个操作数是double型，计算结果是double型；</p><p>5、被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。</p><hr><p>语句1错误：b3=(b1+b2);自动转为int，所以正确写法为b3=(byte)(b1+b2);或者将b3定义为int；</p><p>语句2正确：b6=b4+b5;b4、b5为final类型，不会自动提升，所以和的类型视左边变量类型而定，即b6可以是任意数值类型；</p><p>语句3错误：b8=(b1+b4);虽然b4不会自动提升，但b1仍会自动提升，所以结果需要强转，b8=(byte)(b1+b4);</p><p>语句4错误：b7=(b2+b5); 同上。同时注意b7是<strong>final修饰，即只可赋值一次，便不可再改变</strong>。</p></blockquote><p><strong>（多选）Java语言中，下面哪个语句是创建数组的正确语句？(     )</strong></p><ul><li><strong>A：</strong>float f[][] = new float<code>[6][6]</code>;</li><li><strong>B：</strong>float []f[] = new float<code>[6][6]</code>;</li><li><strong>C：</strong>float f[][] = new float<code>[][6]</code>;</li><li><strong>D：</strong>float [][]f = new float<code>[6][6]</code>;</li><li><strong>E：</strong>float [][]f = new float<code>[6][]</code>;</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ABD</span></span><p>解析：注意B选项就行，还有就是第一个框中必须有值！！</p></blockquote><p><strong>（多选）以下类型为Final类型的为（）</strong></p><ul><li><strong>A：</strong>HashMap</li><li><strong>B：</strong>StringBuffer</li><li><strong>C：</strong>String</li><li><strong>D：</strong>Hashtable</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BC</span></span><p><strong>解析：</strong></p><p>StringBuilder , StringBuffer ,String 都是 final 的，但是为什么StringBuilder , StringBuffer可以进行修改呢，因为不可变包括的是，引用不可变以及对象不可变，而这三个都是属于引用不可变，（也就是地址不要变，里面的内容随心所欲），而StringBuilder , StringBuffer 中都包含右append方法，可对对象中的内容进行增加。</p><p>而String a=”123”+new String(“456”);实际上底层是用了一个StringBuffer 进行append；</p></blockquote><p><strong>（多选）Java1.8版本之前的前提，Java特性中,abstract class和interface有什么区别（）</strong></p><ul><li><strong>A：</strong>抽象类可以有构造方法，接口中不能有构造方法</li><li><strong>B：</strong>抽象类中可以有普通成员变量，接口中没有普通成员变量</li><li><strong>C：</strong>抽象类中不可以包含静态方法，接口中可以包含静态方法</li><li><strong>D：</strong>一个类可以实现多个接口，但只能继承一个抽象类。</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ABD</span></span><p><strong>解析：</strong></p><p>A B D显然都是对的。主要说C选项：</p><p>在JDK1.8之前的版本（不包括JDK1.8），接口中不能有静态方法，抽象类中因为有普通方法，故也可以有静态方法。</p><p>在JDK1.8后（包括JDK1.8），在抽象类中依旧可以有静态方法，同时在接口中也可以定义静态方法了。</p><p>以下代码在JDK1.8之后是没有问题的（可以通过接口名来调用静态方法  ：Main.prinf(); ）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：</p><p>在JDK1.7，接口中只包含抽象方法，使用public abstract  修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;&#125;</span><br></pre></td></tr></table></figure><p><strong>在JDK1.8，接口中新加了默认方法和静态方法：</strong></p><p>​        默认方法：使用default修饰，在接口的实现类中，可以直接调用该方法，也可以重写该方法。</p><p>​        静态方法：使用static修饰，通过接口直接调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;    </span><br><span class="line">    <span class="comment">//默认方法    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">"default method..."</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//静态方法    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">"static method..."</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在JDK1.9，接口中新加了私有方法，使用private修饰，私有方法供接口内的默认方法和静态方法调用。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong>（）运算符把其操作数中所有值为0和所有值为1的位分别在结果的相应中设置1和0</strong></p><ul><li><strong>A：</strong>&amp;</li><li><strong>B：</strong>|</li><li><strong>C：</strong>！</li><li><strong>D：</strong>~</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p><del>是<a href="https://www.baidu.com/s?wd=位运算符&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">位运算符</a>，意义是 按位非（NOT）<br>按位非也叫做补，<a href="https://www.baidu.com/s?wd=一元运算符&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">一元运算符</a>NOT“</del>”是对其运算数的每一位取反。</p><ul><li>仅用于整数值</li><li>反转位，即0位变为1位，1变成0</li><li>在所有情况下〜x等于（-x）- 1</li></ul><p>例如</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="number">0111</span> (<span class="number">7</span>) <span class="built_in">=</span> <span class="number">1000</span> (<span class="number">8</span>)</span><br></pre></td></tr></table></figure></blockquote><p><strong>Java 源程序文件的扩展名为（）</strong></p><ul><li><strong>A：</strong>.java</li><li><strong>B：</strong>.class</li><li><strong>C：</strong>.exe</li><li><strong>D：</strong>.jar</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>java中源文件的后缀为.java，经过javac.exe编译后生成字节码文件，后缀为.class，再经过java.exe编译为可执行文件，后缀为.exe。</p></blockquote><p><strong>下列程序的运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCustomerInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// do something that may cause an Exception</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.FileNotFoundException ex) &#123;</span><br><span class="line">            System.out.print(<span class="string">"FileNotFoundException!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException ex) &#123;</span><br><span class="line">            System.out.print(<span class="string">"IOException!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.lang.Exception ex) &#123;</span><br><span class="line">            System.out.print(<span class="string">"Exception!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>IOException!</li><li><strong>B：</strong>IOException!Exception!</li><li><strong>C：</strong>FileNotFoundException!IOException!</li><li><strong>D：</strong>FileNotFoundException!IOException!Exception!</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><h4 id="try-catch-finally-规则"><a href="#try-catch-finally-规则" class="headerlink" title="try-catch-finally 规则"></a><strong>try-catch-finally 规则</strong></h4><p>1)  必须在 try 之后添加 catch 或 finally 块。try 块后可同时接 catch 和 finally 块，但至少有一个块。</p><p>2) 必须遵循块顺序：若代码同时使用 catch 和 finally 块，则必须将 catch 块放在 try 块之后。<br>3) catch 块与相应的异常类的类型相关。<br>4) 一个 try 块可能有多个 catch 块。若如此，则执行第一个匹配块。即Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或 其子类的实例，就执行这个catch代码块，不会再执行其他的 catch代码块<br>5) 可嵌套 try-catch-finally 结构。<br>6) 在 try-catch-finally 结构中，可重新抛出异常。<br>由此可以看出，<strong>catch只会匹配一个，因为只要匹配了一个，虚拟机就会使整个语句退出</strong></p></blockquote><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><strong>（多选）下面有关java threadlocal说法正确的有？</strong></p><ul><li><strong>A：</strong>ThreadLocal存放的值是线程封闭，线程间互斥的，主要用于线程内共享一些数据，避免通过参数来传递</li><li><strong>B：</strong>线程的角度看，每个线程都保持一个对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收</li><li><strong>C：</strong>在Thread类中有一个Map，用于存储每一个线程的变量的副本。</li><li><strong>D：</strong>对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ABCD</span></span><p><strong>解析：</strong></p><p><strong>ThreadLocal类用来提供线程内部的局部变量。</strong>这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。 可以总结为一句话：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 <strong>ThreadLocal设计的初衷：提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。</strong></p></blockquote><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p><strong>（多选）下面的类哪些可以处理Unicode字符?</strong></p><ul><li><strong>A：</strong>InputStreamReader</li><li><strong>B：</strong>BufferedReader</li><li><strong>C：</strong>Writer</li><li><strong>D：</strong>PipedInputStream</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ABC</span></span><p><strong>解析：</strong></p><p>后缀是Stream的都是字节流，其他的都是字符流。</p></blockquote><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><strong>下面程序段的时间复杂度是（）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>( k &lt; n )&#123;</span><br><span class="line">   i ++ ;</span><br><span class="line">k += i ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>O(n)</li><li><strong>B：</strong>O(n^1/2)</li><li><strong>C：</strong>O(n*i)</li><li><strong>D：</strong>O(n+i)</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>设q为一共要执行的次数 </p><p>k=0+1; k=1+1</p><p>q ^ 2+q+1/4=2n+1/4</p><p>(q+1/2)=(2n+1/4) ^ 1/2</p><p>q=(2n+1/4)^1/2-1/2</p><p>所以 T(n)=O(n^1/2)</p></blockquote><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p><strong>运用下列哪个命令能够获取JVM的内存映像</strong></p><ul><li><strong>A：</strong>jinfo</li><li><strong>B：</strong>jmap</li><li><strong>C：</strong>jhat</li><li><strong>D：</strong>jstat</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><ol><li><p>jps：查看本机java进程信息。</p></li><li><p>jstack：打印线程栈信息，制作线程dump文件。</p></li><li><p>jmap：打印内存映射，制作<strong>堆</strong>dump文件</p></li><li><p>jstat：性能监控工具。</p></li><li><p>jhat：内存分析工具</p></li><li><p>jconsole：简易的可视化控制台</p></li><li><p>jvisualvm：功能强大的控制台</p></li><li><p>jinfo<br>如何查看当前运行程序的配置<br>jps -l查看当前所有的进程及进程号<br>方式一：jinfo -flag 配置项 进程号<br>方式二：jinfo -flags 进程号（可查看所有配置项，包括系统默认的和人工自己配置的）</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 题集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 题集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2020/06/28/java/theme/design_mode/"/>
      <url>/2020/06/28/java/theme/design_mode/</url>
      
        <content type="html"><![CDATA[<h1 id="程序设计原则"><a href="#程序设计原则" class="headerlink" title="程序设计原则"></a>程序设计原则</h1><p>1. </p>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> 设计模式 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> JAVA </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归题集</title>
      <link href="/2020/06/26/java/arithmetic/4/"/>
      <url>/2020/06/26/java/arithmetic/4/</url>
      
        <content type="html"><![CDATA[<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">arithmetic70</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 爬楼梯</span></span><br><span class="line"><span class="comment">     * 题目：https://leetcode-cn.com/problems/climbing-stairs/</span></span><br><span class="line"><span class="comment">     * 题解：https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(climbStairs1(<span class="number">3</span>));</span><br><span class="line">        System.out.println(climbStairs2(<span class="number">3</span>));</span><br><span class="line">        System.out.println(climbStairs3(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            p = q;</span><br><span class="line">            q = r;</span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 傻递归</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> climbStairs2(n - <span class="number">1</span>) + climbStairs2(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾递归</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> climbStairs3Course(n, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs3Course</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将上一步的b 传给 a，a + b 传给 b</span></span><br><span class="line">        <span class="keyword">return</span> climbStairs3Course(n - <span class="number">1</span>, b, a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>方法2的递归太傻中间计算了太多的重复的值，递归千万不能这样用。</p><p>方法3中采用了尾递归的形式，相当于把上一步的结果缓存下来，可以重复使用。类似于方法一，这样的递归就很快速。</p><p>这道题目在前面我也写过，不过当时没用递归方法而已。</p></blockquote><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">arithmetic22</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 22. 括号生成</span></span><br><span class="line"><span class="comment">     * 题目：https://leetcode-cn.com/problems/generate-parentheses/</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(generateParenthesis1(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        recursion(n, n, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left   左括号数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right  右括号数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result 字符串结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, String result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左右括号为0，添加结果</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">            resultList.add(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左括号剩余可以添加左括号</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            recursion(left - <span class="number">1</span>, right, result + <span class="string">"("</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里限制右括号数量大于左括号的时候才能添加右括号，若不大于就添加必定不合法</span></span><br><span class="line">        <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">            recursion(left, right - <span class="number">1</span>, result + <span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. 翻转二叉树</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">arithmetic226</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 226. 翻转二叉树</span></span><br><span class="line"><span class="comment">     * 题目：https://leetcode-cn.com/problems/invert-binary-tree/description/</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右子树交换</span></span><br><span class="line">        TreeNode temp = root.right;</span><br><span class="line">        root.right = root.left;</span><br><span class="line">        root.left = temp;</span><br><span class="line">        <span class="comment">// 递归交换当前节点的左子树</span></span><br><span class="line">        invertTree1(root.left);</span><br><span class="line">        <span class="comment">// 递归交换当前节点的右子树</span></span><br><span class="line">        invertTree1(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h2>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈题集</title>
      <link href="/2020/06/24/java/arithmetic/2/"/>
      <url>/2020/06/24/java/arithmetic/2/</url>
      
        <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 题目：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</span></span><br><span class="line"><span class="comment">     * 题解：</span></span><br><span class="line"><span class="comment">     * https://blog.csdn.net/Zolewit/article/details/88863970</span></span><br><span class="line"><span class="comment">     * https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/</span></span><br><span class="line"><span class="comment">     * https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(largestRectangleArea1(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>&#125;));</span><br><span class="line">        System.out.println(largestRectangleArea2(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法一</span></span><br><span class="line"><span class="comment">     * 固定中间一个找两边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heights</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea1</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heights.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最大面积</span></span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i;</span><br><span class="line">            <span class="keyword">int</span> currentHeight = heights[i];</span><br><span class="line">            <span class="comment">// left &gt; 0 防止为第一个数据；寻找左边最后一个大于currentHeight的下标</span></span><br><span class="line">            <span class="keyword">while</span> (left &gt; <span class="number">0</span> &amp;&amp; heights[left - <span class="number">1</span>] &gt;= currentHeight) &#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> right = i;</span><br><span class="line">            <span class="comment">// right &lt; heights.length - 1 防止为最后一个数据；寻找右边最后一个大于currentHeight的下标</span></span><br><span class="line">            <span class="keyword">while</span> (right &lt; heights.length - <span class="number">1</span> &amp;&amp; heights[right + <span class="number">1</span>] &gt;= currentHeight) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxArea = Math.max(maxArea, (right - left + <span class="number">1</span>) * currentHeight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法二</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heights</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea2</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] newHeights = <span class="keyword">new</span> <span class="keyword">int</span>[heights.length + <span class="number">2</span>];</span><br><span class="line">        System.arraycopy(heights, <span class="number">0</span>, newHeights, <span class="number">1</span>, heights.length);</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;(heights.length);</span><br><span class="line">        deque.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; newHeights.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (newHeights[i] &lt; newHeights[deque.getLast()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> height = newHeights[deque.pollLast()];</span><br><span class="line">                <span class="keyword">int</span> width = i - deque.peekLast() - <span class="number">1</span>;</span><br><span class="line">                maxArea = Math.max(maxArea, height * width);</span><br><span class="line">            &#125;</span><br><span class="line">            deque.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>这个题目的第二种解法真的太妙了，有亿点东西，我在idea中一步步调试才弄明白</strong></p><p><img src="https://image.cclblog.cn/blog/20200624221318.png" alt=""></p></blockquote><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. 滑动窗口最大值</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 题目：https://leetcode-cn.com/problems/sliding-window-maximum/</span></span><br><span class="line"><span class="comment">     * 题解：https://leetcode.com/problems/sliding-window-maximum/discuss/65884/Java-O(n)-solution-using-deque-with-explanation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Arrays.toString(maxSlidingWindow1(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, <span class="number">3</span>)));</span><br><span class="line">        System.out.println(Arrays.toString(maxSlidingWindow2(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, <span class="number">3</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法一：遍历每个滑动窗口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow1(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums.length - k + 1 : 滑动窗口个数</span></span><br><span class="line">        <span class="keyword">int</span>[] rnums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + k; j++) &#123;</span><br><span class="line">                max = Math.max(max, nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            rnums[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rnums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法二：双端队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span> - k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 每当新数进来时，如果发现队列头部的数的下标，是窗口最左边数的下标，则扔掉</span></span><br><span class="line">            <span class="keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.peekFirst() == i - k) &#123;</span><br><span class="line">                deque.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把队列尾部所有比新数小的都扔掉，保证队列是降序的</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加入新数</span></span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">            <span class="comment">// 队列头部就是该窗口内第一大的</span></span><br><span class="line">            <span class="keyword">if</span> ((i + <span class="number">1</span>) &gt;= k) &#123;</span><br><span class="line">                res[i + <span class="number">1</span> - k] = nums[deque.peek()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组题集</title>
      <link href="/2020/06/23/java/arithmetic/1/"/>
      <url>/2020/06/23/java/arithmetic/1/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：https://leetcode-cn.com/problems/container-with-most-water/</span></span><br><span class="line"><span class="comment"> * 题解：https://leetcode-cn.com/problems/container-with-most-water/solution/container-with-most-water-shuang-zhi-zhen-fa-yi-do/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] test = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    System.out.println(maxArea2(test));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴力解法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> height</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea1</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">            maxArea = Math.max(maxArea, Math.min(height[i], height[j]) * (j - i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双指针法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> height</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea2</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = height.length - <span class="number">1</span>, maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        maxArea = height[i] &gt; height[j] ?</span><br><span class="line">                Math.max(maxArea, (j - i) * height[j--]) :</span><br><span class="line">                Math.max(maxArea, (j - i) * height[i++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：https://leetcode-cn.com/problems/move-zeroes/</span></span><br><span class="line"><span class="comment"> * 题解：https://leetcode-cn.com/problems/move-zeroes/solution/dong-hua-yan-shi-283yi-dong-ling-by-wang_ni_ma/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] test = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    moveZeroes1(test);</span><br><span class="line">    moveZeroes2(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 纪录0出现的个数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历数组将非0元素前提</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            nums[count++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 count-nums.length 全部置为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = count; i &lt; nums.length; i++) &#123;</span><br><span class="line">        nums[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(nums));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快慢指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) &#123;</span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">                nums[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Syste.out.println(Arrays.toString(nums));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 题目：https://leetcode-cn.com/problems/climbing-stairs/</span></span><br><span class="line"><span class="comment">    * 题解：https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(climbStairs(<span class="number">3</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           p = q;</span><br><span class="line">           q = r;</span><br><span class="line">           r = p + q;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> r;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 题目：https://leetcode-cn.com/problems/two-sum/</span></span><br><span class="line"><span class="comment">    * 解析：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(Arrays.toString(twoSum1(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>&#125;, <span class="number">6</span>)));</span><br><span class="line">       System.out.println(Arrays.toString(twoSum2(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>&#125;, <span class="number">6</span>)));</span><br><span class="line">       System.out.println(Arrays.toString(twoSum3(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>&#125;, <span class="number">6</span>)));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 暴力求解</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum1(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="comment">// 双重for循环遍历，将所有的可能全部列举，一一与target比较</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 两遍哈希表</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       Map&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="comment">// 遍历数组将数组中的值-下标保存到hashMap中</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           hashMap.put(nums[i], i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 遍历数组，如果hashMap中存在target - nums[i] 这个值&amp;&amp;该值的下标不等于i（防止数组中正好target - nums[i]为其本身，例如6 - 3 = 3），</span></span><br><span class="line">       <span class="comment">// 那么就立即返回结果</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (hashMap.containsKey(target - nums[i]) &amp;&amp; hashMap.get(target - nums[i]) != i) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, hashMap.get(target - nums[i])&#125;;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 一遍哈希表</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum3(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       Map&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="comment">// 一边将元素保存到hashMap中，一边同时进行检查，如果找到符合的条件立即返回</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (hashMap.containsKey(target - nums[i]) &amp;&amp; hashMap.get(target - nums[i]) != i) &#123;</span><br><span class="line">               <span class="comment">// 之所以&#123;hashMap.get(target - nums[i]), i&#125;而不是&#123;i, hashMap.get(target - nums[i])&#125;</span></span><br><span class="line">               <span class="comment">// 是因为hashMap最后的那个元素，i永远比hashMap.get(target - nums[i])大</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;hashMap.get(target - nums[i]), i&#125;;</span><br><span class="line">           &#125;</span><br><span class="line">           hashMap.put(nums[i], i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：https://leetcode-cn.com/problems/3sum/</span></span><br><span class="line"><span class="comment"> * 题解：https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(threeSum(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>&#125;));</span><br><span class="line">    System.out.println(threeSum(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    ArrayList&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">// 数组长度小于三，无意义</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 最小的都大于0，肯定不存在结果 a + b + c = 0;</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i&gt;0 防止i=0的时候 i-1=-1；去重，前一个值等于后一个值已经计算过，不能重复计算</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// l 指向i的前一个位置</span></span><br><span class="line">        <span class="keyword">int</span> l = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// r 指向数组的最后一个位置</span></span><br><span class="line">        <span class="keyword">int</span> r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// l 指针不能大于r</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">// 计算这三个数的值</span></span><br><span class="line">            <span class="keyword">int</span> result = nums[i] + nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 等于0添加到列表中</span></span><br><span class="line">                list.add(Arrays.asList(nums[i], nums[l], nums[r]));</span><br><span class="line">                <span class="comment">// 去重，防止存在重复元素，导致结果重复</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>]) &#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 去重，同理上</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) &#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 左指针++</span></span><br><span class="line">                l++;</span><br><span class="line">                <span class="comment">// 右指针--</span></span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// a + b + c &gt; 0 说明这个 c太大 要减小 自然 r-- 指向c的前一个位置 （注意这是排过序的数组）</span></span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 同理上</span></span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>这个题目真的需要自己去思考，debug调试一下，我写的注释仅仅是我个人理解。</strong></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题集（第一周）</title>
      <link href="/2020/06/22/java/question/1/"/>
      <url>/2020/06/22/java/question/1/</url>
      
        <content type="html"><![CDATA[<h1 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h1><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p><strong>假如某个JAVA进程的JVM参数配置如下：</strong><br><strong>-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3,</strong><br><strong>请问eden区最终分配的大小是多少？</strong></p><ul><li><strong>A：</strong>64M</li><li><strong>B：</strong>500M</li><li><strong>C：</strong>300M</li><li><strong>D：</strong>100M</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p>-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3,</p><p>-Xms1G    设置Java堆最小值为1G    </p><p>-Xmx2G    设置Java堆最大值为2G</p><p>-Xmn500M    设置新生代大小为500M（一个Eden区，两个Survivor区）</p><p>-XX:MaxPermSize=64M    设置永久代大小为64M</p><p>-XX:+UseConcMarkSweepGC     设置使用CMS收集器</p><p>-XX:SurvivorRatio=3    设置Eden区与Survivor区大小的比例</p><p>本题看新生代大小，新生代为500M，三个区比例为3：1：1，很容易计算出Eden大小为300M</p></blockquote><p><strong>对于JVM内存配置参数：</strong></p><blockquote><p><strong>-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3</strong></p></blockquote><p><strong>,其最小内存值和Survivor区总大小分别是（）</strong></p><ul><li><strong>A：</strong>5120m，1024m</li><li><strong>B：</strong>5120m，2048m</li><li><strong>C：</strong>10240m，1024m</li><li><strong>D：</strong>10240m，2048m</li></ul><blockquote><p><strong>解析：</strong></p><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p>-Xmx：最大堆大小</p><p>-Xms：初始堆大小</p><p>-Xmn:年轻代大小</p><p>-XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值</p><p>年轻代5120m， Eden：Survivor=3，Survivor区大小=1024m（Survivor区有两个，即将年轻代分为5份，每个Survivor区占一份），总大小为2048m。</p><p>-Xms初始堆大小即最小内存值为10240m</p></blockquote><p><strong>（多选）关于OutOfMemoryError，下面说法正确的是（）？</strong></p><ul><li>java.lang.OutOfMemoryError: PermGen space 增加-XX:MaxPermSize这个参数的值的话，这个问题通常会得到解决。</li><li>java.lang.OutOfMemoryError: Requested array size exceeds VM limit当你正准备创建一个超过虚拟机允许的大小的数组时，这条错误将会出现</li><li>java.lang.OutOfMemoryError: Java heap space 一般情况下解决这个问题最快的方法就是通过-Xmx参数来增加堆的大小</li><li>java.lang.OutOfMemoryError: nativeGetNewTLA这个异常只有在jRockit虚拟机时才会碰到</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ABC</span></span><p><strong>解析：</strong></p><p>A：属于运行时常量池导致的溢出，设置-XX：MaxPermSize可以解决这个问题，</p><p>B：属于堆空间不足导致的错误，解决方式和C相同，</p><p>C：属于java堆内存问题，一般的手段是通过内存映像分析工具，对Dump出来的堆转储存快照进行分析，重点是确认内存中的对象是否是有必要的，也就是要判断是出现了内存泄漏，还是出现了内存溢出。如果是内存泄露，通过工具检查泄露对象打GC Roots的引用链信息，可以准确的确定出泄露代码的位置，不存在泄露，就应该检查虚拟机的堆参数，如果可以继续调大，可以设置-Xmx解决问题</p><p>D：java.lang.OutOfMemoryError: nativeGetNewTLA指当虚拟机不能分配新的线程本地空间(Thread Local Area）的时候错误信息，此错误是线程申请一个新的TLA时产生的，这个异常一般只会发生在jRockit虚拟机，只有过于绝对。</p></blockquote><p><strong>下面有关java classloader说法错误的是（）?</strong></p><ul><li><strong>A：</strong> Java默认提供的三个ClassLoader是BootStrap ClassLoader，Extension ClassLoader，App ClassLoader、</li><li><strong>B：</strong>ClassLoader使用的是双亲委托模型来搜索类的</li><li><strong>C：</strong>VM在判定两个class是否相同时，只用判断类名相同即可，和类加载器无关</li><li><strong>D：</strong>ClassLoader就是用来动态加载class文件到内存当中用的</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p>比较两个类是否相等，只有这两个类是由同一个类加载器加载才有意义。否则，即使这两个类是来源于同一个Class文件，只要加载它们的类加载器不同，那么这两个类必定不相等。</p><p>补充：</p><p><strong>1.</strong> <strong>什么是类加载器？</strong></p><p>把类加载的过程放到Java虚拟机外部去实现，让应用程序决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。  </p><p><strong>2.</strong> <strong>有哪些类加载器，分别加载哪些类</strong></p><p>类加载器按照层次，从顶层到底层，分为以下三种：<br>(1)启动类加载器 : 它用来加载 Java 的核心库，比如String、System这些类<br>(2)扩展类加载器 : 它用来加载 Java 的扩展库。</p><p>(3) 应用程序类加载器 : 负责加载用户类路径上所指定的类库，一般来说，Java 应用的类都是由它来完成加载的。</p><p><strong>3.</strong> <strong>双亲委派模型</strong></p><p>我们应用程序都是由以上三种类加载器互相配合进行加载的，还可以加入自己定义的类加载器。称为 <strong>类加载器的双亲委派模型</strong> ，这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用 <strong>组合关系</strong> 来复用父加载器的。</p><p><strong>4.</strong> <strong>双亲委托模型的工作原理</strong></p><p>是当一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法加载这个加载请求的时候，子加载器才会尝试自己去加载。</p><p><strong>5.</strong> <strong>使用双亲委派模型好处？（原因）</strong></p><p>第一：可以避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载。</p><p>第二：考虑到安全因素，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时被加载，所以用户自定义类是无法加载一个自定义的类装载器。</p></blockquote><p><strong>（多选）关于Java中的ClassLoader下面的哪些描述是错误的：(   )</strong></p><ul><li><strong>A：</strong>默认情况下，Java应用启动过程涉及三个ClassLoader: Boostrap, Extension, System</li><li><strong>B：</strong>一般的情况不同ClassLoader装载的类是不相同的，但接口类例外，对于同一接口所有类装载器装载所获得的类是相同的</li><li><strong>C：</strong>类装载器需要保证类装载过程的线程安全</li><li><strong>D：</strong>ClassLoader的loadClass在装载一个类时，如果该类不存在它将返回null</li><li><strong>E：</strong>ClassLoader的父子结构中，默认装载采用了父优先</li><li><strong>F：</strong>所有ClassLoader装载的类都来自CLASSPATH环境指定的路径</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BDF</span></span><p><strong>解析：</strong></p><p><strong>A.Java系统提供3种类加载器：启动类加载器（Bootstrap ClassLoader）  扩展类加载器（Extension ClassLoader） 应用程序类加载器（Application ClassLoader）. A正确</strong></p><p><strong>B.《深入理解Java虚拟机》P228：对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类必定不相等。</strong>接口类是一种特殊类，因此对于同一接口不同的类装载器装载所获得的类是不相同的。<strong>B错误</strong></p><p><strong>C.类只需加载一次就行，因此要保证类加载过程线程安全，防止类加载多次。C正确</strong></p><p><strong>D.</strong> <strong>Java程序的类加载器采用双亲委派模型，实现双亲委派的代码集中在java.lang.ClassLoader的loadClass()方法中，此方法实现的大致逻辑是：先检查是否已经被加载，若没有加载则调用父类加载器的loadClass()方法，若父类加载器为空则默认使用启动类加载器作为父类加载器。如果父类加载失败，抛出ClassNotFoundException异常。D错误</strong></p><p><strong>E.双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。E正确</strong></p><p><strong>F.应用程序类加载器（Application ClassLoader）负责加载</strong>用户类路径（ClassPath）上所指定的类库，不是所有的ClassLoader都加载此路径。F错误</p></blockquote><p><strong>以下代码执行的结果显示是多少（）？</strong></p><ul><li><strong>A：</strong>505000</li><li><strong>B：</strong>0</li><li><strong>C：</strong>运行时错误</li><li><strong>D：</strong>5050</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>count = count++  原理是 temp = count； count = count+1 ； count = temp；   因此count始终是0 这仅限于java 与c是不一样的</p><p>count=count++就是先把局部变量表中count的值0放入操作数栈中，然后直接对局部变量表中的count加1，然后再把操作数栈中的0出栈赋值给局部变量表中的count，最终局部变量表中的count值仍为0</p></blockquote><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><strong>在java中，下列对继承的说法，正确的是（ ）</strong></p><ul><li><strong>A：</strong>子类能继承父类的所有成员</li><li><strong>B：</strong>子类继承父类的非私有方法和状态</li><li><strong>C：</strong>子类只能继承父类的public方法和状态</li><li><strong>D：</strong>子类只能继承父类的方法</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>使用反射可以看出子类是继承了父类的私有方法的(不管是否是final)，只是直接调用父类的私有方法是不可以的，但是利用反射的方式可以调用。字段同理。</p><p><strong>其实private方法是可以继承的，只是不能调用</strong></p></blockquote><p><strong>有如下一段程序：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        Test test=<span class="keyword">new</span> Test();</span><br><span class="line">        Test testObject=<span class="keyword">new</span> Test();</span><br><span class="line">        test.getNext();</span><br><span class="line">        testObject.getNext();</span><br><span class="line">        System.out.println(testObject.getNext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>请问最后打印出来的是什么？（）</strong></p><ul><li><strong>A：</strong>2</li><li><strong>B：</strong>3</li><li><strong>C：</strong>4</li><li><strong>D：</strong>5</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>return i++, 先返回i，然后i+1；</p><p>第一次调用getNext()方法时，返回的是1，但此时i=2；</p><p>第二次调用 getNext()方法时，返回的是2，但此时i=3；</p><p>第三次调用 getNext()方法时，返回的是3，但此时i=4；</p></blockquote><p><strong>（多选）下面的switch语句中，x可以是哪些类型的数据：()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>long</li><li><strong>B：</strong>char</li><li><strong>C：</strong>float</li><li><strong>D：</strong>byte</li><li><strong>E：</strong>double</li><li><strong>F：</strong>Object</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BD</span></span><p><strong>解析：</strong></p><p>jdk1.7之前byte,short ,int ,char</p><p>jdk1.7之后加入String </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str =</span><br><span class="line"><span class="string">""</span>;</span><br><span class="line">System.out.print(str.split(<span class="string">","</span>).length);</span><br></pre></td></tr></table></figure><p><strong>输出结果为：</strong></p><ul><li><strong>A：</strong>0</li><li><strong>B：</strong>1</li><li><strong>C：</strong>出现异常</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>String split() 这个方法默认返回一个数组，如果没有找到分隔符，会把整个字符串当成一个长度为1的字符串数组，返回到结果， 所以此处结果就是1 。</p></blockquote><p><strong>以下程序执行的结果是：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span>&#123;</span><br><span class="line">    Y y=<span class="keyword">new</span> Y();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">X</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"X"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Y</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Y"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Z</span> <span class="keyword">extends</span> <span class="title">X</span></span>&#123;</span><br><span class="line">    Y y=<span class="keyword">new</span> Y();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Z</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Z"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Z();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A：ZYXX</li><li>B：ZYXY</li><li>C：YXYZ</li><li>D：XYZX</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p><strong>java对象初始化顺序</strong><br>先说结论：</p><ol><li>父类静态代码块，父类静态成员变量（同级，按代码顺序执行）</li><li>子类静态代码块，子类静态成员变量（同级，按代码顺序执行）</li><li>父类普通代码块，父类普通成员变量（同级，按代码顺序执行）</li><li>父类构造方法</li><li>子类普通代码块，子类普通成员变量（同级，按代码顺序执行）</li><li>子类构造方法</li></ol><p>注意点：</p><ol><li>静态内容只在类加载时执行一次，之后不再执行。</li><li>默认调用父类的无参构造方法，可以在子类构造方法中利用super指定调用父类的哪个构造方法。</li></ol><hr><p><strong>（1）初始化父类的普通成员变量和代码块，执行  Y y=new</strong> <strong>Y();</strong>  <strong>输出Y</strong> </p><p><strong>（2）再执行父类的构造方法；输出X</strong></p><p><strong>（3）</strong> <strong>初始化子类的普通成员变量和代码块，执行  Y y=new</strong>   <strong>Y();</strong>  <strong>输出Y</strong> </p><p><strong>（4）再执行子类的构造方法；输出Z</strong></p></blockquote><p><strong>设三个整型变量 x = 1 , y = 2 , z = 3，则表达式 y＋＝z－－/＋＋x 的值是( )。</strong></p><ul><li><strong>A：</strong>3</li><li><strong>B：</strong>3.5</li><li><strong>C：</strong>4</li><li><strong>D：</strong>5</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>y是2，返回的结果是2+（z–/++x），再来看z–/++x，结果应该是3/2，但是因为x,y,z都是int型的，所以最后的返回值只能是int，这时候z–/++x的值就是1，那么最终的结果就是2+1=3</p></blockquote><p><strong>instanceof运算符能够用来判断一个对象是否为:</strong></p><ul><li><strong>A：</strong>一个类的实例</li><li><strong>B：</strong>一个实现指定接口的类的实例</li><li><strong>C：</strong>全部正确</li><li><strong>D：</strong>一个子类的实例</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p><strong>instance是java的二元运算符，用来判断他左边的对象是否为右面类（接口，抽象类，父类）的实例</strong></p></blockquote><p><strong>以下代码将打印出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    String classFile = <span class="string">"com.jd."</span>. replaceAll(<span class="string">"."</span>, <span class="string">"/"</span>) + <span class="string">"MyClass.class"</span>;</span><br><span class="line">    System.out.println(classFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>com. jd</li><li><strong>B：</strong>com/jd/MyClass.class</li><li><strong>C：</strong>///////MyClass.class</li><li><strong>D：</strong>com.jd.MyClass</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p>由于replaceAll方法的第一个参数是一个正则表达式，而”.”在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成”/“。如果想替换的只是”.”，那么久要写成”\.”.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1=<span class="number">1</span>,b2=<span class="number">2</span>,b3,b6; </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span> b4=<span class="number">4</span>,b5=<span class="number">6</span>; </span><br><span class="line">b6=b4+b5; </span><br><span class="line">b3=(b1+b2); </span><br><span class="line">System.out.println(b3+b6);</span><br></pre></td></tr></table></figure><p><strong>关于上面代码片段叙述正确的是（）</strong></p><ul><li><strong>A：</strong>输出结果：13</li><li><strong>B：</strong>语句：b6=b4+b5编译出错</li><li><strong>C：</strong>语句：b3=b1+b2编译出错</li><li><strong>D：</strong>运行期抛出异常</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p>被final修饰的变量是常量，这里的b6=b4+b5可以看成是b6=10；在编译时就已经变为b6=10了</p><p>而b1和b2是byte类型，java中进行计算时候将他们提升为int类型，再进行计算，b1+b2计算后已经是int类型，赋值给b3，b3是byte类型，类型不匹配，编译不会通过，需要进行强制转换。</p><p>Java中的byte，short，char进行计算时都会提升为int类型。</p></blockquote><p><strong>下面有关java基本类型的默认值和取值范围，说法错误的是？</strong></p><ul><li><strong>A：</strong>字节型的类型默认值是0，取值范围是-2^7—2^7-1</li><li><strong>B：</strong>boolean类型默认值是false，取值范围是true\false</li><li><strong>C：</strong>字符型类型默认是0，取值范围是-2^15 —2^15-1</li><li><strong>D：</strong>long类型默认是0，取值范围是-2^63—2^63-1</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><table><thead><tr><th></th><th>More Actions  默认值</th><th>存储需求（字节）</th><th>取值范围</th><th>示例</th></tr></thead><tbody><tr><td>byte</td><td>0</td><td>1</td><td>-2^7—2^7-1</td><td>byte b=10;</td></tr><tr><td>char</td><td>‘ \u0000′</td><td>2</td><td>0—2^16-1</td><td>char c=’c’ ;</td></tr><tr><td>short</td><td>0</td><td>2</td><td>-2^15—2^15-1</td><td>short s=10;</td></tr><tr><td>int</td><td>0</td><td>4</td><td>-2^31—2^31-1</td><td>int i=10;</td></tr><tr><td>long</td><td>0</td><td>8</td><td>-2^63—2^63-1</td><td>long o=10L;</td></tr><tr><td>float</td><td>0.0f</td><td>4</td><td>-2^31—2^31-1</td><td>float f=10.0F</td></tr><tr><td>double</td><td>0.0d</td><td>8</td><td>-2^63—2^63-1</td><td>double d=10.0;</td></tr><tr><td>boolean</td><td>false</td><td>1</td><td>true\false</td><td>boolean flag=true;</td></tr></tbody></table></blockquote><p><strong>java有8种基本类型，请问byte、int、long、char、float、double、boolean各占多少个字节？</strong></p><ul><li><strong>A：</strong>1 2 8 2 4 8 1</li><li><strong>B：</strong>1 4 8 2 4 8 1</li><li><strong>C：</strong>1 4 4 2 4 4 2</li><li><strong>D：</strong>1 4 4 2 4 8 2</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span></blockquote><p><strong>对于abstract声明的类，下面说法正确的是</strong></p><ul><li><strong>A：</strong>可以实例化</li><li><strong>B：</strong>不可以被继承</li><li><strong>C：</strong>子类为abstract</li><li><strong>D：</strong>只能被继承</li><li><strong>E：</strong>可以被抽象类继承</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：E</span></span><p><strong>解析：</strong></p><p>A：抽象类不能实例化，因为有抽象方法未实现</p><p>B：可以被继承。派生类可以实现抽象方法</p><p>C：子类可以是抽象的，也可以非抽象的</p><p>D：只能被继承说法太肯定，不正确</p><p>E：可以被抽象类继承，也可以被非抽象类继承</p></blockquote><p><strong>（多选）final、finally和finalize的区别中，下述说法正确的有？</strong></p><ul><li><strong>A：</strong>final用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。</li><li><strong>B：</strong>finally是异常处理语句结构的一部分，表示总是执行。</li><li><strong>C：</strong>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源的回收，例如关闭文件等。</li><li><strong>D：</strong>引用变量被final修饰之后，不能再指向其他对象，它指向的对象的内容也是不可变的。</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AB</span></span><p><strong>解析：</strong></p><p>A，D考的一个知识点，final修饰变量，变量的引用（也就是指向的地址）不可变，但是引用的内容可以变（地址中的内容可变）。</p><p>B，finally表示总是执行。但是其实finally也有不执行的时候，但是这个题不要扣字眼。</p><ol><li><p>在try中调用System.exit(0)，强制退出了程序，finally块不执行。</p></li><li><p>在进入try块前，出现了异常，finally块不执行。</p></li></ol><p>C，finalize方法，这个选项错就错在，<strong>这个方法一个对象只能执行一次，只能在第一次进入被回收的队列，而且对象所属于的类重写了finalize方法才会被执行。</strong>第二次进入回收队列的时候，不会再执行其finalize方法，而是直接被二次标记，在下一次GC的时候被GC。</p></blockquote><p><strong>（多选）以下关于final关键字说法错误的是（）</strong></p><ul><li><strong>A：</strong>final是java中的修饰符，可以修饰类、接口、抽象类、方法和属性</li><li><strong>B：</strong>final修饰的类肯定不能被继承</li><li><strong>C：</strong>final修饰的方法不能被重载</li><li><strong>D：</strong>final修饰的变量不允许被再次赋值</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AC</span></span><p><strong>解析：</strong></p><p>1.final修饰变量，则等同于常量</p><p>2.final修饰方法中的参数，称为最终参数。</p><p>3.final修饰类，则类不能被继承</p><p>4.final修饰方法，则方法不能被重写。</p><p>5.final 不能修饰抽象类</p><p>6.final修饰的方法可以被重载 但不能被重写</p></blockquote><p><strong>（多选）下面属于java包装类的是？</strong></p><ul><li><strong>A：</strong>String</li><li><strong>B：</strong>Long</li><li><strong>C：</strong>Character</li><li><strong>D：</strong>Short</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BCD</span></span><p><strong>解析：</strong></p><p>包装类是针对 <strong>基本数据类型</strong> 的。</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table></blockquote><p><strong>（多选）在java中重写方法应遵循规则的包括（）</strong></p><ul><li><strong>A：</strong>访问修饰符的限制一定要大于被重写方法的访问修饰符</li><li><strong>B：</strong>可以有不同的访问修饰符</li><li><strong>C：</strong>参数列表必须完全与被重写的方法相同</li><li><strong>D：</strong>必须具有不同的参数列表</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BC</span></span><p><strong>解析：</strong></p><p>A：错在访问修饰符还可以相等。</p><p><strong>方法重写的规则：</strong></p><hr><ul><li>​    1）参数列表必须完全与被重写方法的相同；     </li><li>​    2）<strong>返回类型必须完全与被重写方法的返回类型相同；（备注:这条信息是标准的重写方法的规则,但是在java1.5 版本之前返回类型必须一样,1.5(包含) 版本之后java放宽了限制,返回类型必须小于或者等于父类方法的返回类型 才有了子类返回类型小于等于父类方法返回类型。</strong>。    </li><li>​       3）访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。     </li><li>​    4）父类的成员方法只能被它的子类重写。     </li><li>​    5）声明为final的方法不能被重写。     </li><li>​    6）声明为static的方法不能被重写，但是能够被再次声明。     </li><li>​    7）子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。     </li><li>​    8）子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。     </li><li>​       9）重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。     </li><li>​    10）构造方法不能被重写。     </li><li>​    11）如果不能继承一个方法，则不能重写这个方法。</li></ul></blockquote><p><strong>以下代码段执行后的输出结果为()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = -<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y = -<span class="number">12</span>;</span><br><span class="line">System.out.println(y % x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A：-1</li><li>B：2</li><li>C：1</li><li>D：-2</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p>取模运算，结果的符号和被除数符号一致，切记切记</p></blockquote><p><strong>（多选）以下关于final关键字说法错误的是</strong></p><ul><li><strong>A：</strong>final是java中的修饰符，可以修饰类、接口、抽象类、方法和属性</li><li><strong>B：</strong>final修饰的类肯定不能被继承</li><li><strong>C：</strong>final修饰的方法不能被重载</li><li><strong>D：</strong>final修饰的变量不允许被再次赋值</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AC</span></span><p><strong>解析：</strong></p><ul><li><p>final修饰类、方法、属性！不能修饰抽象类，因为抽象类一般都是需要被继承的，final修饰后就不能继承了。</p></li><li><p>final修饰的方法不能被重写而不是重载！ </p></li><li><p>final修饰属性，此属性就是一个常量，不能被再次赋值！ </p></li><li><p>final也不能修饰接口，接口可以只能被public&amp;abstract修饰</p></li><li><p>final如果修饰的是基本类型的变量，那么这个变量就表示为一个常数，只能赋值一次，要么在定义时赋值，要么在初始化时赋值；final修饰应用类型的变量是，变量不能再次被赋值意思是变量的地址（引用）不可以被改变，当变量所指向的内容可以被改变。</p></li></ul></blockquote><p><strong>静态内部类不可以直接访问外围类的非静态数据，而非静态内部类可以直接访问外围类的数据，包括私有数据。（ ）</strong></p><ul><li><strong>A：</strong>正确</li><li><strong>B：</strong>错误</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><ol><li><p><strong>静态内部类：</strong></p><ol><li>静态内部类本身可以访问外部的静态资源，包括静态私有资源。但是不能访问非静态资源，可以不依赖外部类实例而实例化。</li></ol></li><li><p><strong>成员内部类：</strong></p><ol><li>成员内部类本身可以访问外部的所有资源，但是自身不能定义静态资源，因为其实例化本身就还依赖着外部类。</li></ol></li><li><p><strong>局部内部类：</strong></p><ol><li>局部内部类就像一个局部方法，不能被访问修饰符修饰，也不能被static修饰。</li><li>局部内部类只能访问所在代码块或者方法中被定义为final的局部变量。</li></ol></li><li><p><strong>匿名内部类：</strong></p><ol><li>没有类名的内部类，不能使用class，extends和implements，没有构造方法。</li></ol><p>​    2.  多用于GUI中的事件处理。</p><p>​    3.  不能定义静态资源</p><p>​    4.  只能创建一个匿名内部类实例。</p><p>​    5. 一个匿名内部类一定是在new后面的，这个匿名类必须继承一个父类或者实现一个接口。</p><p>​    6. 匿名内部类是局部内部类的特殊形式，所以局部内部类的所有限制对匿名内部类也有效。</p></li></ol></blockquote><p><strong>有如下4条语句：()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i01=<span class="number">59</span>;</span><br><span class="line"><span class="keyword">int</span> i02=<span class="number">59</span>;</span><br><span class="line">Integer i03=Integer.valueOf(<span class="number">59</span>);</span><br><span class="line">Integer i04=<span class="keyword">new</span> Integer(<span class="number">59</span>);</span><br></pre></td></tr></table></figure><p><strong>以下输出结果为false的是:</strong></p><ul><li>System.out.println(i01==i02);</li><li>System.out.println(i01==i03);</li><li>System.out.println(i03==i04);</li><li>System.out.println(i02==i04);</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><ul><li>无论如何，Integer与new Integer不会相等。不会经历拆箱过程，</li><li>两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false；java在编译Integer i2 = 128的时候,被翻译成-&gt; Integer i2 = Integer.valueOf(128);而valueOf()函数会对-128到127之间的数进行缓存</li></ul><blockquote><p>Integer.valueOf方法中也有判断，如果传递的整型变量&gt;= -128并且小于127时会返回IntegerCache类中一个静态数组中的某一个对象， 否则会返回一个新的Integer对象,代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li>两个都是new出来的,都为false</li><li>int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比</li></ul></blockquote><p><strong>定义有StringBuffer s1=new StringBuffer(10);s1.append(“1234”)则s1.length()和s1.capacity()分别是多少?</strong></p><ul><li><strong>A：</strong>4   10</li><li><strong>B：</strong>4   4</li><li><strong>C：</strong>10  10</li><li><strong>D：</strong>10  4</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>StringBuffer s = new StringBuffer(x);  x为初始化容量长度</p><p>s.append(“Y”); “Y”表示长度为y的字符串</p><p>length始终返回当前长度即y；</p><p>对于s.capacity()：</p><p>1.当y&lt;x时，值为x</p><p>以下情况，容器容量需要扩展</p><p>2.当x&lt;y&lt;2<em>x+2时，值为 2</em>x+2</p><p>3.当y&gt;2x+2时，值为y</p></blockquote><p><strong>（多选）有关静态初始化块说法正确的是？</strong></p><ul><li><strong>A：</strong>无法直接调用静态初始化块</li><li><strong>B：</strong>在创建第一个实例前或引用任何静态成员之前，将自动调用静态初始化块来初始化</li><li><strong>C：</strong>静态初始化块既没有访问修饰符，也没有参数</li><li><strong>D：</strong>在程序中，用户可以控制合适执行静态初始化块</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ABC</span></span><p><strong>解析：</strong></p><p><strong>java对象初始化顺序</strong><br>先说结论：</p><ol><li>父类静态代码块，父类静态成员变量（同级，按代码顺序执行）</li><li>子类静态代码块，子类静态成员变量（同级，按代码顺序执行）</li><li>父类普通代码块，父类普通成员变量（同级，按代码顺序执行）</li><li>父类构造方法</li><li>子类普通代码块，子类普通成员变量（同级，按代码顺序执行）</li><li>子类构造方法</li></ol><p>注意点：</p><ol><li>静态内容只在类加载时执行一次，之后不再执行。</li><li>默认调用父类的无参构造方法，可以在子类构造方法中利用super指定调用父类的哪个构造方法。</li></ol></blockquote><p><strong>执行如下程序代码</strong></p><p>char chr = 127;</p><p>int sum = 200;</p><p>chr += 1;</p><p>sum += chr;</p><p>后，sum的值是   ; （     ）</p><p>备注：同时考虑c/c++和Java的情况的话</p><ul><li><strong>A：</strong>72</li><li><strong>B：</strong>99</li><li><strong>C：</strong>328</li><li><strong>D：</strong>327</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span> <p><strong>解析：</strong></p><p>java中只有byte, boolean是一个字节, char是两个字节, 所以对于java来说127不会发生溢出, 输出328</p><p>但是对于c/c++语言来说, char是一个字节, 会发生溢出, 对127加一发生溢出,  0111 1111 –&gt; 1000 0000, 1000 0000为补码-128, 所以结果为200-128=72</p></blockquote><p><strong>下列关于包（package）的描述，正确的是（）</strong></p><ul><li><strong>A：</strong>包（package）是Java中描述操作系统对多个源代码文件组织的一种方式。</li><li><strong>B：</strong>import语句将所对应的Java源文件拷贝到此处执行。</li><li><strong>C：</strong>包（package）是Eclipse组织Java项目特有的一种方式。</li><li><strong>D：</strong>定义在同一个包（package）内的类可以不经过import而直接相互使用。</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span>        <p><strong>解析：</strong></p><p>1、为了更好地组织类，Java提供了包机制。包是类的容器，用于分隔类名空间。如果没有指定包名，所有的示例都属于一个默认的无名包。Java中的包一般均包含相关的类，java是跨平台的，所以java中的包和操作系统没有任何关系，java的包是用来组织文件的一种虚拟文件系统。A错</p><p>2、import语句并没有将对应的java源文件拷贝到此处仅仅是引入，告诉编译器有使用外部文件，编译的时候要去读取这个外部文件。B错<br>3、Java提供的包机制与IDE没有关系。C错<br>4、定义在同一个包（package）内的类可以不经过import而直接相互使用。        </p></blockquote><p><strong>（多选）哪个是不正确的字符常量？</strong></p><ul><li><strong>A：</strong>”\n”</li><li><strong>B：</strong>”1”</li><li><strong>C：</strong>”a”</li><li><strong>D：</strong>”\101”</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ABCD</span></span><p>解析：文字游戏注意是<strong>字符常量（’’）</strong>而不是<strong>字符串常量（””）</strong></p></blockquote><p><strong>（多选）以下关于JAVA语言异常处理描述正确的有？</strong></p><ul><li><strong>A：</strong>throw关键字可以在方法上声明该方法要抛出的异常。</li><li><strong>B：</strong>throws用于抛出异常对象。</li><li><strong>C：</strong>try是用于检测被包住的语句块是否出现异常，如果有异常，则抛出异常，并执行catch语句。</li><li><strong>D：</strong>finally语句块是不管有没有出现异常都要执行的内容。<br>在try块中不可以抛出异常</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：CD</span></span><p><strong>解析：</strong></p><p>Java语言中的异常处理包括声明异常、抛出异常、捕获异常和处理异常四个环节。</p><ul><li><p>throws关键字可以在方法上声明该方法要抛出的异常，然后在方法内部通过throw抛出异常对象。<strong>A选项应该为throws B选项应该为throw</strong>。</p></li><li><p>C选项不严谨，这个异常不是用try抛出来的，而是用了try能检测到底层抛出的异常，然后进行处理。这里应该用“<strong>捕获</strong>”这个异常才对。</p><p>这个“如果有异常，则抛出异常”。在捕获异常的时候使用throw，才会抛出这个异常，否则只是捕获到，而不是抛出。这个是需要显式写出来的。</p><p>但是答案中存在，忽略这个细节。AB错误太明显。</p></li></ul></blockquote><p><strong>下列语句正确的是：</strong></p><ul><li><strong>A：</strong>形式参数可被字段修饰符修饰</li><li><strong>B：</strong>形式参数不可以是对象</li><li><strong>C：</strong>形式参数为方法被调用时真正被传递的参数</li><li><strong>D：</strong>形式参数可被视为local variable</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p><img src="https://image.cclblog.cn/blog/20200623100219.png" alt=""></p></blockquote><p><strong>关于C++/JAVA类中static 成员和对象成员的说法正确的是？</strong></p><ul><li><strong>A：</strong>static 成员变量在对象构造时生成</li><li><strong>B：</strong>static 成员函数在对象成员函数中无法调用</li><li><strong>C：</strong>虚成员函数不可能是static 成员函数</li><li><strong>D：</strong>static 成员函数不能访问static 成员变量</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><ul><li>static为成员变量或函数，在类初始化是加载完成，可以被成员函数调用或访问</li><li>static成员函数既可以通过类名直接调用，也可以通过对象名进行调用</li><li>虚函数是C++中的，虚函数不可能是static的</li><li>static成员函数可以访问static成员变量</li></ul></blockquote><p><strong>给定以下JAVA代码，这段代码运行后输出的结果是（）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aMethod</span><span class="params">(<span class="keyword">int</span> i)</span><span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"exception in a Method"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">"finally"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            aMethod(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.printf(<span class="string">"exception in main"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>exception in main finished</li><li><strong>B：</strong>finally finished</li><li><strong>C：</strong>exception in main finally</li><li><strong>D：</strong>finally exception in main finished</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>题目中是i/10 不是 10/i 绝对不会报异常</p><p>1、finally块一定会执行，无论是否try…catch。</p><p>2、finally前有return，会先执行return语句，并保存下来，再执行finally块，最后return。</p><p>3、finally前有return、finally块中也有return，先执行前面的return，保存下来，再执行finally的return，覆盖之前的结果，并返回。</p></blockquote><p><strong>What is the result?</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.print(c);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] argv )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( foo(<span class="string">'A'</span>); foo(<span class="string">'B'</span>) &amp;&amp; (i &lt; <span class="number">2</span>); foo(<span class="string">'C'</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            i++ ;</span><br><span class="line">            foo(<span class="string">'D'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>ABDCBDCB</li><li><strong>B：</strong>ABCDABCD</li><li><strong>C：</strong>Compilation fails.</li><li><strong>D：</strong>An exception is thrown at runtime.</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>for(条件1;条件2;条件3) {</p><p>​    //语句</p><p>}</p><p>执行顺序是条件1-&gt;条件2-&gt;语句-&gt;条件3-&gt;条件2-&gt;语句-&gt;条件3-&gt;条件2……..</p><p>如果条件2为true，则一直执行。如果条件2位false，则for循环结束21. </p></blockquote><p><strong>Which lines of the following will produce an error?</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="keyword">byte</span> a1 = <span class="number">2</span>, a2 = <span class="number">4</span>, a3;</span><br><span class="line"><span class="number">2</span>. <span class="keyword">short</span> s = <span class="number">16</span>;</span><br><span class="line"><span class="number">3</span>. a2 = s;</span><br><span class="line"><span class="number">4</span>. a3 = a1 * a2;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>Line 3 and Line 4</li><li><strong>B：</strong>Line 1 only</li><li><strong>C：</strong>Line 3 only</li><li><strong>D：</strong>Line 4 only</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>short类型转为byte类型出错</p><p>a1*a2结果为int类型，转为byte类型出错</p><p><strong>java中如果碰到char、byte和short参与运算时，会自动将这些值转换为int类型然后再进行运算。这里a1和a2就自动转为int类型了，结果也为Int类型。把一个int类型赋值给byte需要转型。</strong></p></blockquote><p><strong>What is displayed when the following is executed;</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1=-<span class="number">0.5</span>;</span><br><span class="line">System.out.println(<span class="string">"Ceil d1="</span>+Math.ceil(d1));</span><br><span class="line">System.out.println(<span class="string">"floor d1="</span>+Math.floor(d1));</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>Ceil d1=-0.0<br>floor d1=-1.0</li><li><strong>B：</strong>Ceil d1=0.0<br>floor d1=-1.0</li><li><strong>C：</strong>Ceil d1=-0.0<br>floor d1=-0.0</li><li><strong>D：</strong>Ceil d1=0.0<br>floor d1=0.0</li><li><strong>E：</strong>Ceil d1=0<br>floor d1=-1</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p><strong>ceil：天花板数，向上取整。</strong></p><p><strong>floor：地板数，向下取整</strong></p><p>这里主要是有一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Math.ceil(d1) `</span><br></pre></td></tr></table></figure><p>ceil 方法上有这么一段注释：If the argument value is less than zero but greater than -1.0, then the result is negative zero</p><p>如果参数小于0且大于-1.0，结果为 -0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Math.floor(d1)`</span><br></pre></td></tr></table></figure><p>ceil 和 floor 方法 上都有一句话：If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as  the argument，意思为：如果参数是 NaN、无穷、正 0、负 0，那么结果与参数相同，</p><p>如果是 -0.0，那么其结果是 -0.0</p></blockquote><p><strong>java中将ISO8859-1字符串转成GB2312编码，语句为 ？</strong>  </p><ul><li><strong>A：</strong>new String(“ISO8859-1”.getBytes(“ISO8859-1”),”GB2312”)</li><li><strong>B：</strong>new String(String.getBytes(“GB2312”）, ISO8859-1)</li><li><strong>C：</strong>new String(String.getBytes(“ISO8859-1”))</li><li><strong>D：</strong>new String(String.getBytes(“GB2312”))</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>注意这里”ISO8859-1”是一个普通字符串，不要被迷惑了</p><p>new String(“这是要转换的字符串”.getBytes(“ISO-8859-1”), “GB2312”);</p></blockquote><p><strong>（多选）已知String a=”a”,String b=”b”,String c=a+b,String d=new String(“ab”) 以下操作结果为true的是</strong></p><ul><li><strong>A：</strong>(a+b).equals(c)</li><li><strong>B：</strong>a+b==c</li><li><strong>C：</strong>c==d</li><li><strong>D：</strong>c.equals(d)</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AD</span></span><p><strong>解析：</strong></p><p>1.== 和 equals():</p><p>(1)“==” 用于比较基本数据类型时比较的是值，用于比较引用类型时比较的是引用指向的地址。</p><p>(2)Object 中的equals() 与 “==” 的作用相同，但String类重写了equals()方法，比较的是对象中的内容。</p><p>2.String对象的两种创建方式:</p><p>(1)第一种方式: String str1 = “aaa”;  是在常量池中获取对象(“aaa” 属于字符串字面量，因此编译时期会在常量池中创建一个字符串对象，如果常量池中已经存在该字符串对象则直接引用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>3.String类型的常量池比较特殊。它的主要使用方法有两种</p><p>(1)直接使用双引号声明出来的String对象会直接存储在常量池中。</p><p>(2)如果不是用双引号声明的String对象,可以使用 String 提供的 intern 方法。 String.intern() 是一个 Native 方法，它的作用是： 如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用； 如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"AAA"</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 = <span class="string">"AAA"</span>;</span><br><span class="line">System.out.println(s2);<span class="comment">//AAA</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false，因为一个是堆内存中的String对象一个是常量池中的String对象，</span></span><br><span class="line">System.out.println(s2 == s3);<span class="comment">//true， s1,s2指向常量池中的”AAA“</span></span><br></pre></td></tr></table></figure><p>4字符串拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"a"</span>;</span><br><span class="line">String b = <span class="string">"b"</span>;</span><br><span class="line">  </span><br><span class="line">String str1 = <span class="string">"a"</span> + <span class="string">"b"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">String str2 = a + b; <span class="comment">//在堆上创建的新的对象     </span></span><br><span class="line">String str3 = <span class="string">"ab"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//true </span></span><br><span class="line">System.out.println(str2 == str3);<span class="comment">//false</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>对于java类型变量char c,short s,float f,double d,表达式c*s+f+d的结果类型为（）</strong></p><ul><li><strong>A：</strong>float</li><li><strong>B：</strong>char</li><li><strong>C：</strong>short</li><li><strong>D：</strong>double</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p><strong>基本数据类型的运算，会自动向上转型。boolean不可以和其他基本数据类型相互转换。</strong></p><p><strong>byte-&gt;short,char -&gt; int -&gt; long</strong>      </p><p><strong>float -&gt; double</strong></p><p><strong>int -&gt; float</strong></p><p><strong>long -&gt; double</strong></p><p><img src="https://image.cclblog.cn/blog/20200622161949.png" alt=""></p></blockquote><p><strong>在运行时，由java解释器自动引入，而不用import语句引入的包是()。</strong></p><ul><li><strong>A：</strong>java.lang</li><li><strong>B：</strong>java.system</li><li><strong>C：</strong>java.io</li><li><strong>D：</strong>java.util</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>java.lang包是java语言的核心包，lang是language的缩写</p><p>java.lang包定义了一些基本的类型，包括Integer,String之类的，是java程序必备的包，有解释器自动引入，无需手动导入</p></blockquote><p><strong>由3 个“1”和 5 个“0”组成的 8 位二进制补码，能表示的最小整数（）</strong></p><ul><li><strong>A：</strong>-126</li><li><strong>B：</strong>-125</li><li><strong>C：</strong>-32</li><li><strong>D：</strong>-3</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>既然求最小整数，那肯定先想到负数，则最高位（符号位）一定为1，原码中肯定是1所在的位数越高，值越小，而补码是由原码取反加1（符号位不变）得到的，则在补码中1所在的位数一定要越低，即补码为1000 0011；由补码求得原码：1111 1101=-(64+32+16+8+4+1)=-125;</p></blockquote><p><strong>关于访问权限，说法正确的是？ ( )</strong></p><ul><li><strong>A：</strong>类A和类B在同一包中，类B有个protected的方法testB，类A不是类B的子类（或子类的子类），类A可以访问类B的方法testB</li><li><strong>B：</strong>类A和类B在同一包中，类B有个protected的方法testB，类A不是类B的子类（或子类的子类），类A不可以访问类B的方法testB</li><li><strong>C：</strong>访问权限大小范围：public &gt; 包权限 &gt; protected &gt; private</li><li><strong>D：</strong>访问权限大小范围：public &gt; 包权限 &gt; private &gt; protected</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p><img src="https://image.cclblog.cn/blog/20200622110227.jpg" alt=""></p></blockquote><p><strong>以下程序程序运行后的输出结果是（）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">12</span>,n=<span class="number">34</span>;</span><br><span class="line">    System.out.printf(<span class="string">"%d%d"</span>,m++,++n);</span><br><span class="line">    System.out.printf(<span class="string">"%d%d\n"</span>,n++,++m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>12353514</li><li><strong>B：</strong>12353513</li><li><strong>C：</strong>12343514</li><li><strong>D：</strong>12343513</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p><strong>不要忘记前面已经自加过后，变量的值已经改变了（明白了这个肯定就没问题了）</strong></p><p>​          第一个输出：m++值：12，m的值：13</p><p>​                              ++n值：35，n的值：35</p><p>​          第一个输出：n++值：35，n的值：36</p><p>​                              ++m值：14，n的值：14</p><p>​          故最终输出：12353514</p></blockquote><p><strong>在jdk1.8之前，下列哪一种叙述是正确的（ ）</strong></p><ul><li><strong>A：</strong>abstract修饰符可修饰字段、方法和类</li><li><strong>B：</strong>抽象方法的body部分必须用一对大括号{ }包住</li><li><strong>C：</strong>声明抽象方法，大括号可有可无</li><li><strong>D：</strong>声明抽象方法不可写出大括号</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style=""> 查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p>A:abstract修饰方法和类</p><p>B、C:抽象方法没有方法体，有没有方法体看有没有大括号。</p></blockquote><p><strong>以下不是修饰符final的作用的是( )。</strong></p><ul><li><strong>A：</strong>修饰常量</li><li><strong>B：</strong>修饰不可被继承的类</li><li><strong>C：</strong>修饰不可变类</li><li><strong>D：</strong>修饰不可覆盖的方法</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p>final的作用：</p><p>​    1. 修饰变量，变量的引用地址不可变，但是地址中的内容可以变。</p><p>​    2. 修饰方法，方法不可被重写，但是还是可以重载</p><p>​    3. 修饰类，类不可继承。</p><p><strong>不可变类：</strong>说的是一个类一旦被实例化，就不可改变自身的状态。常见的比如String和基本数据类型的包装类，对于这种不可变类，一旦在进行引用传递的时候，形参一开始就和实际参数指向的不是一个地址，所以在方法中对形参的改变，并不会影响实际参数。</p></blockquote><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><p><strong>在一个基于分布式的游戏服务器系统中，不同的服务器之间，哪种通信方式是不可行的（）？</strong></p><ul><li><strong>A：</strong>管道</li><li><strong>B：</strong>消息队列</li><li><strong>C：</strong>高速缓存数据库</li><li><strong>D：</strong>套接字</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p><strong>管道( pipe )：</strong>管道是一种半双工的通信方式，数据只能单向流动，<strong>而且只能在具有亲缘关系的进程间使用</strong>。进程的亲缘关系通常是指父子进程关系。</p><p><strong>既然是不同的服务器之间进行通信，怎么可能会是具有亲缘关系的进程呢？</strong></p></blockquote><p><strong>以下哪个式子有可能在某个进制下成立（）？</strong></p><ul><li><strong>A：</strong>13  * 14=204</li><li><strong>B：</strong>12 * 34=568</li><li><strong>C：</strong>14*14=140</li><li><strong>D：</strong>1+1=3</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>A:  假设为x进制</p><p>13用10进制表示为 1 * x^1 + 3 * x ^ 0 =  x + 3</p><p>同理 14 ：x + 4 </p><p>204：2x^2 + 4</p><p>(x + 3)(x + 4 ) = 2x^2 + 4</p><p>解得 x1 = 8 x2 = -1</p><p>BCD同理可计算</p></blockquote><p><strong>以下JAVA程序代码的输出是</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="number">17</span>^<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>12</li><li><strong>B：</strong>22</li><li><strong>C：</strong>20</li><li><strong>D：</strong>1419857</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p>位异运算符号。</p><p>运算规则是：两个数转为二进制，然后从高位开始比较，如果相同则为0，不相同则为1。</p><p>17：0001 0001 </p><p>5：  0000 0101</p><p>结果：0001 0100 转10进制：20</p></blockquote><p><strong>变量a是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF;变量b是一个64位有符号的整数，初始值用16进制表示为：0x8000000000000000。则a+b的结果用10进制表示为多少？</strong></p><ul><li><strong>A：</strong>1</li><li><strong>B：</strong>-1</li><li><strong>C：</strong>2^63+2^62+…+2^2+2^1+2^0</li><li><strong>D：</strong>–(2^63+2^62+…+2^2+2^1+2^0)</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>0x7FFFFFFFFFFFFFFF +  0x8000000000000000 =  0xFFFFFFFFFFFFFFFF</p><p>（1）a+b的16进制表示为：OxFFFFFFFFFFFFFFF（16位F），转为2进制为111……111（64位1，每个F-&gt;4位2进制）。</p><p>（2）有符号数：是针对二进制来讲的。用最高位作为符号位，“0”代表“+”，“1”代表“-”。所以a+b的结果是一个负数。</p><p>（3）计算机中负数是以补码的形式保存的，将补码转换成原码的计算方式如下：</p><p>​        ①. 对于正数，原码与补码相同。</p><p>​        ②.对于负数：</p><p>​                （1）<strong>符号位保持不变</strong>，按位取反，末位加1，即得到原码。</p><p>​                （2）<strong>符号位保持不变</strong>，先-1，然后其他位按位取反            </p><p>​                    这两种方法都可以    </p><p>（4）a + b = 111……111（64位1）</p><p>​          取反：100……000（1位1，后面63位0）</p><p>​          加一：100……00（中间62位0）</p><p>​      结果10进制：-1。</p></blockquote><p><strong>存根（Stub）与以下哪种技术有关</strong> </p><ul><li><strong>A：</strong>交换</li><li><strong>B：</strong>动态链接</li><li><strong>C：</strong>动态加载</li><li><strong>D：</strong>磁盘调度</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>存根类是一个类，它实现了一个接口，它的作用是：如果一个接口有很多方法，如果要实现这个接口，就要实现所有的方法。但是一个类从业务来说，可能只需要其中一两个方法。如果直接去实现这个接口，除了实现所需的方法，还要实现其他所有的无关方法。而如果通过继承存根类就实现接口，就免去了这种麻烦。<br>RMI 采用stubs 和 skeletons 来进行远程对象(remote object)的通讯。stub 充当远程对象的客户端<strong>，有着和远程对象相同的远程接口，远程对象的调用实际是通过调用该对象的客户端</strong>对象stub来完成的。<br>每个远程对象都包含一个<strong>对象stub，当运行在本地Java虚拟机上的程序调用运行在远程Java虚拟机上的对象方法时，它首先在本地创建该对象的</strong>对象stub, 然后调用对象上匹配的方法。每一个远程对象同时也包含一个skeleton对象，skeleton运行在远程对象所在的虚拟机上，接受来自stub对象的调用。这种方式符合等到程序要运行时将目标文件动态进行链接的思想</p></blockquote><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><strong>（多选）对Collection和Collections描述正确的是</strong></p><ul><li><strong>A：</strong>Collection是java.util下的类，它包含有各种有关集合操作的静态方法</li><li><strong>B：</strong>Collection是java.util下的接口，它是各种集合结构的父接口</li><li><strong>C：</strong>Collections是java.util下的接口，它是各种集合结构的父接口</li><li><strong>D：</strong>Collections是java.util下的类，它包含有各种有关集合操作的静态方法</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BD</span></span><p><strong>解析：</strong></p><ul><li><p>java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。</p></li><li><p>java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。</p></li></ul></blockquote><p><strong>java8中，下面哪个类用到了解决哈希冲突的开放定址法</strong></p><ul><li><strong>A：</strong>LinkedHashSet</li><li><strong>B：</strong>HashMap</li><li><strong>C：</strong>ThreadLocal</li><li><strong>D：</strong>TreeMap</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：C</span></span><p><strong>解析：</strong></p><p>ThreadLocalMap中使用开放地址法来处理散列冲突，而HashMap中使用的是分离链表法。之所以采用不同的方式主要是因为：在ThreadLocalMap中的散列值分散得十分均匀，很少会出现冲突。并且ThreadLocalMap经常需要清除无用的对象，使用纯数组更加方便。</p></blockquote><p><strong>列表(List)和集合(Set)下面说法正确的是？  ( )</strong></p><ul><li><strong>A：</strong>Set中至多只能有一个空元素</li><li><strong>B：</strong>List中至多只能有一个空元素</li><li><strong>C：</strong>List和Set都可以包含重复元素的有序集合</li><li><strong>D：</strong>List和Set都是有序集合</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><ul><li>Set 不能有重复的元素，且是无序的，要有空值也就只能有一个。因为它不允许重复。 L ist 可以有重复元素，且是有序的，要有空值也可以有多个，因为它可重复。</li><li>java里面讲的有序无序，指的是你按照顺序存进去数据，然后再按照顺序取出来，两者是一样的。比如List(0)我放的是“a”，那么我list.get(0)取出来也是“a”。并不代表我存了打乱顺序存1到10十个数，它会自己给按照升序或者降序给你排好序。</li></ul></blockquote><p><strong>（多选）关于java集合下列说法不正确的有哪些（）</strong></p><ul><li><strong>A：</strong>HashSet 它是线程安全的，不允许存储相同的对象</li><li><strong>B：</strong>ConcurrentHashMap 它是线程安全的，其中存储的键对象可以重复，值对象不能重复</li><li><strong>C：</strong>Collection接口是List接口和Set接口的父接口，通常情况下不被直接使用</li><li><strong>D：</strong>ArrayList线程安全的，允许存放重复对象</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：ABD</span></span><p><strong>解析：</strong></p><p><strong>注意：常见并非全部</strong></p><p><strong>线程安全(Thread-safe)的集合对象：</strong></p><ul><li>Vector 线程安全：</li><li>HashTable 线程安全：</li><li>StringBuffer 线程安全：</li></ul><p><strong>非线程安全的集合对象：</strong></p><ul><li>ArrayList ：</li><li>LinkedList：</li><li>HashMap：</li><li>HashSet：</li><li>TreeMap：</li><li>TreeSet：</li><li>StringBulider：</li></ul></blockquote><p><strong>list是一个ArrayList的对象，哪个选项的代码填到//todo delete处，可以在Iterator遍历的过程中正确并安全的删除一个list中保存的对象？（）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = list.iterator();</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">    Object obj = it.next();</span><br><span class="line">    <span class="keyword">if</span> (needDelete(obj))  <span class="comment">//needDelete返回boolean，决定是否要删除</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//todo delete</span></span><br><span class="line">    &#125;</span><br><span class="line">    index ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>it.remove();</li><li><strong>B：</strong>list.remove(obj);</li><li><strong>C：</strong>list.remove(index);</li><li><strong>D：</strong>list.remove(obj,index);</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：A</span></span><p><strong>解析：</strong></p><p>源码是这么描述的：<strong>ArrayList</strong> 继承了 <strong>AbstractList，</strong> 其中<strong>AbstractList</strong> 中有个<strong>modCount</strong> 代表了集合修改的次数。在<strong>ArrayList的iterator方法中会判断</strong> <strong>expectedModCount与</strong> <strong>modCount是否相等，如果相等继续执行，不相等报错，只有iterator的remove方在调用自身的remove之后让</strong> <strong>expectedModCount与modCount再相等，所以是安全的。</strong></p></blockquote><p><strong>（多选）Hashtable 和 HashMap 的区别是：</strong></p><ul><li><strong>A：</strong>Hashtable 是一个哈希表，该类继承了 AbstractMap，实现了 Map 接口</li><li><strong>B：</strong>HashMap 是内部基于哈希表实现，该类继承AbstractMap，实现Map接口</li><li><strong>C：</strong>Hashtable 线程安全的，而 HashMap 是线程不安全的</li><li><strong>D：</strong>Properties 类 继承了 Hashtable 类，而 Hashtable 类则继承Dictionary 类</li><li><strong>E：</strong>HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BCDE</span></span><p><strong>解析：</strong></p><p><strong>Hashtable</strong>：</p><p>（1）Hashtable 是一个散列表，它存储的内容是键值对(key-value)映射。</p><p>（2）Hashtable 的函数都是同步的，这意味着它是<strong>线程安全</strong>的。它的key、value都不可以为null。</p><p>（3）HashTable直接使用对象的hashCode。</p><p><strong>HashMap：</strong></p><p>（1）由<strong>数组+链表</strong>(jdk1.8以前)组成的，基于<strong>哈希表的Map</strong>实现，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</p><p>（2）不是线程安全的，HashMap可以接受为null的键(key)和值(value)。</p><p>（3）HashMap重新计算hash值</p><p><strong>Hashtable,HashMap,Properties</strong>继承关系如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Properties</span> <span class="keyword">extends</span> <span class="title">Hashtable</span>&lt;<span class="title">Object</span>,<span class="title">Object</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Objecct</span><br><span class="line">java.util.Dictionary&lt;K,V&gt;</span><br><span class="line"> java.util.Hashtable&lt;Object,Object&gt;</span><br><span class="line">   java.util.Properties </span><br></pre></td></tr></table></figure></blockquote><p><strong>(多选)对</strong> <strong>Map</strong> <strong>的用法，正确的有：</strong></p><ul><li><strong>A：</strong>new java.util.Map().put(“key” , “value”) ;</li><li><strong>B：</strong>new java.util.SortedMap().put(“key” , “value”) ;</li><li><strong>C：</strong>new java.util.HashMap().put( null , null ) ;</li><li><strong>D：</strong>new java.util.TreeMap().put( 0 , null ) ;</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：CD</span></span><p><strong>解析：</strong></p><p>选C、D。考察的是<strong>Map接口</strong>实现类的<strong>创建对象</strong>以及对象类型包含的<strong>方法</strong>。</p><p>A选项<strong>Map属于接口类型</strong>，不可以new的方式创建对象。所以A错误。</p><p>B选项<strong>SortedMap属于接口类型</strong>，不可以new的方式创建对象。所以B错误。</p><p>C选项<strong>HashMap</strong>基于哈希表实现Map接口的类，<strong>并允许null的值和null键</strong>。</p><p>D选项<strong>TreeMap</strong>通过红黑树实现Map接口的类，key不可以为null，会报<strong>NullPointerException</strong>异常,value可以为null。</p></blockquote><p><strong>（多选）以下哪些继承自 Collection 接口（）</strong></p><ul><li><strong>A：</strong>List</li><li><strong>B：</strong>Set</li><li><strong>C：</strong>Map</li><li><strong>D：</strong>Array</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AB</span></span><p><strong>解析：</strong></p><p>├List</p><p>​    │├LinkedList</p><p>​    │├ArrayList</p><p>​    │└Vector</p><p>​        │└Stack</p><p>└Set</p><p>Map</p><p>​    ├Hashtable</p><p>​    ├HashMap</p><p>​    └WeakHashMap</p></blockquote><p><strong>（多选）下面哪些类实现或继承了 Collection 接口？</strong></p><ul><li>A：HashMap</li><li>B：ArrayList</li><li>C：Vector</li><li>D：Iterator</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BC</span></span><p><strong>解析：</strong></p><p><img src="https://image.cclblog.cn/blog/20200623094232.png" alt=""></p></blockquote><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><strong>（多选）下列哪些操作会使线程释放锁资源？</strong></p><ul><li><strong>A：</strong>sleep()</li><li><strong>B：</strong>wait()</li><li><strong>C：</strong>join()</li><li><strong>D：</strong>yield()</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：BC</span></span><p><strong>解析：</strong></p><p>所谓的释放锁资源实际是通知对象内置的monitor对象进行释放，而只有所有对象都有内置的monitor对象才能实现任何对象的锁资源都可以释放。又因为所有类都继承自Object，所以wait(）就成了Object方法，也就是通过wait()来通知对象内置的monitor对象释放，而且事实上因为这涉及对硬件底层的操作，所以wait()方法是native方法，底层是用C写的。</p><p>其他都是Thread所有，所以其他3个是没有资格释放资源的</p><p>而join()有资格释放资源其实是通过调用wait()来实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码如下： </span></span><br><span class="line">wait()方法   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// join()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay); </span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong>（多选）在Java线程状态转换时，下列转换不可能发生的有（）？</strong></p><ul><li><strong>A：</strong>初始态-&gt;运行态</li><li><strong>B：</strong>就绪态-&gt;运行态</li><li><strong>C：</strong>阻塞态-&gt;运行态</li><li><strong>D：</strong>运行态-&gt;就绪态</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：AC</span></span><p><strong>解析：</strong></p><p><img src="https://image.cclblog.cn/blog/20200624171403.jpg" alt=""></p></blockquote><p><strong>（多选）Java.Thread的方法resume()负责重新开始被以下哪个方法中断的线程的执行（）。</strong></p><ul><li><strong>A：</strong>stop</li><li><strong>B：</strong>sleep</li><li><strong>C：</strong>wait</li><li><strong>D：</strong>suspend</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p>resume与suspended一起使用<br>wait与notify/notifyAll一起使用<br>sleep会让线程暂时不执行</p><p><strong>Thread类的suspend（）和resume（）方法都已经被声明已废弃了</strong></p></blockquote><p><strong>下列程序的运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            pong();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.run();</span><br><span class="line">    System.out.print(<span class="string">"ping"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"pong"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>A：</strong>pingpong</li><li><strong>B：</strong>pongping</li><li><strong>C：</strong>pingpong和pongping都有可能</li><li><strong>D：</strong>都不输出</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：B</span></span><p><strong>解析：</strong></p><p>这里需要注意Thread的start和run方法</p><p>用start方法才能真正启动线程，此时线程会处于就绪状态，一旦得到时间片，则会调用线程的run方法进入运行状态。</p><p>而run方法只是普通方法，如果直接调用run方法，程序只会按照顺序执行主线程这一个线程。</p></blockquote><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p><strong>BufferedReader的父类是以下哪个？</strong></p><ul><li><strong>A：</strong>FilterReader</li><li><strong>B：</strong>InputStreamReader</li><li><strong>C：</strong>PipedReader</li><li><strong>D：</strong>Reader</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><p><img src="https://image.cclblog.cn/blog/20200625205640.png" alt=""></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 题集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 题集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java习题整理</title>
      <link href="/2020/06/22/java/theme/question/"/>
      <url>/2020/06/22/java/theme/question/</url>
      
        <content type="html"><![CDATA[<ol><li><strong><a href="/2020/06/22/java/question/1/">第一周</a></strong></li><li><strong><a href="/2020/06/29/java/question/2/">第二周</a></strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> JAVA </category>
          
          <category> 题集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> JAVA </tag>
            
            <tag> 题集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成员变量与局部变量</title>
      <link href="/2020/06/21/java/javase/15/"/>
      <url>/2020/06/21/java/javase/15/</url>
      
        <content type="html"><![CDATA[<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ol><li><p><strong>成员变量</strong>是独立于方法外的变量，<strong>局部变量</strong>是方法中的变量。</p></li><li><p>成员变量：包括<strong>实例变量</strong>和<strong>类变量</strong>，用static修饰的是类变量，不用static修饰的是实例变量，所有类的成员变量可以通过this来引用。</p><p>局部变量：包括<strong>形参</strong>，<strong>方法局部变量</strong>，<strong>代码局部变量</strong>，存在于方法的参数列表和方法定义中以及代码块中。</p></li><li><p><strong>成员变量</strong>存储在<strong>堆</strong>，<strong>局部变量</strong>存储在<strong>栈</strong>。<strong>局部变量</strong>的<strong>作用域</strong>仅限于<strong>定义它的方法</strong>，在该方法的外部无法访问它。<strong>成员变量</strong>的<strong>作用域</strong>在<strong>整个类内部都</strong>是可见的，所有成员方法都可以使用它。如果访问权限允许，还可以在类外部使用成员变量。</p></li><li><p><strong>局部变量的生存周期与方法的生存周期相同</strong>。当方法执行到定义局部变量的语句时，局部变量被创建；执行到它所在的作用域的最后一条语句时局部变量将被销毁。<strong>类的成员变量如果是实例成员变量，它和对象对象的生命周期相同</strong>。<strong>而静态成员变量的生存期则是整个程序运行期。</strong></p></li><li><p>成员变量在累加或实例创建时，系统自动分配内存空间，并在分配空间后自动为成员变量指定初始化值，初始化值为默认值，<strong>基本数据类型byte、short、char、int、long默认值0，float、double默认为0.0，String等引用数据类型默认赋值为null。</strong>（被final修饰且没有static修饰的必须显示赋值），局部变量必须经过显示初始化后才能使用，系统不会为局部变量执行初始化。</p></li><li><p><strong>局部变量可以和成员变量同名，</strong>且在使用时，<strong>局部变量具有更高的优先级，直接使用同名访问，访问的是局部变量，如需访问成员变量可以使用this.变量名访问。</strong></p></li></ol><blockquote><p><strong>this不但可以引用实例变量也可以引用静态变量。</strong>因为类变量属于整个类，this代表当前对象，也可以使用整个类的方法与属性。但是一般来说，我们不会使用this来引用类变量，因为不管在实例方法还是类方法中，类变量都可以直接引用（在其他类中调用本类的类方法需要加类名），不需要加this。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动装箱与拆箱</title>
      <link href="/2020/06/20/java/javase/5/"/>
      <url>/2020/06/20/java/javase/5/</url>
      
        <content type="html"><![CDATA[<h1 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>自动装箱：</strong>就是自动将基本数据类型包装为包装器类型；</p><p><strong>自动拆箱：</strong>就是自动将包装器类型转换为基本数据类型；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Interger i = <span class="number">1</span>; <span class="comment">// 拆箱</span></span><br><span class="line"><span class="keyword">int</span> n = i; <span class="comment">// 装箱</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>这个装箱拆箱操作是jdk5的新特性</strong> </p><ul><li>JDK5之前的方式：比如Integer i = Integer.valueof(5);（这里5为基本类型int，Integer包装类利用valueof()方法将其转换为Integer类型）或者int i = i.intValue();（这里基本类型利用intValue()方法将Integer类型转换为基本类型int）。</li><li>JDK5之后的方式：比如①Integer i = 5;或者②int i = new Integer(100);，这里基本类型与包装类之间可直接操作，而①的操作就是自动装箱，②的操作就是自动拆箱。</li></ul></blockquote><table><thead><tr><th></th><th>More Actions  默认值</th><th>存储需求（字节）</th><th>取值范围</th><th>示例</th><th>包装类型</th></tr></thead><tbody><tr><td>byte</td><td>0</td><td>1</td><td>-2^7—2^7-1</td><td>byte b=10;</td><td><strong>Byte</strong></td></tr><tr><td>char</td><td>‘ \u0000′</td><td>2</td><td>0—2^16-1</td><td>char c=’c’ ;</td><td><strong>Character</strong></td></tr><tr><td>short</td><td>0</td><td>2</td><td>-2^15—2^15-1</td><td>short s=10;</td><td><strong>Short</strong></td></tr><tr><td>int</td><td>0</td><td>4</td><td>-2^31—2^31-1</td><td>int i=10;</td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>0</td><td>8</td><td>-2^63—2^63-1</td><td>long o=10L;</td><td><strong>Long</strong></td></tr><tr><td>float</td><td>0.0f</td><td>4</td><td>-2^31—2^31-1</td><td>float f=10.0F</td><td><strong>Float</strong></td></tr><tr><td>double</td><td>0.0d</td><td>8</td><td>-2^63—2^63-1</td><td>double d=10.0;</td><td><strong>Double</strong></td></tr><tr><td>boolean</td><td>false</td><td>不确定</td><td>true\false</td><td>boolean flag=true;</td><td><strong>Boolean</strong></td></tr></tbody></table><blockquote><p>boolean的大小java规范并没有明确给出具体查看：</p><p><a href="">https://www.cnblogs.com/wangtianze/p/6690665.html</a></p></blockquote><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><strong>1、有如下4条语句：()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i01=<span class="number">59</span>;</span><br><span class="line"><span class="keyword">int</span> i02=<span class="number">59</span>;</span><br><span class="line">Integer i03=Integer.valueOf(<span class="number">59</span>);</span><br><span class="line">Integer i04=<span class="keyword">new</span> Integer(<span class="number">59</span>);</span><br></pre></td></tr></table></figure><p><strong>以下输出结果为false的是:</strong></p><ul><li>System.out.println(i01==i02);</li><li>System.out.println(i01==i03);</li><li>System.out.println(i03==i04);</li><li>System.out.println(i02==i04);</li></ul><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：D</span></span><p><strong>解析：</strong></p><ul><li>无论如何，Integer与new Integer不会相等。不会经历拆箱过程。</li><li>两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false；java在编译Integer i2 = 128的时候,被翻译成-&gt; Integer i2 = Integer.valueOf(128);而valueOf()函数会对-128到127之间的数进行缓存。</li></ul><blockquote><p>Integer.valueOf方法中也有判断，如果传递的整型变量&gt;= -128并且小于127时会返回IntegerCache类中一个静态数组中的某一个对象， 否则会返回一个新的Integer对象,代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">     <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">         <span class="keyword">return</span> IntegerCache.[i + (-IntegerCache.low)];</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li><strong>两个都是new出来的,都为false</strong></li><li><strong>int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比</strong></li></ul></blockquote><blockquote><p>我认为理论看的再多也不如实际的去做题，理论知道的多，题目不一定做得对，做题可以巩固自己的理论知识。</p></blockquote><p><strong>2、下面程序的输出结果是什么？（这个是我引用参考链接中第二个链接中的一个例子）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        Long h = <span class="number">2L</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(c==d); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(e==f); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(c==(a+b)); <span class="comment">// 3</span></span><br><span class="line">        System.out.println(c.equals(a+b)); <span class="comment">// 4</span></span><br><span class="line">        System.out.println(g==(a+b)); <span class="comment">// 5</span></span><br><span class="line">        System.out.println(g.equals(a+b)); <span class="comment">// 6 </span></span><br><span class="line">        System.out.println(g.equals(a+h)); <span class="comment">// 7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案  </a><span class="hide-content">答案：1.true 2.false 3.true 4.true 5.true 6.false 7.true</span></span><p><strong>解析：</strong></p><ol><li>c==d：因为Integer中缓存的存在，如果数在[-128,127] (包括边界)，则是true,否则为false</li><li>e==f：同1</li><li>c=(a + b)：a + b 这个操作会自动拆箱结果为int</li><li>c.equals(a+b)：无需解释</li><li>(g==(a+b))：同3 a+b=&gt; int g为Long自动拆箱为long 然后int类型自动提升为long </li><li>g.equals(a+b)：a+b 为int 类型，Long 与 相同值的 包装类 用equals比较时，如果传入的类型不是Long,那么全部返回false，Long类中的equals()源码：</li></ol><p><img src="https://image.cclblog.cn/blog/20200628122339.png" alt=""></p><ol start="7"><li>g.equals(a+b)：true a+h 结果会向精度大的转换 为long类型</li></ol></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="比较值"><a href="#比较值" class="headerlink" title="比较值"></a>比较值</h3><ol><li>基本数据类型与引用数据类型进行比较时，引用数据类型会进行拆箱，然后与基本数据类型进行值的比较</li></ol><blockquote><p>int i = 12;<br>Integer j = new Integer(12);<br>i == j 返回的是true</p></blockquote><p>二、引用数据类型与基本数据类型进行比较（equals方法），基本数据类型会进行自动装箱，与引用数据类型进行比较，Object中的equals方法比较的是地址，但是Integer类已经重写了equals方法，只要两个对象的值相同，则可视为同一对象，具体看API文档，所以这归根到底也是值的比较！</p><blockquote><p>int i = 12;<br>Integer j = new Integer(12);<br>j.equals(i) 返回的是true</p></blockquote><h3 id="比较地址"><a href="#比较地址" class="headerlink" title="比较地址"></a>比较地址</h3><ol><li>如果引用数据类型是这样 Integer i = 12;直接从<strong>常量池</strong>取对象，这是如果数值是在-128与127之间，则视为同一对象，否则视为不同对象</li></ol><blockquote><p>Integer i = 12; Integer j = 12; i == j 返回的是true<br>Integer i = 128; Integer j = 128; i == j 返回的是false</p></blockquote><ol start="2"><li>如果引用数据类型是直接new的话，不管值是否相同，这时两个对象都是不相同的，因为都会各自在堆内存中开辟一块空间</li></ol><blockquote><p>Integer i =new Integer(12);<br>Integer j = new Integer(12);<br>i == j 这时返回的是false</p></blockquote><ol start="3"><li><strong>从常量池取对象跟new出来的对象也是不同的</strong></li></ol><blockquote><p>举例：<br>Integer i = 12; // 这个常量池中的<br>Integer j = new Integer(12) // 这个是堆中创建的<br>i == j 这时返回的是false</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="">https://www.cnblogs.com/wang-yaz/p/8516151.html</a></p><p><a href="">https://www.cnblogs.com/dolphin0520/p/3780005.html</a></p><blockquote><p><strong>这两篇文章从源码以及jvm分析了原理，并且写的很好，我就不再说明了。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法区</title>
      <link href="/2020/06/20/java/jvm/2-7/"/>
      <url>/2020/06/20/java/jvm/2-7/</url>
      
        <content type="html"><![CDATA[<h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法区</title>
      <link href="/2020/06/19/java/jvm/2-6/"/>
      <url>/2020/06/19/java/jvm/2-6/</url>
      
        <content type="html"><![CDATA[<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><ul><li>方法区（Method Area）和Java堆一样，是各个线程共享的内存区域。</li><li>《Java虚拟机规范》当中把方法区描述为堆的一个逻辑部分，但是它有一个别名叫<strong>“非堆”</strong>，目的是与Java堆区分开来。</li><li>jdk7以前，把方法区称为永久代。jdk8开始，使用元空间取代了永久代。</li></ul><blockquote><p>jdk7把原本存放在永久代的字符串常量池，静态变量等移到了堆中，直到jdk8才用元空间（Metaspace）替代了永久代，元空间在本地内存中。之所以放入本地内存我感觉就是加大了方法区的内存，避免了很多由于类加载过多导致的OOM。</p></blockquote><ul><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，就会导致OOM。</li><li>方法区同样存在垃圾收集。</li></ul><blockquote><p>这个垃圾收集的条件很苛刻也就为什么说是永久代一样，永久存在了，后续说明。</p></blockquote><h2 id="方法区大小设置"><a href="#方法区大小设置" class="headerlink" title="方法区大小设置"></a>方法区大小设置</h2><p><strong>jdk7以前：</strong></p><ul><li><p>-XX:PermSize来设置永久代初始内存大小 默认20.75M</p></li><li><p>-XX:MaxPermiSize来设置永久代最大可分配空间。32位机器默认64M，64位机器82M</p></li></ul><blockquote><p>JVM加载的类信息容量超出最大值会报OutOfMemoryError:PermGen space</p></blockquote><p><strong>jdk8以后：</strong></p><ul><li>-XX:MetspaceSize和-XX:MaxMetaspaceSize设置元数据区大小。</li></ul><blockquote><p>windows下，-XX:MetspaceSize 默认为21M，-XX:MaxMetaspaceSize默认为<strong>-1</strong>就是没有限制。(这个-1我参考网上的都说的-1，但是我看自己的程序的默认参数不是-1。反正这个了解就好，没必要去记这个)</p><p>内存溢出错误<strong>java.lang.OutOfMemoryError:Metaspace</strong></p></blockquote><p><img src="https://image.cclblog.cn/blog/20200619153032.png" alt=""></p><h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><p>方法区保存着被加载过的每一个类的信息，这些信息由类加载器在加载类的时候，从类的源文件抽取出来。</p><blockquote><p>方法区保存的起始就是每个类的一个模板，Class的元数据。</p></blockquote><p><strong>这些信息有：</strong></p><p><img src="https://image.cclblog.cn/blog/20200619202435.png" alt=""></p><blockquote><p><strong>这些信息没有一个统一的标准，网上说什么的都有，这是我自己综合整理，我感觉这个比较全面。仅供参考啊</strong></p></blockquote><h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>对于每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p><ul><li>类的完整有效名称（包名.类名）</li></ul><blockquote><p>比如java.lang.String</p></blockquote><ul><li><p>类的直接父类的完整有效名</p></li><li><p>类型直接实现接口的有序列表</p></li></ul><blockquote><p>一个类实现的接口可能有多个，多以存放在有序列表中。</p></blockquote><ul><li>类的修饰符</li></ul><blockquote><p>比如public abstract</p></blockquote><hr><blockquote><p>这个就像是查户口一样，看一下你家的详细地址（类的完整有效名称），你的父亲是谁（父类完整有效名称），你的工作（你实现的哪些接口），还有你是什么人（类的修饰符）。</p></blockquote><h3 id="字段信息"><a href="#字段信息" class="headerlink" title="字段信息"></a>字段信息</h3><ul><li>字段修饰符（public、protect、private、default）</li><li>字段声明的顺序</li><li>字段的类型</li><li>字段的名称</li></ul><h3 id="方法信息"><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h3><ul><li>方法名称</li><li>方法的返回类型（包括void）</li><li>方法参数的类型、数目和顺序</li><li>方法的修饰符（public、private、protected、static、final、synchronized、native、abstract）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外）</li></ul><blockquote><p>前面从未说过异常表这次详细分析</p><p>包括异常处理的<strong>开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获异常类的常量池索引</strong></p></blockquote><p><img src="https://image.cclblog.cn/blog/20200619164030.png" alt=""></p><h3 id="类的常量池-运行时常量池"><a href="#类的常量池-运行时常量池" class="headerlink" title="类的常量池/运行时常量池"></a>类的常量池/运行时常量池</h3><p><img src="https://image.cclblog.cn/blog/20200619173204.png" alt=""></p><h4 id="类常量池-静态常量池"><a href="#类常量池-静态常量池" class="headerlink" title="类常量池(静态常量池)"></a>类常量池(静态常量池)</h4><p><img src="https://image.cclblog.cn/blog/20200619180101.png" alt=""></p><ul><li>class常量池用于存储编译器生成的各种<strong>字面量</strong>和<strong>符号引用</strong>。 </li></ul><p><img src="https://image.cclblog.cn/blog/20200619201759.png" alt=""></p><blockquote><p>红色的这几个我仅仅了解，无法说清楚，待我日后补充，其它的三种是网上常见的，并且只有这三种，基本上都是这样，我是参考《深入理解Java虚拟机》第三版 p218。</p></blockquote><ul><li>每个class文件都有一个class常量池。</li></ul><h4 id="运行时常量池-动态常量池"><a href="#运行时常量池-动态常量池" class="headerlink" title="运行时常量池(动态常量池)"></a>运行时常量池(动态常量池)</h4><ul><li>方法区的一部分</li><li>常量池表是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。</li><li>运行时常量池包含多种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里变为了真实地址。</li></ul><blockquote><p>实际上在解析阶段只有能确定唯一版本的方法才能将符号引用直接替换为直接引用，这里也就是前面的章节说过的非虚方法。</p><p>Byte，Short，Integer，Long，Character，Boolean这5中包装类默认创建了数值[-128,127]的相应类型的缓存数据，但是超过此范围仍然回去创建新的对象。这也就是包装类比较是否相等要使用equals()。（Double，Float没有实现常量池技术）</p></blockquote><ul><li>运行时常量池相对于Class文件常量池的另外一个特征就是具备动态性。</li></ul><blockquote><p>String.intern()方法 </p></blockquote><h3 id="非final修饰的类变量"><a href="#非final修饰的类变量" class="headerlink" title="非final修饰的类变量"></a>非final修饰的类变量</h3><ul><li>静态变量和类是关联在一起的，随着类的加载而加载。</li><li>类变量被类的所有实例共享，即使没有类实例时也可以访问。</li></ul><blockquote><p><strong>final型变量的值是在编译期就被确定了，因此被保存在常量池中。</strong></p></blockquote><h3 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h3><ul><li><p>jvm必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么jvm会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。</p></li><li><p>jvm在动态链接的时候需要这个信息。当解析一个类型到另一个类型的引用的时候，jvm需要保证这两个类型的类加载器是相同的。这对jvm区分名字空间的方式是至关重要的。</p></li><li><p>比较两个类是否相等也需要比较类加载器是否是相同的。</p></li><li><p>垃圾收集的时候也需要参考这个类的加载器是否不再使用！</p></li></ul><h3 id="对Class类的引用"><a href="#对Class类的引用" class="headerlink" title="对Class类的引用"></a>对Class类的引用</h3><p>jvm为每个加载的类都创建一个java.lang.Class的实例（<strong>存储在堆上</strong>）。而jvm必须以某种方式把Class的这个实例和存储在方法区中的类型数据联系起来， 因此，类的元数据里面保存了一个Class对象的引用；</p><h3 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h3><blockquote><p><strong>引用：</strong></p><p>为了提高访问效率，必须仔细的设计存储在方法区中的数据信息结构。除了以上讨论的结构，jvm的实现者还可以添加一些其他的数据结构，如方法表。jvm对每个加载的非虚拟类的类型信息中都添加了一个方法表，方法表是一组对类实例方法的直接引用(包括从父类继承的方法。jvm可以通过方法表快速激活实例方法。(译者：这里的方法表与C++中的虚拟函数表一样，但java方法全都 是virtual的，自然也不用虚拟二字了。正像java宣称没有 指针了，其实java里全是指针。更安全只是加了更完备的检查机制，但这都是以牺牲效率为代价的,个人认为java的设计者 始终是把安全放在效率之上的，所有java才更适合于网络开发)</p></blockquote><h2 id="栈、堆、方法区的交互"><a href="#栈、堆、方法区的交互" class="headerlink" title="栈、堆、方法区的交互"></a>栈、堆、方法区的交互</h2><p><img src="https://image.cclblog.cn/blog/20200619211848.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java修饰符大全</title>
      <link href="/2020/06/18/java/javase/3/"/>
      <url>/2020/06/18/java/javase/3/</url>
      
        <content type="html"><![CDATA[<h1 id="Java修饰符大全"><a href="#Java修饰符大全" class="headerlink" title="Java修饰符大全"></a>Java修饰符大全</h1><ul><li>访问修饰符</li><li>非访问修饰符</li></ul><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><ul><li><strong>public：</strong>公有访问。对所有类都可见。</li><li><strong>protected：</strong>保护型访问，对同一个包可见，<strong>对不同的包的子类不可见</strong>。</li><li><strong>default：</strong>默认访问权限。只对同一个包可见，<strong>注意对不同的包的子类不可见</strong>。</li><li><strong>private：</strong>私有访问。只对同一个类可见，其余都不可见。</li></ul><blockquote><p><strong>这里也就注意一下default默认和protected对不同包的子类是否可见。</strong></p></blockquote><table><thead><tr><th>修饰符</th><th>同类</th><th>同包</th><th>子类</th><th>其它包</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>default</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h2 id="非权限访问修饰符"><a href="#非权限访问修饰符" class="headerlink" title="非权限访问修饰符"></a>非权限访问修饰符</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>static关键字可以用来修饰类（静态内部类）、方法（静态方法）、变量（静态变量）和代码块（静态代码块）。</strong></p><ul><li><p><strong>修饰类</strong></p><p><strong><a href="/2020/06/30/java/javase/6">Java中的内部类</a></strong></p></li><li><p><strong>修饰方法</strong></p></li></ul><ol><li>静态方法可以直接通过类名调用，任何的实例也都可以调用。</li></ol><blockquote><p><strong>new 一个对象的实例同样可以调用这个静态方法。</strong></p></blockquote><ol start="2"><li>静态方法中不能用this和super关键字。</li></ol><blockquote><p>学过jvm的就知道，静态方法的局部变量表中都没有this，所以不能使用。</p><p>this表示这个类的当前实例，super表示父类的当前实例，static修饰的是类的一个级别的，肯定不能用this，和super。</p><p>这个原因和jvm具体的类加载内存分配有关，可以看我写的jvm那些，或者百度。</p></blockquote><ol start="3"><li>不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。</li></ol><ul><li><strong>修饰变量</strong></li></ul><ol><li>对于静态变量在内存中只有一个拷贝（节省内存），JVM只分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问，当然也可以通过对象来访问。</li></ol><blockquote><p>这个就像HashSet底层是HashMap的key来存储元素的吗，它的value是一个默认的值，这个PRESENT声明为静态类型，所有的value共用这个变量。不这样做的话也太浪费空间了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><strong>修饰代码块</strong></p><p><strong><a href="/2020/07/03/java/javase/18">new一个类初始化的顺序</a></strong></p></li></ul><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul><li>final修饰类、方法、属性！不能修饰抽象类，因为抽象类一般都是需要被继承的，final修饰后就不能继承了。</li><li>final修饰的方法不能被重写而不是重载！ </li><li>final修饰属性，此属性就是一个常量，不能被再次赋值！ </li><li>final也不能修饰接口，接口可以只能被public&amp;abstract修饰</li><li>final如果修饰的是基本类型的变量，那么这个变量就表示为一个常数，只能赋值一次，要么在定义时赋值，要么在初始化时赋值；final修饰应用类型的变量是，变量不能再次被赋值意思是变量的地址（引用）不可以被改变，当变量所指向的内容可以被改变。</li></ul><blockquote><p><strong>final关键字不能用来抽象类和接口（这个很重要）</strong>  </p></blockquote><p><strong>final关键字可以用来修饰类、方法、变量。</strong></p><ul><li><strong>修饰类(class)。</strong> </li></ul><ol><li>该类不能被继承。 </li><li>类中的方法不会被覆盖，因此默认都是final的。 </li><li>用途：设计类时，如果该类不需要有子类，不必要被扩展，类的实现细节不允许被改变，那么就设计成final类</li></ol><ul><li><strong>修饰方法(method)</strong> </li></ul><ol><li>该方法可以被继承，但是不能被覆盖。</li><li>用途：一个类不允许子类覆盖该方法，则用final来修饰 </li><li>好处：可以防止继承它的子类修改该方法的意义和实现；更为高效，编译器在遇到调用final方法转入内嵌机制，提高了执行效率。 </li><li><strong>注意：</strong>父类中的private成员方法不能被子类覆盖，因此，private方法默认是final型的(可以查看编译后的class文件)</li></ol><ul><li><strong>修饰变量(variable)</strong> </li></ul><ol><li>用final修饰后变为常量。包括静态变量、实例变量和局部变量这三种。</li><li><strong>特点：</strong>可以先声明，不给初值，这种叫做final空白。但是使用前必须被初始化。一旦被赋值，将不能再被改变。</li></ol><blockquote><p>final修饰基本数据类型那基本数据类型的值就不能修改，要是引用数据类型指的是指向这个引用数据类型的地址不能被修改，但是这个引用数据类型中的数据是可以被修改的。</p></blockquote><ul><li><strong>修饰参数(arguments)</strong> </li></ul><ol><li>用final修饰参数时，称为最终参数，可以读取该参数，但是不能对其作出修改。</li></ol><h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p><strong>abstract可以用来修饰类（抽象类），和方法（抽象方法）。</strong></p><ul><li><strong>修饰类</strong></li></ul><ol><li>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</li></ol><blockquote><p><strong>抽象类不能实例化！！！！！！！！！！！！！！！！</strong></p></blockquote><ol start="2"><li>可以被继承。可以被抽象类继承，也可以被非抽象类继承。派生类可以实现抽象方法，并且也必须实现，除非是派生类也是抽象类。</li><li>抽象类不一定包含抽象方法，但是有抽象方法的类必定是抽象类。抽象类中既可以有抽象方法，也可以有普通方法。</li><li><strong>构造方法和类方法，不能声明为抽象方法。</strong></li></ol><ul><li><strong>修饰方法</strong></li></ul><ol><li>抽象方法只包含一个方法名，而没有方法体。</li><li>抽象方法没有定义，<strong>方法名后面直接跟一个分号，而不是花括号。</strong></li></ol><blockquote><p><strong>一个非抽象类继承abstract类必须实现其中的抽象方法，那么注意这个final关键字不可能和这个abstract一块使用。</strong></p></blockquote><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>用于多线程的同步。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>修饰的成员变量防止指令重排序，保持了这个变量在多线程间的可见性，不保证原子性。</p><blockquote><p>synchronized保证了多线程的顺序，可见和原子性。volatile不保证原子性。这里只是十分简单的说了一下这两个关键字。</p></blockquote><blockquote><p>这两个关键字的区别和具体在多线程中说明。太多了。。</p></blockquote><h3 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h3><p><strong>transient只能用来修饰变量。</strong></p><ul><li><strong>修饰变量</strong></li></ul><ol><li><p>一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</p></li><li><p>transient关键字只能修饰变量，而<strong>不能修饰方法和类</strong>。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。</p></li></ol><blockquote><p>成员变量(实例变量，属性)</p><p>局部变量（本地变量）</p><p>类变量（静态属性）</p></blockquote><ol start="3"><li>被transient关键字修饰的变量不再能被序列化，<strong>一个静态变量不管是否被transient修饰，均不能被序列化。</strong></li></ol><blockquote><p>静态变量属于类级别，不能被序列化。具体可以百度。</p></blockquote><h3 id="native"><a href="#native" class="headerlink" title="native"></a>native</h3><p>本地修饰符，指定此方法的方法体，是由其它语言在程序外部编写的。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础知识点</title>
      <link href="/2020/06/18/java/theme/javase/"/>
      <url>/2020/06/18/java/theme/javase/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础知识点"><a href="#Java基础知识点" class="headerlink" title="Java基础知识点"></a>Java基础知识点</h1><ol><li><a href="/2020/06/16/java/javase/1"><strong>重载和重写</strong></a></li><li><a href="/2020/06/17/java/javase/2"><strong>面向对象三大特性：继承、封装、多态</strong></a></li><li><a href="/2020/06/18/java/javase/3"><strong>Java中修饰符大全</strong></a></li><li><strong><a href="/2020/07/02/java/javase/4">StringBuffer与StringBuilder</a></strong></li><li><a href="/2020/06/20/java/javase/5"><strong>自动装箱与拆箱</strong></a></li><li><strong><a href="/2020/06/30/java/javase/6">Java中的内部类</a></strong></li><li><a href="">==与equals()</a></li><li><a href="">值传递与引用传递</a></li><li><a href="">Java中异常体系结构</a></li><li><a href="">深拷贝与浅拷贝</a></li><li><a href="">Stream流、lambda表达式</a></li><li><a href="">泛型</a></li><li><a href="">深入理解i++与++i</a></li><li><a href="">反射</a></li><li><a href="/2020/06/21/java/javase/15">成员变量和局部变量</a></li><li><a href="">&gt;&gt;&gt;、&gt;&gt;、&lt;&lt;</a></li><li><strong><a href="/2020/06/29/java/javase/17">接口与抽象类的区别</a></strong></li><li><strong><a href="/2020/07/03/java/javase/18">new一个类初始化的顺序</a></strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机栈</title>
      <link href="/2020/06/17/java/jvm/2-3/"/>
      <url>/2020/06/17/java/jvm/2-3/</url>
      
        <content type="html"><![CDATA[<h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><ul><li>本地方法栈与虚拟机栈所发挥的作用是非常相似的，区别就是虚拟机栈执行Java方法，本地方法栈为本地（Native）方法服务。</li></ul><blockquote><p>native方法是Java通过JNI（java native interface）直接调用本地C/C++库，这个就相当于C/C++暴露给Java的一个接口，Java 通过调用这个接口从而调用到 C/C++ 方法。</p></blockquote><ul><li>本地方法栈线程私有的。</li><li>本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。</li><li>它的具体做法就是本地方法栈登记native方法，在执行引擎执行时候加载本地方法库。</li></ul><blockquote><p>当调用的是 native 方法时，虚拟机会保持 Java 虚拟机栈不变，也不会向 Java 虚拟机栈中压入新的栈帧，虚拟机只是简单地动态连接并直接调用指定的 native 方法</p></blockquote><ul><li><strong>Hotspot虚拟机中，直接将本地方法栈和虚拟机栈合二为一。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆</title>
      <link href="/2020/06/17/java/jvm/2-5/"/>
      <url>/2020/06/17/java/jvm/2-5/</url>
      
        <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><ul><li>Java堆是虚拟机所管理内存最大的一块区域，并且一个JVM实例只有一个堆，堆是Java内存管理的核心区域。</li><li>Java堆是被所有线程共享的，但是Java堆中还可以划分线程私有的缓冲区（Thread Local Allocation Buffer， TLAB），用来提高对象分配时的效率。</li><li><strong>Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</strong></li><li>Java的程序中，“几乎”所有的对象实例都在这里分配内存。</li></ul><blockquote><p>这里有特殊情况 逃逸分析技术的日渐强大 <strong>栈上分配、标量替换</strong>（后续说明）导致了”几乎”这一情况的发生</p></blockquote><ul><li>方法结束后，堆中的对象不会马上移除，仅仅在垃圾收集的时候才会被移除。</li><li>堆是垃圾收集的重点对象。</li></ul><p><img src="https://image.cclblog.cn/blog/20200617172417.png" alt=""></p><h2 id="堆空间内部结构"><a href="#堆空间内部结构" class="headerlink" title="堆空间内部结构"></a>堆空间内部结构</h2><p><img src="https://image.cclblog.cn/blog/20200617174629.png" alt=""></p><blockquote><p>我认为之所以这种分代设置都是为了方便垃圾收集，基于分代思想，一个应用程序中对象的声明周期不尽相同，每次垃圾回收肯定不能堆空间全部扫描，这样效率太低了，所以才有了对象分代这个思想，不是为了分代而分代，而是为了程序更好的性能，就像不是为了多线程而去盲目使用多线程，而是根据实际情况来使用，一切都要考虑实际情况。</p></blockquote><p><strong>这里不讨论永久代（元空间）！</strong></p><h3 id="年轻代、老年代"><a href="#年轻代、老年代" class="headerlink" title="年轻代、老年代"></a>年轻代、老年代</h3><blockquote><p>存储在JVM中的Java对象有两类：</p><ol><li>一类是生命周期特别短，就像是你写的普通方法中声明的局部变量，大部分都是这样的情况，这类对象创建和消亡都十分迅速。</li><li>另一类对象的声明周期十分的长，这样的对象一般存放在老年代。</li></ol></blockquote><ul><li>几乎所有的Java对象都是在Eden区被new出来的。</li><li>绝大部分的Java对象的销毁都是在新生代进行的。</li><li>“-Xmn参数可以设置新生代最大内存大小”</li></ul><h2 id="设置堆内存大小"><a href="#设置堆内存大小" class="headerlink" title="设置堆内存大小"></a>设置堆内存大小</h2><ul><li>堆的大小在JVM启动时就已经设定好了，可以通过选项“-Xmx”和“-Xms”来进行设置。</li></ul><blockquote><p>“-Xms”用于表示堆区的起始内存，等价于-XX:InittalHeapSize</p><p>“-Xmx”用于表示堆区的最大内存，等价于-XX:MaxHeapSize</p></blockquote><ul><li><p>堆中的内存大小超过“-Xmx“指定的最大内存的时候，就会抛出OutOfMemoryError异常。</p></li><li><p><strong>一般会将-Xms和-Xmx两个参数配置相同的值，目的是为了能够在java垃圾回收机制清理完堆区后不需要重新计算堆区的大小，从而提高性能。</strong></p></li><li><p>默认情况下，初始内存大小：物理电脑内存大小/64；最大内存大小：物理电脑内存大小/4；</p></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Test&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Test());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/blog/20200617181558.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200617181719.png" alt=""></p><blockquote><p>这个结果很明显了正常情况下程序肯定不会OOM -Xms -Xmx 改变了堆的大小，导致这一情况发生。</p></blockquote><h2 id="对象分配的过程"><a href="#对象分配的过程" class="headerlink" title="对象分配的过程"></a>对象分配的过程</h2><ol><li>new的对象先放到Eden区，如果超大对象直接分配到老年代。</li><li>当Eden区空间填满时，创建新的对象，就会触发JVM的垃圾回收机制，对新生区进行垃圾回收（Minor GC），然后在加载新的对象放到Eden区。</li><li>将Eden区中剩余的对象移动到幸存者0区。</li><li>如果再次触发垃圾回收机制，幸存的对象（包括幸存者0区的对象）会全部放入幸存者1区。如此反复</li><li>当一个对象经历15次这样的操作后，历经磨难，就会进入养老区。</li></ol><blockquote><p>15次只是JVM一个默认值，-XX:MaxTenuringThreshold= 这个参数可以设置 15次在Hotspot虚拟机中是最大值。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200617182949.png" alt=""></p><blockquote><p>上面的描述实际上很不全面，你有可能会想：</p><p><strong>进行垃圾回收之后Eden还是空间不足怎么办？</strong></p><p><strong>垃圾回收后将存活的对象移动到其中的一个幸存区的时候内存不够怎么办？</strong></p><p><strong>新对象难道必须经过15次洗礼才能进入到老年区养老吗？</strong></p><p>利用具体的流程图来解释</p></blockquote><p><strong>具体的流程图：</strong></p><p><img src="https://image.cclblog.cn/blog/20200617203602.png" alt=""></p><blockquote><p>这个图算是比较详细的，解释了上面的几个问题。</p></blockquote><h2 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h2><p>JVM在进行GC的时候，肯定不是这三个区域一块回收，要是这样分代有什么意义。大部分回收的是新生代。</p><hr><p>Minor GC/Young GC：只是新生代的垃圾收集。</p><p>Major GC/Old GC：只是老年代的垃圾收集</p><blockquote><p>只有CMS GC会有单独收集老年代的行为。其它的情况就是Full GC。</p><p>还有一种混合收集（Mined GC）只有G1会有这种行为，G1这个垃圾收集器组成很特殊。</p></blockquote><p>Full GC：收集整个java堆和方法区的垃圾。</p><h3 id="GC触发机制"><a href="#GC触发机制" class="headerlink" title="GC触发机制"></a>GC触发机制</h3><h4 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h4><ol><li>当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor区满不会触发GC。Survivor区只能等待Eden区被动清理。这个清理会清理整个新生代。</li><li>Minor GC十分频繁（这里的频繁是相对来说的），回收速度非常快。</li><li>Minor GC会导致STW，暂停用户线程，等待垃圾回收结束，用户线程才恢复运行。</li></ol><h4 id="Major-GC、Full-GC"><a href="#Major-GC、Full-GC" class="headerlink" title="Major GC、Full GC"></a>Major GC、Full GC</h4><ol><li>出现Major GC，一般会伴随至少一次的Minor GC（大部分垃圾收集器都是这样Parallel Scavenge这个比较特殊）。</li><li>如果Major GC后内存还不足，那就完蛋，直接OOM。</li><li>Major GC 很慢，STW时间很长（相对Minor GC）。</li></ol><h2 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>对象的创建在堆中十分频繁，因为堆是线程共享的，在并发的环境下在堆区中划分内存空间是线程不安全的，为了避免多个线程操作同一地址，需要使用加锁的机制，这导致了分配速度有所影响，但是TLAB是堆中开辟的每个线程私有的，就缓解了这个问题。</p><blockquote><p>上面之所以说的缓解是因为并不是全部的对象都是这种方式分配内存的，也不可能这样，这个TLAB的空间非常小，仅仅为Eden空间的1%，-XX:TLABWasteTargetPercent可以设置，虽然只是缓解，但是这也是JVM分配内存的一个首选方式。</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p><strong>TLAB是JVM为每个线程分配的一个私有缓存区域，这个区域在Eden空间内。</strong></p></li><li><p>TLAB快速分配内存，这种内存分配方式称为<strong>快速分配策略。</strong></p></li><li><p>-XX:UseTLAB 设置是否开启TLAB。</p></li><li><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p></li></ul><blockquote><p>分配内存的方式在垃圾那章节说明！</p></blockquote><h2 id="堆空间各种参数总结"><a href="#堆空间各种参数总结" class="headerlink" title="堆空间各种参数总结"></a>堆空间各种参数总结</h2><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>-XX: +PrintFlageInitial</td><td>查看所有的参数的默认初始值</td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>设置新生代对象最大年龄</td></tr><tr><td><strong>-Xms</strong></td><td>初始堆空间内存（默认本机物理内存1/64）</td></tr><tr><td><strong>-Xmx</strong></td><td>最大堆空间内存（默认本机物理内存1/4）</td></tr><tr><td>-Xmn</td><td>设置新生代大小</td></tr><tr><td>-XX:NewRatio</td><td>配置新生代与老年代在堆结构的占比</td></tr><tr><td>-XX:SurvivorRatio</td><td>设置新生代中Eden和s0/s1空间比例</td></tr><tr><td><strong>-XX:+PringGCDetails</strong></td><td>输出详细的GC处理日志</td></tr><tr><td>-XX:HandlePromotionFailure</td><td>是否设置空间分配担保（具体百度这个参数我仅仅了解）</td></tr></tbody></table><h3 id="jinfo查看默认参数"><a href="#jinfo查看默认参数" class="headerlink" title="jinfo查看默认参数"></a>jinfo查看默认参数</h3><p><img src="https://image.cclblog.cn/blog/20200617222501.png" alt=""></p><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>这个博客写的不错：我确实对这个理解不够，不做总结。</p><p><a href="https://www.jianshu.com/p/580f17760f6e" target="_blank" rel="noopener">https://www.jianshu.com/p/580f17760f6e</a> </p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><blockquote><p>平常写代码的时候能使用局部变量的，就不要使用在方法外定义。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC</title>
      <link href="/2020/06/17/java/theme/juc/"/>
      <url>/2020/06/17/java/theme/juc/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>总结中。。。</p>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> JAVA </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> JAVA </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承、封装、多态</title>
      <link href="/2020/06/17/java/javase/2/"/>
      <url>/2020/06/17/java/javase/2/</url>
      
        <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h3 id="概念（is-a）"><a href="#概念（is-a）" class="headerlink" title="概念（is-a）"></a>概念（is-a）</h3><p>继承是类与类之间的一种关系，继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><h3 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h3><ul><li>子类拥有父类非private的属性、方法。</li><li>子类可以拥有自己的属性和方法，也就是子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（重写）</li><li><strong>Java中类只能单继承；接口可以多继承</strong></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">god</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"女娲创造了人类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person吃饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person睡觉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Man狼吞虎咽的吃饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Man负责挣钱"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">god</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"什么女娲创造了人类？"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Woman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Woman</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spendMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Woman负责花钱"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Man(<span class="string">"伏羲"</span>, <span class="number">11</span>);</span><br><span class="line">        person1.eat(); <span class="comment">// man 中重写了person中的eat方法</span></span><br><span class="line">        Man man = <span class="keyword">new</span> Man(<span class="string">"男人"</span>, <span class="number">20</span>);</span><br><span class="line">        man.makeMoney();</span><br><span class="line">        man.god();</span><br><span class="line"></span><br><span class="line">        Woman woman = <span class="keyword">new</span> Woman(<span class="string">"女娲"</span>, <span class="number">12</span>);</span><br><span class="line">        woman.eat(); <span class="comment">// woman 中未重写调用的是person的eat</span></span><br><span class="line">        woman.spendMoney();</span><br><span class="line">        <span class="comment">//woman.god(); // 无法访问父类的私有方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/blog/20200627112158.png" alt=""></p><blockquote><ol><li><p>一个类中如果不声明构造函数，也会默认存在一个无参的构造函数，除非手动声明后，这个默认无参构造函数也就不存在了。</p></li><li><p>构造函数没有返回值，并且不能用void修饰符来修饰。</p></li><li><p>子类的构造函数中会默认调用父类的无参构造函数，如果父类中存在有参的构造函数，那么子类就需要显示的调用了。</p></li><li><p>注意super()和this()不能同时存在，它们是冲突的，并且都必须在第一行来进行调用。</p><p><strong>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</strong></p><p><strong>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</strong></p></li><li><p><strong>用父类来声明子类的时候，比如Person person = new Man()则person无法调用子类中特有的那些方法，编译器编译的时候默认的认为你这个类型就是Person类型的，虽然无法调用子类中特有的方法，但是重写这个特性还是存在的，如果子类重写了父类的方法，并不会去调用父类的方法，这个应该因为重写是动态分派的一种，在运行期才能决定调用哪个方法，编译阶段无法知道你具体调用的哪个方法，自然不会让你编译通过。</strong></p></li></ol></blockquote><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><blockquote><ul><li>我理解的继承就是使程序的设计变得简单了，它的一个最大的好处就是代码复用，我感觉有了继承这个属性，才是真正面向对象的灵魂，真正的抽象出生活中的各种模型，比如，人，男人，女人，都能吃饭，睡觉，但是男人与女人又有不同，通过继承可以非常好的对此进行描述，大大简化了程序的编写。</li><li>过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。为了了解一个类的功能，我们不仅需要查看这个类的代码，还需要按照继承关系一层一层地往上查看“父类、父类的父类……”的代码。还有，子类和父类高度耦合，修改父类的代码，会直接影响到子类。 <strong>多用组合少用继承。</strong> </li></ul></blockquote><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>封装就是把对象的属性和操作结合为一个独立的整体，并尽可能的隐藏对象内部的实现细节。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>良好的封装能够减少耦合。</li><li>类内部的结构可以自由的修改</li></ul><blockquote><p>封装就是你只管提供接口，就像打印机，我打印东西只需点击打印即可，具体的实现我不去管。<strong>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</strong></p></blockquote><ul><li>可以对成员变量进行更精确的控制。</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><blockquote><p>我认为封装就是给你提供接口，让你来使用，你无需知道具体的实现是怎么样的，比如你是一个付费用户，给你提供的接口功能就比免费用户多。不能破坏程序的封装性，破坏了你不是vip成员但是能够使用vip的功能，这个就不好了。</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>多态是同一个行为具有多个不同表现形式或形态的能力。</strong></p><blockquote><p>这个就好比，键盘的快捷键，相同的按键在不同的应用程序中体现出来的效果也不一样。</p><p>就比如ctrl + Y 在idea中是删除快捷键，在eclipse中就可能是别的操作了。</p></blockquote><p>这个多态和虚函数（我在jvm中详细说到这个虚函数非虚函数）。</p><h3 id="多态的三个必要条件"><a href="#多态的三个必要条件" class="headerlink" title="多态的三个必要条件"></a>多态的三个必要条件</h3><ol><li>继承</li><li>重写</li><li>父类引用指向子类对象</li></ol><blockquote><p>就像继承中的例子那样Person person = new Man()这样</p></blockquote><h3 id="重载与多态的区别（重载与多态无关）"><a href="#重载与多态的区别（重载与多态无关）" class="headerlink" title="重载与多态的区别（重载与多态无关）"></a>重载与多态的区别（重载与多态无关）</h3><ol><li>多态是建立在重写的基础之上的，是类与类之间的关系，是发生在不同的类之间的，子类重写父类的方法。实现不同的子类，不同的实现形态。</li><li>而重载是类的内部的方法构型上的不同，是发生在同一个类里面的。同一个函数名称，参数不同的多个方法，实现同一类型的功能。</li></ol><p>具体可以看：</p><p><a href="/java/javase/2020/06/16/1"><strong>重载和重写</strong></a></p><p><a href="/java/jvm/2020/06/16/2-2-1"><strong>深入理解重载和重写</strong></a></p><blockquote><p>知识点之间都是相关的，一开始学的时候只是知道有这个东西，然后随着慢慢的探索就会发现更深入的东西。</p></blockquote><h3 id="多态的表现形式"><a href="#多态的表现形式" class="headerlink" title="多态的表现形式"></a>多态的表现形式</h3><ol><li>重写</li><li>接口</li><li>抽象类抽象方法</li></ol><blockquote><p>这些都很好理解接口只是定义一些规则，每个实现接口的类，实现方式并不相同，抽象类也是这样，继承抽象类的，实现其中的抽象方法，肯定也不一定相同的。</p><p>比如：接口是非机动车靠边行驶。这个在中国的具体实现就是靠右行，在外国就不一定了。这个就是多态。</p></blockquote><h2 id="–"><a href="#–" class="headerlink" title="–"></a>–</h2><blockquote><p><strong>目前我对面向对象的理解还很浅显，或许几年过后，再回头看，会对面向对象有更深层次的理解。</strong></p><p>还有一个这里我没写封装，封装这个属性比较特殊，常常不被称为面向对象变成的<strong>特性</strong>。就是这个思想太过广泛。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重载与重写规则</title>
      <link href="/2020/06/16/java/javase/1/"/>
      <url>/2020/06/16/java/javase/1/</url>
      
        <content type="html"><![CDATA[<h1 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h1><ul><li><strong>被重载的方法必须改变参数列表(参数个数或类型不一样)；</strong></li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li><strong>无法以返回值类型作为重载函数的区分标准。</strong></li></ul><h1 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写(Override)"></a>重写(Override)</h1><ul><li><p><strong>参数列表必须完全与被重写方法的相同。</strong></p></li><li><p>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</p></li><li><p>访问权限不能比父类中被重写的方法的访问权限更低。</p><blockquote><p> 例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</p></blockquote></li><li><p>父类的成员方法只能被它的子类重写。</p></li><li><p>声明为 final 的方法不能被重写。</p></li><li><p>声明为 static 的方法不能被重写，但是能够被再次声明。</p></li><li><p>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</p></li><li><p>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</p></li><li><p>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</p></li><li><p>构造方法不能被重写。</p></li><li><p>如果不能继承一个方法，则不能重写这个方法。</p></li></ul><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><blockquote><p>重载：</p><ol><li>​    编译时的多态</li><li>​    重载发生在同一个类中</li><li>​    函数名相同，参数列表不同(参数的类型，顺序，个数 和参数名没有关系)  和方法的返回值类型无关   (因为编译器 并不知道 调用哪一个函数)</li><li>可以抛出不同的异常，可以有不同修饰符</li></ol><p>重写：</p><ol><li>​    运行时的多态</li><li>​    重载发生在子类与父类中</li><li>​    遵循两同两小一大 </li></ol><p>​            两同：</p><p>​                        函数名<strong>相同</strong></p><p>​                        参数列表<strong>相同</strong></p><p>​            两小：</p><p>​                        子类被重写方法的返回值类型<strong>小于</strong>父类被重写方法的返回值</p><p>​                        子类被重写方法抛出异常的类型<strong>小于</strong>父类被重写方法抛出异常的类型</p><p>​            一大：</p><p>​                        <strong>子类被重写方法的访问权限大于等于父类被重写方法的访问权限</strong></p><p>​        4.构造方法不能被重写，声明为 final 的方法不能被重写，声明为 static 的方法不能被重写（隐藏），但是能够被再次声明，父类的私有方法，子类可以继承 但是子类不能访问，子类不能重写父类的私有方法。</p></blockquote><table><thead><tr><th align="left">区别点</th><th align="left">重载方法</th><th align="left">重写方法</th></tr></thead><tbody><tr><td align="left">参数列表</td><td align="left">必须修改</td><td align="left">一定不能修改</td></tr><tr><td align="left">返回类型</td><td align="left">可以修改</td><td align="left">一定不能修改</td></tr><tr><td align="left">异常</td><td align="left">可以修改</td><td align="left">可以减少或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td align="left">访问</td><td align="left">可以修改</td><td align="left">一定不能做更严格的限制（可以降低限制）</td></tr></tbody></table><blockquote><p><strong>重载是静态分配的表现，重写则是动态分派的表现。</strong></p></blockquote><p><a href="/2020/06/16/java/jvm/2-2-1"><strong>深入理解重载和重写</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分派</title>
      <link href="/2020/06/16/java/jvm/2-2-1/"/>
      <url>/2020/06/16/java/jvm/2-2-1/</url>
      
        <content type="html"><![CDATA[<h1 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h1><h2 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h2><ul><li><p>所有依赖<strong>静态类型</strong>来决定方法执行版本的<strong>分派</strong>动作，都成为静态分派。</p></li><li><p>静态分配的最典型应用表现就是<strong>方法重载。</strong></p></li><li><p>静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。</p></li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Magpie</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(Bird bird)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是鸟！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(Sparrow human)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是鸟中的麻雀！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(Magpie human)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是鸟中的喜鹊！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bird sparrow = <span class="keyword">new</span> Sparrow();</span><br><span class="line">        Bird magpie = <span class="keyword">new</span> Magpie();</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.talk(sparrow);</span><br><span class="line">        test.talk(magpie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><blockquote><p>我是鸟！<br>我是鸟！</p></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><img src="https://image.cclblog.cn/blog/20200616205136.png" alt=""></p><blockquote><p>理解这个要明白<strong>重载是根据<code>静态类型</code>而不是<code>实际类型</code>来判断选择哪个方法的。</strong></p><p>Bird sparrow = new Sparrow();</p><p>这个Bird 称为变量的 <strong>“静态类型”</strong>，而Sparrow 则是 变量的 <strong>“实际类型”</strong>。变量本身的静态类型是不会发生变化的，在编译期是可知的，上图也说明了这一点，程序还未运行便知道要调用的方法。实际类型变化的结果是在运行期间才可以确定的。编译器在编译程序的时候并不知道一个对象的实际类型是什么。</p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void String(Object param) &#123;</span><br><span class="line">        System.out.println(&quot;object&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test(int param) &#123;</span><br><span class="line">        System.out.println(&quot;int&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test.test(&#39;a&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个代码输出什么？</strong></p><p><img src="https://image.cclblog.cn/blog/20200616210755.png" alt=""></p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><blockquote><p>这说明了重载的版本并不是唯一的，但是往往必须确定一个<strong>“相对更加合适的”</strong>版本。</p><p>‘a’是char类型，就去寻找char类型的重载方法，如果此方法不存在，他就会自动进行类型转换’a’也可以代表数字97。所以他就会去执行int类型的重载方法了。</p></blockquote><h2 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h2><ul><li>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</li></ul><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是鸟！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是鸟中的麻雀！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Magpie</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是鸟中的喜鹊！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bird sparrow = <span class="keyword">new</span> Sparrow();</span><br><span class="line">        Bird magpie = <span class="keyword">new</span> Magpie();</span><br><span class="line">        sparrow.talk();</span><br><span class="line">        magpie.talk();</span><br><span class="line">        sparrow = <span class="keyword">new</span> Magpie();</span><br><span class="line">        sparrow.talk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><blockquote><p>我是鸟中的麻雀！<br>我是鸟中的喜鹊！<br>我是鸟中的喜鹊！</p></blockquote><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><blockquote><p>显然重写不是根据静态类型确定调用哪个方法的，而是根据实际类型。子类重写了父类的方法不同的子类必然产生的动作不同，这肯定就不能依靠静态类型来确定了。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200616212607.png" alt=""></p><p><strong>分析main()方法中的字节码:</strong></p><p><img src="https://image.cclblog.cn/blog/20200616214243.png" alt=""></p><h4 id="invokevirtual"><a href="#invokevirtual" class="headerlink" title="invokevirtual"></a>invokevirtual</h4><p>运行时解析过程</p><ol><li><strong>找到操作数栈顶的第一个元素所指向的对象的实际类型，记做C</strong></li><li><strong>如果在类型C中找到与常量中描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；</strong>不通过则返回java.lang.IllegalAccessError异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstartMethodError异常。</li></ol><blockquote><p>这个说的很明白了，第1步不就找到实际类型吗！！<strong>这个过程就是Java语言中方法重写的本质。</strong></p></blockquote><p>既然这种多态性的根源是和invokevirtual这个指令有关，那么这个只能对方法生效对字段是无效的，因为字段并不使用这个指令，<strong>字段永远没有多态这个特性至少目前还没有(jdk14)</strong>。</p><h2 id="彻底理解多态"><a href="#彻底理解多态" class="headerlink" title="彻底理解多态"></a>彻底理解多态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> B().getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span> <span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">            setValue(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value= value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                value ++;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.setValue(value);</span><br><span class="line">                System.out.println(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(<span class="number">5</span>);</span><br><span class="line">            setValue(getValue()- <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.setValue(<span class="number">2</span> * value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><blockquote><span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看输出结果  </a><span class="hide-content">答案：22 34 17</span></span><p><strong>解析：</strong></p><p>​    <strong>执行对象实例化过程中遵循多态特性，调用的方法都是将要实例化的子类中的重写方法，只有明确调用了super.xxx关键词或者是子类中没有该方法时，才会去调用父类相同的同名方法。</strong></p><ol><li>new B()构造一个B类的实例</li><li>B的构造函数中super(5)中显示调用父类A的构造函数</li><li>执行A (int v) =&gt; setValue(v)</li><li>虽然构造函数是A类的构造函数，但此刻正在初始化的对象是B的一个实例，<strong>因此这里调用的实际是B类的setValue方法</strong>，于是调用B类中的setValue方法，而B类中setValue方法显示调用父类的setValue方法，将B实例的value值设置为2 x 5 = <strong>10</strong>。</li><li>至此super(5)这条语句执行完成，紧接着执行setValue(getValue() - 3)</li><li>由于B类中没有重写getValue方法，因此调用父类A的getValue方法。</li><li>value++ 此时B的成员变量value=11，<strong>11这个返回值会先暂存起来</strong>，return value，跳过，先执行finally中的方法。</li><li>this.setValue(value)；调用的是B类的setValue方法，因为此刻正在初始化的是B类的一个对象（运行时多态），然后super.setValue(11 * 2)这里显示调用A类的setValue方法，将B的value设置为了22</li><li>然后System.out.println(value) 因此第一个打印的值为22。</li><li>finally语句执行完毕，会把刚才暂存的11返回出去，也就是说这么经历了这些处理，getValue方法最终的返回值是11。</li><li>setValue(11 - 3) =&gt; setValue(8)</li><li>执行setValue(8)执行的肯定是B类的setValue方法，然后value就变成了16。</li><li>到此new B()构造完毕</li><li>然后执行new B().getValue()方法，B中不存在此方法，所以调用的是A类的此方法。</li><li>value++，B的成员变量value值为17，此时执行到return语句，先暂存，然后执行finally中语句，和之前原理一样，打印出34。</li><li>然后把value = 17返回出去，导致System.out.println(new B().getValue)就打印出17</li><li><strong>所以最终的打印结果就是22 34 17</strong></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序计数器</title>
      <link href="/2020/06/12/java/jvm/2-4/"/>
      <url>/2020/06/12/java/jvm/2-4/</url>
      
        <content type="html"><![CDATA[<h1 id="程序计数器（PC寄存器）"><a href="#程序计数器（PC寄存器）" class="headerlink" title="程序计数器（PC寄存器）"></a>程序计数器（PC寄存器）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>程序计数器是一个记录着当前线程所执行的字节码的行号指示器。</code></p><p>程序计数器（Program Counter Register）是一个非常小的空间，可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><p><strong>如果程序正在执行的是本地（Native）方法，这个计数器的值就为空（Undefined）。</strong>native方法是java通过JNI直接调用C/C++库，相当于C/C++暴露给java的一个接口，java调用这个接口就相当于C/C++去执行相应的代码，肯定不会产生相应的字节码，既然没有字节码，那程序计数器不就没得记录。</p></li><li><p><strong>线程私有，每个线程都存在一个程序计数器。</strong></p></li><li><p><strong>此内存区域是唯一一个不存在OOM情况的区域。</strong></p></li><li><p>占用内存非常小，可以忽略不计。</p></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后</p><p><img src="https://image.cclblog.cn/blog/20200612175746.png" alt=""></p><p>我是用的idea的Jclasslib插件进行反编译的，也可以使用javap来反编译。</p><p>这个类似于行号的就是字节码指令的地址，程序计数器中就是要记录这些地址。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li><strong>为什么使用程序计数器来记录当前线程的执行地址呢？（程序计数器的作用？）</strong></li></ol><blockquote><p>因为CPU需要不停的切换各个线程，这时候CPU切换回需要执行的线程后，就得知道接着从哪开始继续执行。</p><p>JVM的字节码解释器需要通过改变程序计数器的值来明确下一条应该执行什么样的字节码指令。</p></blockquote><ol start="2"><li><strong>程序计数器为什么被设定为线程私有？</strong></li></ol><blockquote><p>JVM的多线程是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的。也就是说，某个线程在执行过程中可能会因为时间片耗尽而被挂起，而另一个线程获取到时间片开始执行。当被挂起的线程重新获取到时间片的时候，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置，在JVM中，通过程序计数器来记录某个线程的字节码执行位置。因此，程序计数器是具备线程隔离的特性，也就是说，每个线程工作时都要有属于自己的独立计数器。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机栈</title>
      <link href="/2020/06/12/java/jvm/2-2/"/>
      <url>/2020/06/12/java/jvm/2-2/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>Java虚拟机栈线程私有，生命周期与线程相同。描述的是Java方法执行的线程内存模型。</p></li><li><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够内存会抛出OutOfMemoryError异常。</p></li></ul><blockquote><p>栈是运行时的单位，而堆是存储的单位。栈解决程序的运行问题，即程序如何执行，数据如何处理。堆解决的是数据的存储问题，即数据怎么放。</p><p>栈就好比你程序中的业务代码，而堆就是存储数据的数据库，数据一个程序是灵魂，如果数据不做处理、可视化，完全是死的数据，我认为是完全没有意义的。</p></blockquote><h3 id="设置栈的大小"><a href="#设置栈的大小" class="headerlink" title="设置栈的大小"></a>设置栈的大小</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码就会导致StackOverflowError异常。递归调用操作不当十分容易导致栈溢出。</p><p><img src="https://image.cclblog.cn/blog/20200613161704.png" alt=""></p><p>test2()这个方法执行了10271次才溢出，可以通过<code>-Xss</code>选项来设置线程的最大栈空间，这个栈空间的大小直接决定了函数的调用的最大深度。</p><p><img src="https://image.cclblog.cn/blog/20200613162335.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200613162909.png" alt=""></p><p>发现test2()方法只运行了541次，得出<code>-Xss</code>改变了栈空间的大小。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>栈是一种快速有效的分配方式，访问速度仅次于程序计数器。</li><li>对于栈来说不存在垃圾回收的问题。</li></ul><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p><strong>栈的存储单位就是栈桢。</strong></p><p>每个方法被执行的时候，java虚拟机都会同步创建一个栈桢用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法从被调用到执行完毕的过程，就对应着一个栈桢在虚拟机中从入栈到出栈的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个程序main()方法中调用test1()，test1()调用test2()，test2()调用test3()。</p></blockquote><p>将程序在test1()处打个断点，平时写代码调试的时候，经常接触栈栈桢，只是有可能不知道这是而已。</p><p><img src="https://image.cclblog.cn/blog/20200613164510.png" alt=""></p><p>然后步入接着执行程序</p><p><img src="https://image.cclblog.cn/blog/20200613164755.png" alt=""></p><p>继续步入执行</p><p><img src="https://image.cclblog.cn/blog/20200613165010.png" alt=""></p><p>test3()方法执行完毕后开始出栈。</p><p><img src="https://image.cclblog.cn/blog/20200613165154.png" alt=""></p><p>之后就是test2出栈test1出栈最后main出栈，程序执行结束。</p><p>这里如果调试的时候执行了下一步怎么返回上一步执行，退回去重新操作。idea提供了丢帧的操作。</p><p><img src="https://image.cclblog.cn/blog/20200613165543.png" alt=""></p><p>抛弃test1()后就回到main()这个栈桢了。</p><p><img src="https://image.cclblog.cn/blog/20200613172005.gif" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200613172046.gif" alt=""></p><blockquote><p>这个就像你写的程序一个方法中调用另一个方法，就相当于妈妈让你爸爸去买醋，然后你爸爸让你去买醋，你买回来后高速你爸爸我买回来了，然后就没你的事情了，然后你爸爸高速你妈妈，买回来了。。。当然你也可以直接告诉你妈妈，，但是程序不行啊。这就是一个入栈出栈的过程，如果你爸爸告诉你去买，你告诉你爸爸去买，无限循环，不就导致错误了吗。</p></blockquote><h2 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h2><ul><li>不同线程中包含的栈桢是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li><li>java方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用return命令；另外一种是抛出异常；</strong>不管使用哪种方式，都会导致栈帧被弹出。</li></ul><h2 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h2><ul><li><strong>局部变量表（*）</strong></li><li><strong>操作数栈（*）</strong></li><li>动态连接</li><li>方法返回地址</li><li>一些附加的信息</li></ul><p><img src="https://image.cclblog.cn/blog/20200613180052.png" alt=""></p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><ul><li><p>局部变量表(Local Variables Table)是一组变量值的存储空间，用于存放<strong>方法参数</strong>和<strong>方法内部定义的局部变量</strong>这些数据类型包括各大基本数据类型、对象引用（reference），以及returnAddress类型。</p><blockquote><p>基本数据类型无需多言，reference就是一个对象实例的引用。returnAddress是为了字节码指令jsr、jsr_w和ret服务的，指向一条字节码指令的地址，目前已经很少使用。</p></blockquote></li><li><p>由于局部变量表在栈帧之中，因此，如果函数的参数和局部变量很多，会使得局部变量表膨胀，因此，每一次函数调用，其局部变量表会占用更多的栈空间，最终导致函数的嵌套调用的次数减少。</p><blockquote><p><strong>栈大小固定，栈中存放栈帧，栈帧中有局部变量表，局部变量表存放局部变量，局部变量很多，占用空间就大，导致栈中可以存放的栈桢变少，自然函数嵌套的次数也就减少</strong></p></blockquote></li><li><p>局部变量表是建立在线程的栈上，是线程的私有数据，<strong>不存在数据安全问题。</strong></p></li><li><p><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，存储在方法的Code属性的maximum local variables数据项中。（后续会说明）在方法运行期间是不会改变局部变量表的大小的。</p></li></ul><blockquote><p>局部变量表中的容量的意思是你这个方法中有多少局部变量，和方法参数，这个肯定是确定的啊，在编译期间就确定的。你自己都能数一数一个方法中有多少变量和参数，更别说编译器了。</p></blockquote><ul><li>局部变量表中的变量只在当前方法中有效。当在方法执行的时候，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也随之销毁。</strong></li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">short</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> d = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">float</span> e = <span class="number">11.2F</span>;</span><br><span class="line">    <span class="keyword">double</span> f = <span class="number">1.1</span>;</span><br><span class="line">    <span class="keyword">char</span> g = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">boolean</span> i = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    String h = <span class="string">"aa"</span>;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析test1()方法的局部变量表：</strong></p><p><img src="https://image.cclblog.cn/blog/20200613220859.png" alt=""></p><p><strong>因为这是静态方法所以并不存在该对象的引用this，如果不是静态方法，index为0的位置就是隐藏的this。</strong></p><p><img src="https://image.cclblog.cn/blog/20200613222439.png" alt=""></p><h4 id="变量槽Slot"><a href="#变量槽Slot" class="headerlink" title="变量槽Slot"></a>变量槽Slot</h4><ul><li>局部变量表，最基本的存储单元是变量槽</li><li>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</li></ul><blockquote><p>byte、short、char在存储前会被转换为int，boolean也被转换为int，0为false，非0表示true。</p><p><strong>long和double占据两个变量槽。</strong></p></blockquote><ul><li>JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量的值。</li><li><strong>如果要访问局部变量表中的一个64bit（long、double）的局部变量值时，只需要使用前一个索引即可。这也是JVM规定必须的。</strong></li><li><strong>如果一个方法不是静态方法，那么该对象的引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。</strong></li><li><strong>变量槽（Slot）可以重复利用</strong></li></ul><h5 id="变量槽的重复利用"><a href="#变量槽的重复利用" class="headerlink" title="变量槽的重复利用"></a>变量槽的重复利用</h5><p>栈帧中的局部变量表中的槽位是可以重复利用的，如果一个局部变量出了它的作用域，那么在其作用域之后申明的局部变量就会复用过期局部变量的槽位，从而达到节省资源的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/blog/20200613224813.png" alt=""></p><blockquote><p>这个代码不是静态代码，所以肯定存在一个this这个对象的引用，为什么是2个槽位，而不是3个槽位，代码中b这个变量出了代码块后，这个变量槽就没必要存储它了，然后a也没必要在重开一个槽位，就相当于占用了b的槽位，把b替换了。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200613225335.png" alt=""></p><blockquote><p>这是你可能会想，如果a是long或者double类型的占用2个槽位，但是b只空出一个槽位，那该怎么算？如果这样的话，槽位就会变成3，而不是4，照样重用那个槽位，然后在添加上一个槽位就可以了。</p></blockquote><p> <img src="https://image.cclblog.cn/blog/20200614154741.png" alt=""></p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><ul><li><p>后入先出（Last In First Out）栈，也常被称作操作栈。</p></li><li><p>同局部变量表一样，操作数栈的最大深度也在编译的时候被写入Code属性的max_stacks数据项之中。</p></li><li><p>栈中的任何一个元素都是可以任意的Java数据类型。<strong>32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。</strong></p></li><li><p>操作数栈<strong>不是采用访问索引的方式来进行数据访问的</strong>，而是只能通过标准的入栈(push)和出栈(pop)操作来完成一次数据访问。</p></li><li><p>操作数栈中元素类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器必须严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。</p></li><li><p><strong>Java虚拟机的解释执行引擎被称为“基于栈的执行引擎”，里面的“栈”就是操作数栈。</strong></p></li></ul><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/blog/20200615162713.png" alt=""></p><p><strong>编译的时候局部变量表和操作数栈的大小和深度就是确定的。</strong></p><p><img src="https://image.cclblog.cn/blog/20200615164022.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164049.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164109.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164158.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164159.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164200.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164302.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164301.png" alt=""></p><h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><ul><li>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现<strong>动态连接。</strong></li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。比如：描述一个方法调用另外的其他方法时候，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态连接的作用就是为了将这些符号引用转换为调用方法的直接引用。</strong></li></ul><blockquote><p>具体描述在方法调用中说明。</p></blockquote><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><ul><li>方法调用阶段的唯一任务就是确定被调用方法到底是哪个方法。一切方法调用在Class文件里面存储的都只是<strong>符号引用</strong>，而不是<strong>方法在运行时内存布局中入口地址（这个就是直接引用）</strong>。</li><li>某些调用需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</li></ul><p><strong>例如</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"琦玉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main()方法中调用了test1()方法，它的字节码为</p><p><img src="https://image.cclblog.cn/blog/20200616155943.png" alt=""></p><p>在java虚拟机中支持以下5条方法调用字节码指令：</p><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td><strong>invokestatic</strong></td><td>用于调用静态方法</td></tr><tr><td><strong>invokespecial</strong></td><td>用于调用实例构造方法<code>&lt;init&gt;()</code>、私有方法和父类中的方法</td></tr><tr><td><strong>invokevirtual</strong></td><td>用于调用所有的<strong>虚方法</strong></td></tr><tr><td><strong>invokeInterface</strong></td><td>用于调用接口方法，会在运行时再确定一个实现该接口的对象</td></tr><tr><td><strong>invokedynamic</strong></td><td><strong>这个最为特殊，具体说明。</strong></td></tr></tbody></table><h4 id="虚方法、非虚方法"><a href="#虚方法、非虚方法" class="headerlink" title="虚方法、非虚方法"></a>虚方法、非虚方法</h4><ul><li>只要是能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，java语言里符合这个条件的方法有<strong>静态方法、私有方法、实例构造器、父类方法</strong>这4种，再加上被final修饰的方法（尽管它是使用invokevirtual指令调用），这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为<code>非虚方法</code>与之相反就是<strong>虚方法</strong>。</li></ul><blockquote><p>静态方法、私有方法、实例构造器、父类方法还有被final修饰的方法有一个共同的特点就是它们都不能通过继承或别的方式重写，之所以叫做非虚我认为就是十分确定的，你调用这些方法能特别肯定的，你的程序中只有一个地方有该方法，是十分确定的，不像有些方法可以重写，重载一样，你调用一个方法系统不知道调用哪个，必须等到程序真正运行调用的时候才能知道，虚无缥缈，所以就叫做虚方法了。</p></blockquote><h4 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h4><p><a href="/2020/06/12/2-2-1">通过分派彻底理解重载和重写</a></p><h4 id="invokedynamic"><a href="#invokedynamic" class="headerlink" title="invokedynamic"></a>invokedynamic</h4><ul><li><p>jdk7中增加的一个指令，<strong>这个指令是为了实现动态类型语言支持而做出的改进。</strong></p></li><li><p>每一处含有invokedynamic指令的位置都被称作“动态调用点”，虽然这个指令是jdk7引用的，但是并没有提供直接生成该指令的方法。<strong>直到java8中的Lambda表达式的出现，invokedynamic指令的生成，在java中才有了直接的生成方式。</strong></p></li></ul><p><strong>动态类型、静态类型语言</strong></p><p>动态语言的特征是它的类型检查的主体过程是在运行期间而不是编译期进行的（例如js、php、python等）相对的在编译期间就进行类型检查过程的语言，例如c++、java就是最常用的静态类型语言。</p><blockquote><p>a = 1; 这个语句在python中就可以执行，但是在java中就会报错，静态语言是对a变量的检查，而动态语言是对1这个值的检查，根据这个值来确定变量a的类型。一个运行时确定，一个编译期确定。</p></blockquote><p><strong>这两个类型的语言各自优点？</strong></p><blockquote><p><strong>静态语言：</strong>能够在编译期确定变量类型，十分严谨，利于系统的稳定性。</p><p><strong>动态语言：</strong>运行时才确定类型，十分灵活，并且静态类型花费很多代码才能实现的功能，动态语言可能很简洁就能实现，提高了开发的效率。</p></blockquote><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>当一个方法开始执行后只有两种方法可以退出这个方法：</p><ol><li>执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层方法的调用者，这种退出的方式为“正常调用完成”。</li></ol><blockquote><p>ireturn(返回值是boolean，byte，char，short和int时使用)、lreturn、freturn、dreturn、areturn（引用类型）、return（void类型）</p></blockquote><ol start="2"><li>方法在执行的过程中遇到了异常，并且这个异常并未在方法内进行处理，这种退出方法的方式称为“异常调用完成”。</li></ol><blockquote><p>一个方法使用异常完成出口的方式退出，是不会给它的上层调用者提供任何返回值的。</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p><strong>方法退出的过程就等同于当前栈帧出栈。这是需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</strong></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clinit()与init()</title>
      <link href="/2020/06/10/java/jvm/2-1-1/"/>
      <url>/2020/06/10/java/jvm/2-1-1/</url>
      
        <content type="html"><![CDATA[<h2 id="lt-clinit-gt-与-lt-init-gt"><a href="#lt-clinit-gt-与-lt-init-gt" class="headerlink" title="&lt;clinit&gt;()与&lt;init&gt;()"></a><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code></h2><h3 id="lt-clinit-gt"><a href="#lt-clinit-gt" class="headerlink" title="&lt;clinit&gt;()"></a><code>&lt;clinit&gt;()</code></h3><ul><li><code>&lt;clinit&gt;()</code>的执行时期为类初始化阶段，并且该方法只能被jvm使用，专门负责类变量的初始化工作。</li><li>Java 类加载的初始化过程中，编译器<strong>按语句在源文件中出现的顺序</strong>，依次自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并产生 <code>&lt;clinit&gt;()</code>方法。 如果类中没有静态语句和静态代码块，那可以不生成该方法。</li><li><code>&lt;clinit&gt;()</code> 不需要显式调用父类（接口除外，接口不需要调用父接口的初始化方法，只有使用到父接口中的静态变量时才需要调用）的初始化方法 <code>&lt;clinit&gt;()</code>，虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。</li></ul><p><strong>类何时进行初始化？（主动引用）</strong></p><blockquote><ol><li>使用new关键字实例化对象的时候；读取或设置一个类型的静态字段（被final修饰的除外，因为已在编译期将结果放入了常量池）；调用一个静态方法。</li><li>使用反射调用。</li><li>初始化类的时候，发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li><li><strong>当使用JDK7新加入的动态语言支持时。（后续在字节码章节详细讲解）</strong></li><li>当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果这个接口的实现类发生了初始化，那么该接口要在其之前被初始化。</li></ol><p><strong>以上的条件是当类或接口未初始化过，即是第一次初始化，才会执行。并且有且只有这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型都不会触发初始化，称为被动引用</strong></p></blockquote><p><strong>被动引用</strong></p><ol><li><p>通过子类引用父类的静态字段，不会导致子类初始化，只会触发父类的初始化。</p></li><li><p>通过数组定义来引用类。</p></li></ol><blockquote><p>假如有一个Student类</p><p>Student[] studentArray = new Student[10];</p><p>这种情况并不会导致Student类进行初始化。你并没有使用Student类中的任何，但是你声明数组，必然会导致和数组相关的类进行了初始化，[Lorg.fenixsoft.classloading.SuperClass 这个类发生了初始化，这是个与一维数组相关的类，具体不做详细介绍。</p></blockquote><ol start="3"><li>使用类中的被final修饰的静态常量。</li></ol><blockquote><p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p></blockquote><h3 id="lt-init-gt"><a href="#lt-init-gt" class="headerlink" title="&lt;init&gt;()"></a><code>&lt;init&gt;()</code></h3><ul><li><p>执行时期：对象的初始化阶段。</p></li><li><p>执行构造器，以及非静态初始化块中的代码。</p></li></ul><p><strong>实例化一个类的四种途径:</strong></p><ol><li>调用 new 操作符</li><li>调用 Class 或 java.lang.reflect.Constructor 对象的newInstance()方法(反射)</li><li>调用任何现有对象的clone()方法</li><li>通过 java.io.ObjectInputStream 类的 getObject() 方法反序列化</li></ol><h3 id="lt-clinit-gt-与-lt-init-gt-执行顺序案例"><a href="#lt-clinit-gt-与-lt-init-gt-执行顺序案例" class="headerlink" title="&lt;clinit&gt;()与&lt;init&gt;()执行顺序案例"></a><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code>执行顺序案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test instance; <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// &lt;clinit&gt;()</span></span><br><span class="line">        System.out.println(<span class="string">"static开始"</span>);</span><br><span class="line">        instance = <span class="keyword">new</span> Test();</span><br><span class="line">        System.out.println(<span class="string">"static结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// &lt;init&gt;()</span></span><br><span class="line">        System.out.println(<span class="string">"构造器开始"</span>);</span><br><span class="line">        System.out.println(<span class="string">"x="</span> + x + <span class="string">";y="</span> + y);</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        System.out.println(<span class="string">"x="</span> + x + <span class="string">";y="</span> + y);</span><br><span class="line">        System.out.println(<span class="string">"构造器结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">1</span>; <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> y; <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test.getInstance();</span><br><span class="line">        System.out.println(<span class="string">"x="</span> + x);</span><br><span class="line">        System.out.println(<span class="string">"y="</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><blockquote><p>static开始<br>构造器开始<br>x=0;y=0<br>x=1;y=1<br>构造器结束<br>static结束<br>x=1<br>y=1</p></blockquote><blockquote><p>从结果中可以看出静态代码块先执行，如果静态代码块中执行了其它方法，则先去执行，然后在回来继续执行，静态代码，这就说明了<code>&lt;clinit&gt;()</code>方法在<code>&lt;init&gt;()</code>之前执行。</p></blockquote><blockquote><p><code>&lt;clinit&gt;()</code>方法就是将一个类中的所有的静态代码块以及类变量整合到一块，注意这里是有顺序的执行，如果其中调用了其它非静态方法，就会执行完后接着执行，如果有父类的话当然执行父类的静态代码块以及类变量，就像下图一样，<strong>把父类和子类的这些静态代码块，类变量全部整合到一块，按照代码编写的顺序来执行。</strong></p><p><code>&lt;init&gt;()</code>也是如此，不过整合的是普通代码块和普通的成员变量了。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200610133639.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载子系统</title>
      <link href="/2020/06/09/java/jvm/2-1/"/>
      <url>/2020/06/09/java/jvm/2-1/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><h3 id="一个类的生命周期"><a href="#一个类的生命周期" class="headerlink" title="一个类的生命周期"></a>一个类的生命周期</h3><p><img src="https://image.cclblog.cn/blog/20200609204057.png" alt=""></p><p>其中加载，验证，准备，初始化，和卸载这五个阶段顺序是确定的，解析阶段则不一定，在某些情况下可以在初始化阶段之后再进行，这是为了支持java语言的运行时绑定特性。</p><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载阶段，java虚拟机需要完成：</p><ol><li><p>通过一个类的全限定名来获取定义此类的二进制字节流。</p></li><li><p>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构。</p></li><li><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p></li></ol><blockquote><p><strong>这个java.lang.Class对象，将相当于一个模具，假如你在家里面自制雪糕，必须有个模具吧，用这个模具来生产雪糕，假如你这个模具是塑料的。</strong></p><p><strong>1.中的字节流就相当于这个模具的第一道加工，把塑料的原料加工成塑料</strong></p><p><strong>2.中的就是相当于第二道加工，塑料模具基本成型，然后运输到方法区</strong></p><p><strong>3.就相当于这个模具上色美化等，真正的成为了一个可以使用的模具了，然后你就可以用它来制作雪糕，你制作的每个雪糕就是一个个对象，他们的形状是一样的，但是具体的内容即原料颜色等可能不一样，这也就是对象的具体内容可能不同</strong></p></blockquote><p><img src="https://image.cclblog.cn/blog/20200609204148.png" alt=""></p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ol><li><strong>文件格式验证</strong>，验证字节流是否符合Class文件格式规范。</li></ol><blockquote><p><strong>就是看看你这个文件是不是符合我要加载的，就相当于一个图片还有各种格式.jpg.png，不能你把随便一个文件的后缀名改成.class就加载你吧。</strong></p></blockquote><ol start="2"><li><strong>元数据验证</strong>，对字节码描述的信息进行验证，保证描述的信息符合，比如一个类是否继承了被final修饰的类，如果一个类不是抽象类，是否实现了其父类或接口中要求实现的方法等。</li></ol><blockquote><p><strong>就是看看程序中代码是否做了规定以外的事情，这个规定就好java的语言规范，就相当于一个人要遵守法律一样，就相当于查一下你有没有犯法，做了规定以外的事情。比如你不是我老婆，我和你睡在了一块？？？</strong></p></blockquote><ol start="3"><li><strong>字节码验证</strong>，验证程序语义是否为合法的，符合逻辑的。</li></ol><blockquote><p><strong>就是详细的检查程序代码是否是安全的，会不会对虚拟机造成威胁，这个阶段最为复杂，三言两语很难说清，要检查的东西有很多</strong></p></blockquote><ol start="4"><li><strong>符号引用验证</strong>，验证一个类是否缺少或者被禁止访问它依赖的某些外部类、方法等。</li></ol><blockquote><p><strong>就是我依赖的类，我能不能访问。比如买了一个苹果手机，看一下我能不能使用它，不能使用的话不就出问题了</strong></p></blockquote><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值阶段。</p><p>例如一个变量定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>那变量在准备阶段过后的初始值为0而不是123，真正把value赋值的操作是在类的初始化阶段才会被执行。</p><p>但是如果 value被声明为 <strong>final</strong>那么在准备阶段就会给value赋值为123</p><p><strong>例如</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test2 instance = Test2.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test2 test2 = <span class="keyword">new</span> Test2();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a="</span> + a);</span><br><span class="line">        System.out.println(<span class="string">"b="</span> + b);</span><br><span class="line">        <span class="keyword">return</span> test2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序的输出结果为 a=1 b=0 并不是a=1 b=1</strong></p><blockquote><p>分析：</p><ol><li>准备阶段，会将静态变量从上到下设置为默认值，a=0,test2=null,b=0</li><li>当调用一个类的静态变量或静态方法会导致该类初始化，并设置成实际的默认值</li><li>此时a还是0，因为它并没有默认值，然后test2 赋值，调用了Test2()构造方法，对a++,b++ ,此时a = 1 b = 1</li><li>然后给b赋值默认值0，这样就导致了覆盖了前面的1，导致最后b=0</li></ol><p>如果变成private static int b = 0;private static Test2 test2 = new Test2();那最后的结果就变成了a=1 b=1了，和代码的顺序有关。</p></blockquote><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。这个阶段很重要，需要了解Class文件的类文件结构。后续会详细讲解。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类的初始化是类加载过程的最后一个步骤，直到初始化阶段，Java虚拟机才真正开始执行类中编写的java程序代码。</p><p>这个阶段是为静态变量赋予正确的初始值，执行静态代码块，执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。</p><p><strong>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，可以赋值但是不能访问。例如：</strong></p><p><img src="https://image.cclblog.cn/blog/20200609204234.png" alt="">    </p><p><strong>java虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。这个说明父类中定义的静态语句块肯定优先于子类执行。例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a =  <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Test1.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果为2，这不就说明了Test父类中的静态代码块被执行了吗。</p><p><strong>如果一个类中没有静态语句块，也没有对变量的赋值操作，编译器就不会生成<code>&lt;clinit&gt;()</code>方法。</strong></p><p><strong>执行接口的<code>&lt;clint&gt;()</code>方法无需先执行父类的<code>&lt;clinit&gt;()</code>方法</strong>，因为当只有父接口中定义的变量被使用时，父接口才会被初始化。接口的实现类在初始化时也不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p><p><strong><code>&lt;clinit&gt;()</code>在多线程环境下是安全的，并且只会被执行一次</strong>，只会有一个线程去执行，其它线程阻塞，直到执行完该方法后，其它线程才能操作，否则一直阻塞，并且<code>&lt;clinit&gt;()</code>只会被多个线程执行一次，执行完后，其它线程将不会再次执行。</p><blockquote><p><strong>这就好比你的目的是制作一辆汽车（一个类的模板），你有必要去生产两个车壳子（其中的静态代码块，赋值操作）吗？程序中只需要一个类模板就行了，<code>&lt;clinit&gt;()</code>方法就相当于类模板的装饰，装饰这个类一开始有哪些属性，也就是出厂设置吧。其他你初始化赋值<code>&lt;init&gt;()</code>方法，就是你自定义的值了。你开多个线程，就相当于多个工厂，一旦其中一个工厂接下了这份活，你得赶紧通知其他的工厂不要做了，如果几个工厂都生产的话，你总不能只给一份钱吧（浪费系统资源）。</strong></p></blockquote><p>这就相当于生产一个汽车零件，你的目的只是制作一辆汽车，你完全没有必要去生产</p><h4 id="lt-clinit-gt-与-lt-init-gt-方法"><a href="#lt-clinit-gt-与-lt-init-gt-方法" class="headerlink" title="&lt;clinit&gt;()与&lt;init&gt;()方法"></a><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code>方法</h4><p>详情见 <strong><a href="/2020/06/10/java/jvm/2-1-1/"><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code>详解</a></strong></p><h3 id="类加载器ClassLoader"><a href="#类加载器ClassLoader" class="headerlink" title="类加载器ClassLoader"></a>类加载器ClassLoader</h3><p><img src="https://image.cclblog.cn/blog/20200611160308.png" alt=""></p><ul><li>启动类加载器（Bootstrap Class Loader）</li></ul><blockquote><ol><li>这个类加载器使用C/C++语言实现的，嵌套在JVM内部。所以java程序中是获取不到的。</li><li>负责加载放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，并且必须被java虚拟机识别（按照文件名识别，.jar），名字不符合即使放在此目录下也不能加载。</li><li>不继承自java.lang.ClassLoader，没有父加载器</li><li>出于安全考虑，只能加载包名为java、javax、sun等开头的类</li></ol></blockquote><ul><li>扩展类加载器（Extension Class Loader）</li></ul><blockquote><ol><li>这个类加载器是在sun.misc.Launcher$ExtClassLoader中以java代码的形式实现的。</li><li>负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li></ol></blockquote><ul><li>应用程序类加载器（Application Class Loader）</li></ul><blockquote><p>这个类加载器由sun.misc.Launcher$AppClassLoader来实现。它负责加载用户类路径上所有的类库。如果应用程序中没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p></blockquote><h4 id="自定义类加载器步骤"><a href="#自定义类加载器步骤" class="headerlink" title="自定义类加载器步骤"></a>自定义类加载器步骤</h4><ol><li>继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器。</li><li>jdk1.2之前，继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载，之后不在建议这样做，而是建议把自定义的类加载逻辑写在findClass()方法中。</li><li>在编写自定义类加载器时，如果需求简单，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，可以使自定义类加载器编写更加简洁。</li></ol><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><blockquote><p>JVM对class文件采用的是<strong>按需加载</strong>的方式，当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，JVM采用的是<strong>双亲委派机制</strong>。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200611134915.png" alt=""></p><p><strong>双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的类加载器中，只有当父加载器反馈自己无法完成这个加载请求时（它的搜索范围内没有找到所需的类）时，子加载器才会尝试自己去完成加载。</strong></p><blockquote><p>双亲委派机制就是：<code>自底向上检查类是否已经加载，自顶向下尝试是否可以加载类</code></p></blockquote><p><strong>类加载流程图：</strong></p><p><img src="https://image.cclblog.cn/blog/20200611143430.jfif" alt=""></p><p><strong>使用双亲委派机制的优势？（为什么要使用双亲委派机制？优点有哪些？）</strong></p><blockquote><ol><li>避免类的重复加载。</li><li>保护核心API被随意篡改。通过委托方式，不会去篡改核心<code>.class</code>，即使篡改也不会去加载，即使加载也不会是同一个<code>.class</code>对象了。不同的加载器加载同一个<code>.class</code>也不是同一个<code>Class</code>对象。这样保证了<code>Class</code>执行安全。</li></ol></blockquote><p><strong>弊端：</strong></p><blockquote><p>双亲委派模型是单向的，永远是子加载器请求父加载器，这就造成了上层的类加载器无法访问下层类加载器所加载的类。例如常见的JDBC就是这样，JDBC在java.sql.Driver中只定义了接口，具体的实现是由具体的数据库厂商来实现的，例如你使用msql，mysql肯定实现了Driver中的接口，但是它的jar在你的目录下，系统类加载器无法识别，你要是用mysql的话就会出现问题，自然就会出现解决的办法。线程上下文类加载器，和jdk6提供的java.util.ServiceLoader类具体不过多介绍。</p></blockquote><h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><p>当父加载器去委托子加载器去加载类的时候就破坏了这个双亲委派模型，双亲委派模型有三次被破坏，具体不做说明。</p><p>这两篇文章写得挺好。</p><p><a href="https://blog.csdn.net/awake_lqh/article/details/106171219" target="_blank" rel="noopener">双亲委派模型的破坏(JDBC例子)</a></p><p><a href="https://blog.csdn.net/sinat_34976604/article/details/86723663" target="_blank" rel="noopener">双亲委派模式破坏-JDBC</a></p><h4 id="jdk9下发生的变化（简）"><a href="#jdk9下发生的变化（简）" class="headerlink" title="jdk9下发生的变化（简）"></a>jdk9下发生的变化（简）</h4><p>jdk9对java进行了模块化，是一次重大的变化，这个模型也随之而变。</p><p><img src="https://image.cclblog.cn/blog/20200611152410.png" alt=""></p><ol><li>扩展类加载器被平台类加载器替代。</li><li>它们都不在派生自java.net.URLClassLoader，而是全部继承于jdk.internal.loader.BuiltinClassLoader。</li><li>这个双亲委派模型发生了变化。</li></ol><blockquote><p>jdk9相当于对java核心代码进行了重构，变成模块化，启动类加载器，平台类加载器，应用程序类加载器，都被明确规定了加载哪些模块的类，这样类的加载过程就变成了，在委派给父类加载器的时候首先看自己是否可以加载此类，这个变化可以说破坏了双亲委派的这个模型。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM简介</title>
      <link href="/2020/06/08/java/jvm/1-1/"/>
      <url>/2020/06/08/java/jvm/1-1/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM（Hotspot）"><a href="#JVM（Hotspot）" class="headerlink" title="JVM（Hotspot）"></a>JVM（Hotspot）</h2><p><img src="https://image.cclblog.cn/blog/20200612162656.png" alt=""></p><p><code>java虚拟机是运行在操作系统之上的，它与硬件没有直接的交互！！！</code></p><h3 id="程序运行的过程"><a href="#程序运行的过程" class="headerlink" title="程序运行的过程"></a>程序运行的过程</h3><p><img src="https://image.cclblog.cn/blog/20200611155155.png" alt=""></p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p><img src="https://image.cclblog.cn/blog/20200611160308.png" alt=""></p><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p><img src="https://image.cclblog.cn/blog/20200611161129.png" alt=""></p><ul><li>99%的垃圾回收操作都是在堆上，所谓的JVM调优实际上就是在对堆的一个调优！！！</li></ul><h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><p><img src="https://image.cclblog.cn/blog/20200611170207.png" alt=""></p><h3 id="JDK不同版本JVM变化"><a href="#JDK不同版本JVM变化" class="headerlink" title="JDK不同版本JVM变化"></a>JDK不同版本JVM变化</h3><ul><li><p>jdk6：存在永久代，静态变量存放在永久代。</p></li><li><p>jdk7：存在永久代，逐步去永久代；将<strong>字符串常量池</strong>和<strong>静态变量</strong>移动到了堆空间中。</p></li><li><p>jdk8：永久代，类型信息、字段、方法、常量保存在本地内存的元空间（Metaspace），字符串常量池、静态变量仍然在堆中。</p></li></ul><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol><li><p>为什么将字符串常量池移入到堆中？（为什么去永久代，改为元空间？）</p><blockquote><ol><li>字符串存在永久代中，容易出现性能问题和内存溢出，因为字符串应该是程序中非常常用的。</li><li>类及方法的信息等比较难确定大小，因此对于永久代的大小指定比较困难。</li><li>永久代会为GC带来不必要的复杂度，并且回收效率很低。</li><li>Oracle将HotSpot与JRockit合二为一，借鉴了后者虚拟机的优点。</li></ol></blockquote></li></ol><h3 id="其他虚拟机"><a href="#其他虚拟机" class="headerlink" title="其他虚拟机"></a>其他虚拟机</h3><p>BEA JRockit，IBM J9不做过多介绍。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2020/06/06/java/theme/jvm/"/>
      <url>/2020/06/06/java/theme/jvm/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><ol><li><strong><a href="/2020/06/08/java/jvm/1-1/">JVM简介</a></strong></li></ol><hr><h2 id="内存结构篇"><a href="#内存结构篇" class="headerlink" title="内存结构篇"></a>内存结构篇</h2><ol><li><strong><a href="/2020/06/09/java/jvm/2-1/">类加载子系统</a></strong> </li><li><a href="/2020/06/12/java/jvm/2-2/"><strong>虚拟机栈</strong></a></li><li><a href="/2020/06/17/java/jvm/2-3/">本地方法栈</a></li><li><strong><a href="/2020/06/12/java/jvm/2-4/">程序计数器</a></strong></li><li><strong><a href="/2020/06/17/java/jvm/2-5/">堆</a></strong></li><li><strong><a href="/2020/06/19/java/jvm/2-6/">方法区</a></strong></li><li><strong><a href="/2020/06/20/java/jvm/2-7/">执行引擎</a></strong></li><li>本地方法接口<strong>（略）</strong></li></ol><hr><h2 id="垃圾回收篇"><a href="#垃圾回收篇" class="headerlink" title="垃圾回收篇"></a>垃圾回收篇</h2><ol><li>垃圾收集器（×）</li><li>内存分配策略（×）</li></ol><h2 id="性能监控与调优篇"><a href="#性能监控与调优篇" class="headerlink" title="性能监控与调优篇"></a>性能监控与调优篇</h2><ol><li>性能监控（×）</li><li>性能调优（×）</li></ol><hr><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><ol><li>StringTable（×）</li><li>字节码（×）</li></ol><hr><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol><li>…（×）</li></ol><hr><p>​    <strong>要快速的学习JVM就要了解你写的一行代码假如Car car = new Car();这个到底在虚拟机中是怎么加载，分配内存等等，然后怎么被回收处理，等，综合性的学习才能学得更快记得更牢固，起初就是一个知识点知识点的学，堆、栈、方法区…就像一开始学是一个点，然后变成碎片，这些组合起来就是jvm的内存结构，慢慢的组成一个网（整个JVM网络），只要组成一个网络化的知识，我说的是并不是这个网络有多么牢固，要明白不求甚解这个道理，尤其是JVM，知识点互相穿插，并不是一个知识点你就能很透彻，有可能你学了别的知识点，然后再看前面恍然大悟，往往我就是这样。而是你有了个整体的认识，就像从上向下看，一目了然，我认为这就是大局观，一定要有这种观念，知识网络化，小到一个知识点，大到系统的一个架构，一切都是思想，一定要有这个思想，显然我在JVM这个上面功力明显不足，我现在还停留在碎片的阶段（2020-06-19），我并不能把这个JVM特别清楚详细的描述，更别说深入的了解，我只是在尝试深入了解，其中有的点我并不是很清楚，形成一个基本的网络时间肯定不会很长，然后慢慢巩固这个网络，不求甚解这个方法形成网络后，肯定不如你平常研究某个知识点掌握那么的牢固，这种情况下，往往是别人问你你了解，知道有这个知识点，但是只能说个支支吾吾大概，这时无需感觉很无奈，感觉自己白学了，首先有了一个知识网络，然后在逐个点的巩固，不断的巩固，总有一天，（其实我非常烦说这个“总有一天” 这到底是哪一天？但是这个确实需要你的用心的，如果你用心时间肯定不会很长，否则确实就是“总有一天了。。。”）这个网络必定会变得非常健壮。</strong></p><blockquote><p>JVM网络，java网络，框架网络等等整合组成整个体系，相信自己肯定有一天会发生质的变化，短期内可能并没有很好地效果，反而会感觉自己哪哪都掌握不牢！！质的变化，对计算机这个这个体系有自己的认识，并不仅仅局限于Java这门语言。</p></blockquote><p>​    学习了JVM这个之后，真后悔没早点学这个，这个真的不是很快就能学习的，不像框架一样基本学一学就用上了，这个需要自己用心去理解，比较偏理论和实践，自己永远不真正环境的调优，只是简单的自我尝试那些效果并不好，应该长期持续的学习并且实战演练，<strong>实战是进步最快的</strong>。我原本打算的是最后学一学的。。。哎然后才发现JVM这个太重要了，这个太有魅力了，真正的让你接触到了一点java代码到底怎么执行的，自己写代码也不少了，从来没有研究过，哎，自己始终在“上层”，混迹“上流社会”，学习了这个让我明白了每一行代码都干了什么（当然不能是每一行那么夸张，自己还没这个水平），让我对内存的分配，一个类的加载，从前我从来没注意过，因为平常写的那些代码怎么可能OOM（顶多研究递归报一个栈溢出），学习了JVM让我对java思想有了很大的进步，不仅是java，是编程的思想，面向对象的思想。</p><p>​    <strong>编程的道路真的是哪有什么岁月静好,不过是有人替你负重前行！就像自己用springboot、springcloud，自己写代码越来越简单，不能总是期待等着出现更好更简单使用的框架，改变自己，别等着别人来改变你！</strong></p><blockquote><p>个人理解，随笔记录，实际上还有很多点，自己的感悟，自己这大学期间的感悟，和生活中的感悟，在<a href="/2020/06/06/life/life/">感悟</a>中慢慢分享。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> JAVA </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2020/06/06/java/theme/arithmetic/"/>
      <url>/2020/06/06/java/theme/arithmetic/</url>
      
        <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ol><li><p><strong><a href="/2020/06/23/java/arithmetic/1/">数组、链表</a></strong></p></li><li><p><strong><a href="/2020/06/23/java/arithmetic/2/">栈、队列、优先队列、双端队列</a></strong></p></li><li><p><a href="">哈希表、映射、集合</a></p></li><li><p><a href="">树、二叉树、二叉搜索树</a></p></li><li><p><strong><a href="/2020/06/26/java/arithmetic/4/">泛型递归、树的递归</a></strong></p></li><li><p><a href="">分治、回溯</a></p></li><li><p><a href="">深度优先搜索、广度优先搜索</a></p></li><li><p><a href="">贪心算法</a></p></li><li><p><a href="">二分查找</a></p></li><li><p><a href="">动态规划</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> JAVA </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> JAVA </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>感悟</title>
      <link href="/2020/06/06/life/life/"/>
      <url>/2020/06/06/life/life/</url>
      
        <content type="html"><![CDATA[<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol><li>初心！</li></ol>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> 感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
            <tag> 主题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
