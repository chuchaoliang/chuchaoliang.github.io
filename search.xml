<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>程序计数器</title>
      <link href="/2020/06/12/java/jvm/2-4/"/>
      <url>/2020/06/12/java/jvm/2-4/</url>
      
        <content type="html"><![CDATA[<h1 id="程序计数器（PC寄存器）"><a href="#程序计数器（PC寄存器）" class="headerlink" title="程序计数器（PC寄存器）"></a>程序计数器（PC寄存器）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>程序计数器是一个记录着当前线程所执行的字节码的行号指示器。</code></p><p>程序计数器（Program Counter Register）是一个非常小的空间，可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><p><strong>如果程序正在执行的是本地（Native）方法，这个计数器的值就为空（Undefined）。</strong>native方法是java通过JNI直接调用C/C++库，相当于C/C++暴露给java的一个接口，java调用这个接口就相当于C/C++去执行相应的代码，肯定不会产生相应的字节码，既然没有字节码，那程序计数器不就没得记录。</p></li><li><p><strong>线程私有，每个线程都存在一个程序计数器。</strong></p></li><li><p><strong>此内存区域是唯一一个不存在OOM情况的区域。</strong></p></li><li><p>占用内存非常小，可以忽略不计。</p></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后</p><p><img src="https://image.cclblog.cn/blog/20200612175746.png" alt=""></p><p>我是用的idea的Jclasslib插件进行反编译的，也可以使用javap来反编译。</p><p>这个类似于行号的就是字节码指令的地址，程序计数器中就是要记录这些地址。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li><strong>为什么使用程序计数器来记录当前线程的执行地址呢？（程序计数器的作用？）</strong></li></ol><blockquote><p>因为CPU需要不停的切换各个线程，这时候CPU切换回需要执行的线程后，就得知道接着从哪开始继续执行。</p><p>JVM的字节码解释器需要通过改变程序计数器的值来明确下一条应该执行什么样的字节码指令。</p></blockquote><ol start="2"><li><strong>程序计数器为什么被设定为线程私有？</strong></li></ol><blockquote><p>JVM的多线程是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的。也就是说，某个线程在执行过程中可能会因为时间片耗尽而被挂起，而另一个线程获取到时间片开始执行。当被挂起的线程重新获取到时间片的时候，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置，在JVM中，通过程序计数器来记录某个线程的字节码执行位置。因此，程序计数器是具备线程隔离的特性，也就是说，每个线程工作时都要有属于自己的独立计数器。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机栈</title>
      <link href="/2020/06/12/java/jvm/2-2/"/>
      <url>/2020/06/12/java/jvm/2-2/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>Java虚拟机栈线程私有，生命周期与线程相同。描述的是Java方法执行的线程内存模型。</p></li><li><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够内存会抛出OutOfMemoryError异常。</p></li></ul><blockquote><p>栈是运行时的单位，而堆是存储的单位。栈解决程序的运行问题，即程序如何执行，数据如何处理。堆解决的是数据的存储问题，即数据怎么放。</p><p>栈就好比你程序中的业务代码，而堆就是存储数据的数据库，数据一个程序是灵魂，如果数据不做处理、可视化，完全是死的数据，我认为是完全没有意义的。</p></blockquote><h3 id="设置栈的大小"><a href="#设置栈的大小" class="headerlink" title="设置栈的大小"></a>设置栈的大小</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码就会导致StackOverflowError异常。递归调用操作不当十分容易导致栈溢出。</p><p><img src="https://image.cclblog.cn/blog/20200613161704.png" alt=""></p><p>test2()这个方法执行了10271次才溢出，可以通过<code>-Xss</code>选项来设置线程的最大栈空间，这个栈空间的大小直接决定了函数的调用的最大深度。</p><p><img src="https://image.cclblog.cn/blog/20200613162335.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200613162909.png" alt=""></p><p>发现test2()方法只运行了541次，得出<code>-Xss</code>改变了栈空间的大小。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>栈是一种快速有效的分配方式，访问速度仅次于程序计数器。</li><li>对于栈来说不存在垃圾回收的问题。</li></ul><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p><strong>栈的存储单位就是栈桢。</strong></p><p>每个方法被执行的时候，java虚拟机都会同步创建一个栈桢用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法从被调用到执行完毕的过程，就对应着一个栈桢在虚拟机中从入栈到出栈的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个程序main()方法中调用test1()，test1()调用test2()，test2()调用test3()。</p></blockquote><p>将程序在test1()处打个断点，平时写代码调试的时候，经常接触栈栈桢，只是有可能不知道这是而已。</p><p><img src="https://image.cclblog.cn/blog/20200613164510.png" alt=""></p><p>然后步入接着执行程序</p><p><img src="https://image.cclblog.cn/blog/20200613164755.png" alt=""></p><p>继续步入执行</p><p><img src="https://image.cclblog.cn/blog/20200613165010.png" alt=""></p><p>test3()方法执行完毕后开始出栈。</p><p><img src="https://image.cclblog.cn/blog/20200613165154.png" alt=""></p><p>之后就是test2出栈test1出栈最后main出栈，程序执行结束。</p><p>这里如果调试的时候执行了下一步怎么返回上一步执行，退回去重新操作。idea提供了丢帧的操作。</p><p><img src="https://image.cclblog.cn/blog/20200613165543.png" alt=""></p><p>抛弃test1()后就回到main()这个栈桢了。</p><p><img src="https://image.cclblog.cn/blog/20200613172005.gif" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200613172046.gif" alt=""></p><blockquote><p>这个就像你写的程序一个方法中调用另一个方法，就相当于妈妈让你爸爸去买醋，然后你爸爸让你去买醋，你买回来后高速你爸爸我买回来了，然后就没你的事情了，然后你爸爸高速你妈妈，买回来了。。。当然你也可以直接告诉你妈妈，，但是程序不行啊。这就是一个入栈出栈的过程，如果你爸爸告诉你去买，你告诉你爸爸去买，无限循环，不就导致错误了吗。</p></blockquote><h2 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h2><ul><li>不同线程中包含的栈桢是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li><li>java方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用return命令；另外一种是抛出异常；</strong>不管使用哪种方式，都会导致栈帧被弹出。</li></ul><h2 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h2><ul><li><strong>局部变量表（*）</strong></li><li><strong>操作数栈（*）</strong></li><li>动态连接</li><li>方法返回地址</li><li>一些附加的信息</li></ul><p><img src="https://image.cclblog.cn/blog/20200613180052.png" alt=""></p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><ul><li><p>局部变量表(Local Variables Table)是一组变量值的存储空间，用于存放<strong>方法参数</strong>和<strong>方法内部定义的局部变量</strong>这些数据类型包括各大基本数据类型、对象引用（reference），以及returnAddress类型。</p><blockquote><p>基本数据类型无需多言，reference就是一个对象实例的引用。returnAddress是为了字节码指令jsr、jsr_w和ret服务的，指向一条字节码指令的地址，目前已经很少使用。</p></blockquote></li><li><p>由于局部变量表在栈帧之中，因此，如果函数的参数和局部变量很多，会使得局部变量表膨胀，因此，每一次函数调用，其局部变量表会占用更多的栈空间，最终导致函数的嵌套调用的次数减少。</p><blockquote><p><strong>栈大小固定，栈中存放栈帧，栈帧中有局部变量表，局部变量表存放局部变量，局部变量很多，占用空间就大，导致栈中可以存放的栈桢变少，自然函数嵌套的次数也就减少</strong></p></blockquote></li><li><p>局部变量表是建立在线程的栈上，是线程的私有数据，<strong>不存在数据安全问题。</strong></p></li><li><p><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，存储在方法的Code属性的maximum local variables数据项中。（字节码章节会将）在方法运行期间是不会改变局部变量表的大小的。</p></li></ul><blockquote><p>局部变量表中的容量的意思是你这个方法中有多少局部变量，和方法参数，这个肯定是确定的啊，在编译期间就确定的。你自己都能数一数一个方法中有多少变量和参数，更别说编译器了。</p></blockquote><ul><li>局部变量表中的变量只在当前方法中有效。当在方法执行的时候，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也随之销毁。</strong></li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">short</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> d = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">float</span> e = <span class="number">11.2F</span>;</span><br><span class="line">    <span class="keyword">double</span> f = <span class="number">1.1</span>;</span><br><span class="line">    <span class="keyword">char</span> g = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">boolean</span> i = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    String h = <span class="string">"aa"</span>;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析test1()方法的局部变量表：</strong></p><p><img src="https://image.cclblog.cn/blog/20200613220859.png" alt=""></p><p><strong>因为这是静态方法所以并不存在该对象的引用this，如果不是静态方法，index为0的位置就是隐藏的this。</strong></p><p><img src="https://image.cclblog.cn/blog/20200613222439.png" alt=""></p><h4 id="变量槽Slot"><a href="#变量槽Slot" class="headerlink" title="变量槽Slot"></a>变量槽Slot</h4><ul><li>局部变量表，最基本的存储单元是变量槽</li><li>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</li></ul><blockquote><p>byte、short、char在存储前会被转换为int，boolean也被转换为int，0为false，非0表示true。</p><p><strong>long和double占据两个变量槽。</strong></p></blockquote><ul><li>JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量的值。</li><li><strong>如果要访问局部变量表中的一个64bit（long、double）的局部变量值时，只需要使用前一个索引即可。这也是JVM规定必须的。</strong></li><li><strong>如果一个方法不是静态方法，那么该对象的引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。</strong></li><li><strong>变量槽（Slot）可以重复利用</strong></li></ul><h5 id="变量槽的重复利用"><a href="#变量槽的重复利用" class="headerlink" title="变量槽的重复利用"></a>变量槽的重复利用</h5><p>栈帧中的局部变量表中的槽位是可以重复利用的，如果一个局部变量出了它的作用域，那么在其作用域之后申明的局部变量就会复用过期局部变量的槽位，从而达到节省资源的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/blog/20200613224813.png" alt=""></p><blockquote><p>这个代码不是静态代码，所以肯定存在一个this这个对象的引用，为什么是2个槽位，而不是3个槽位，代码中b这个变量出了代码块后，这个变量槽就没必要存储它了，然后a也没必要在重开一个槽位，就相当于占用了b的槽位，把b替换了。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200613225335.png" alt=""></p><blockquote><p>这是你可能会想，如果a是long或者double类型的占用2个槽位，但是b只空出一个槽位，那该怎么算？如果这样的话，槽位就会变成3，而不是4，照样重用那个槽位，然后在添加上一个槽位就可以了。</p></blockquote><p> <img src="https://image.cclblog.cn/blog/20200614154741.png" alt=""></p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><ul><li><p>后入先出（Last In First Out）栈，也常被称作操作栈。</p></li><li><p>同局部变量表一样，操作数栈的最大深度也在编译的时候被写入Code属性的max_stacks数据项之中。</p></li><li><p>栈中的任何一个元素都是可以任意的Java数据类型。<strong>32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。</strong></p></li><li><p>操作数栈<strong>不是采用访问索引的方式来进行数据访问的</strong>，而是只能通过标准的入栈(push)和出栈(pop)操作来完成一次数据访问。</p></li><li><p>操作数栈中元素类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器必须严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。</p></li><li><p><strong>Java虚拟机的解释执行引擎被称为“基于栈的执行引擎”，里面的“栈”就是操作数栈。</strong></p></li></ul><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.cclblog.cn/blog/20200615162713.png" alt=""></p><p><strong>编译的时候局部变量表和操作数栈的大小和深度就是确定的。</strong></p><p><img src="https://image.cclblog.cn/blog/20200615164022.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164049.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164109.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164158.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164159.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164200.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164302.png" alt=""></p><p><img src="https://image.cclblog.cn/blog/20200615164301.png" alt=""></p><h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><ul><li>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现<strong>动态连接。</strong></li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。比如：描述一个方法调用另外的其他方法时候，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态连接的作用就是为了将这些符号引用转换为调用方法的直接引用。</strong></li></ul><blockquote><p>具体描述在方法调用中说明。</p></blockquote><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><ul><li>方法调用阶段的唯一任务就是确定被调用方法到底是哪个方法。一切方法调用在Class文件里面存储的都只是<strong>符号引用</strong>，而不是<strong>方法在运行时内存布局中入口地址（这个就是直接引用）</strong>。</li><li>某些调用需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</li></ul><p><strong>例如</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"琦玉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main()方法中调用了test1()方法，它的字节码为</p><p><img src="https://image.cclblog.cn/blog/20200616155943.png" alt=""></p><p>在java虚拟机中支持以下5条方法调用字节码指令：</p><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td><strong>invokestatic</strong></td><td>用于调用静态方法</td></tr><tr><td><strong>invokespecial</strong></td><td>用于调用实例构造方法<code>&lt;init&gt;()</code>、私有方法和父类中的方法</td></tr><tr><td><strong>invokevirtual</strong></td><td>用于调用所有的<strong>虚方法</strong></td></tr><tr><td><strong>invokeInterface</strong></td><td>用于调用接口方法，会在运行时再确定一个实现该接口的对象</td></tr><tr><td><strong>invokedynamic</strong></td><td><strong>这个最为特殊，具体说明。</strong></td></tr></tbody></table><h4 id="虚方法、非虚方法"><a href="#虚方法、非虚方法" class="headerlink" title="虚方法、非虚方法"></a>虚方法、非虚方法</h4><ul><li>只要是能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，java语言里符合这个条件的方法有<strong>静态方法、私有方法、实例构造器、父类方法</strong>这4种，再加上被final修饰的方法（尽管它是使用invokevirtual指令调用），这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为<code>非虚方法</code>与之相反就是<strong>虚方法</strong>。</li></ul><blockquote><p>静态方法、私有方法、实例构造器、父类方法还有被final修饰的方法有一个共同的特点就是它们都不能通过继承或别的方式重写，之所以叫做非虚我认为就是十分确定的，你调用这些方法能特别肯定的，你的程序中只有一个地方有该方法，是十分确定的，不像有些方法可以重写，重载一样，你调用一个方法系统不知道调用哪个，必须等到程序真正运行调用的时候才能知道，虚无缥缈，所以就叫做虚方法了。</p></blockquote><h4 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h4><p><a href="">彻底理解重载和重写</a></p><h4 id="invokedynamic"><a href="#invokedynamic" class="headerlink" title="invokedynamic"></a>invokedynamic</h4><ul><li><p>jdk7中增加的一个指令，<strong>这个指令是为了实现动态类型语言支持而做出的改进。</strong></p></li><li><p>每一处含有invokedynamic指令的位置都被称作“动态调用点”，虽然这个指令是jdk7引用的，但是并没有提供直接生成该指令的方法。<strong>直到java8中的Lambda表达式的出现，invokedynamic指令的生成，在java中才有了直接的生成方式。</strong></p></li></ul><p><strong>动态类型、静态类型语言</strong></p><p>动态语言的特征是它的类型检查的主体过程是在运行期间而不是编译期进行的（例如js、php、python等）相对的在编译期间就进行类型检查过程的语言，例如c++、java就是最常用的静态类型语言。</p><blockquote><p>a = 1; 这个语句在python中就可以执行，但是在java中就会报错，静态语言是对a变量的检查，而动态语言是对1这个值的检查，根据这个值来确定变量a的类型。一个运行时确定，一个编译期确定。</p></blockquote><p><strong>这两个类型的语言各自优点？</strong></p><blockquote><p><strong>静态语言：</strong>能够在编译期确定变量类型，十分严谨，利于系统的稳定性。</p><p><strong>动态语言：</strong>运行时才确定类型，十分灵活，并且静态类型花费很多代码才能实现的功能，动态语言可能很简洁就能实现，提高了开发的效率。</p></blockquote><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>当一个方法开始执行后只有两种方法可以退出这个方法：</p><ol><li>执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层方法的调用者，这种退出的方式为“正常调用完成”。</li></ol><blockquote><p>ireturn(返回值是boolean，byte，char，short和int时使用)、lreturn、freturn、dreturn、areturn（引用类型）、return（void类型）</p></blockquote><ol start="2"><li>方法在执行的过程中遇到了异常，并且这个异常并未在方法内进行处理，这种退出方法的方式称为“异常调用完成”。</li></ol><blockquote><p>一个方法使用异常完成出口的方式退出，是不会给它的上层调用者提供任何返回值的。</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p><strong>方法退出的过程就等同于当前栈帧出栈。这是需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clinit()与init()</title>
      <link href="/2020/06/10/java/jvm/2-1-1/"/>
      <url>/2020/06/10/java/jvm/2-1-1/</url>
      
        <content type="html"><![CDATA[<h2 id="lt-clinit-gt-与-lt-init-gt"><a href="#lt-clinit-gt-与-lt-init-gt" class="headerlink" title="&lt;clinit&gt;()与&lt;init&gt;()"></a><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code></h2><h3 id="lt-clinit-gt"><a href="#lt-clinit-gt" class="headerlink" title="&lt;clinit&gt;()"></a><code>&lt;clinit&gt;()</code></h3><ul><li><code>&lt;clinit&gt;()</code>的执行时期为类初始化阶段，并且该方法只能被jvm使用，专门负责类变量的初始化工作。</li><li>Java 类加载的初始化过程中，编译器<strong>按语句在源文件中出现的顺序</strong>，依次自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并产生 <code>&lt;clinit&gt;()</code>方法。 如果类中没有静态语句和静态代码块，那可以不生成该方法。</li><li><code>&lt;clinit&gt;()</code> 不需要显式调用父类（接口除外，接口不需要调用父接口的初始化方法，只有使用到父接口中的静态变量时才需要调用）的初始化方法 <code>&lt;clinit&gt;()</code>，虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。</li></ul><p><strong>类何时进行初始化？（主动引用）</strong></p><blockquote><ol><li>使用new关键字实例化对象的时候；读取或设置一个类型的静态字段（被final修饰的除外，因为已在编译期将结果放入了常量池）；调用一个静态方法。</li><li>使用反射调用。</li><li>初始化类的时候，发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li><li><strong>当使用JDK7新加入的动态语言支持时。（后续在字节码章节详细讲解）</strong></li><li>当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果这个接口的实现类发生了初始化，那么该接口要在其之前被初始化。</li></ol><p><strong>以上的条件是当类或接口未初始化过，即是第一次初始化，才会执行。并且有且只有这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型都不会触发初始化，称为被动引用</strong></p></blockquote><p><strong>被动引用</strong></p><ol><li><p>通过子类引用父类的静态字段，不会导致子类初始化，只会触发父类的初始化。</p></li><li><p>通过数组定义来引用类。</p></li></ol><blockquote><p>假如有一个Student类</p><p>Student[] studentArray = new Student[10];</p><p>这种情况并不会导致Student类进行初始化。你并没有使用Student类中的任何，但是你声明数组，必然会导致和数组相关的类进行了初始化，[Lorg.fenixsoft.classloading.SuperClass 这个类发生了初始化，这是个与一维数组相关的类，具体不做详细介绍。</p></blockquote><ol start="3"><li>使用类中的被final修饰的静态常量。</li></ol><blockquote><p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p></blockquote><h3 id="lt-init-gt"><a href="#lt-init-gt" class="headerlink" title="&lt;init&gt;()"></a><code>&lt;init&gt;()</code></h3><ul><li><p>执行时期：对象的初始化阶段。</p></li><li><p>执行构造器，以及非静态初始化块中的代码。</p></li></ul><p><strong>实例化一个类的四种途径:</strong></p><ol><li>调用 new 操作符</li><li>调用 Class 或 java.lang.reflect.Constructor 对象的newInstance()方法(反射)</li><li>调用任何现有对象的clone()方法</li><li>通过 java.io.ObjectInputStream 类的 getObject() 方法反序列化</li></ol><h3 id="lt-clinit-gt-与-lt-init-gt-执行顺序案例"><a href="#lt-clinit-gt-与-lt-init-gt-执行顺序案例" class="headerlink" title="&lt;clinit&gt;()与&lt;init&gt;()执行顺序案例"></a><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code>执行顺序案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test instance; <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// &lt;clinit&gt;()</span></span><br><span class="line">        System.out.println(<span class="string">"static开始"</span>);</span><br><span class="line">        instance = <span class="keyword">new</span> Test();</span><br><span class="line">        System.out.println(<span class="string">"static结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// &lt;init&gt;()</span></span><br><span class="line">        System.out.println(<span class="string">"构造器开始"</span>);</span><br><span class="line">        System.out.println(<span class="string">"x="</span> + x + <span class="string">";y="</span> + y);</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        System.out.println(<span class="string">"x="</span> + x + <span class="string">";y="</span> + y);</span><br><span class="line">        System.out.println(<span class="string">"构造器结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">1</span>; <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> y; <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test.getInstance();</span><br><span class="line">        System.out.println(<span class="string">"x="</span> + x);</span><br><span class="line">        System.out.println(<span class="string">"y="</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><blockquote><p>static开始<br>构造器开始<br>x=0;y=0<br>x=1;y=1<br>构造器结束<br>static结束<br>x=1<br>y=1</p></blockquote><blockquote><p>从结果中可以看出静态代码块先执行，如果静态代码块中执行了其它方法，则先去执行，然后在回来继续执行，静态代码，这就说明了<code>&lt;clinit&gt;()</code>方法在<code>&lt;init&gt;()</code>之前执行。</p></blockquote><blockquote><p><code>&lt;clinit&gt;()</code>方法就是将一个类中的所有的静态代码块以及类变量整合到一块，注意这里是有顺序的执行，如果其中调用了其它非静态方法，就会执行完后接着执行，如果有父类的话当然执行父类的静态代码块以及类变量，就像下图一样，<strong>把父类和子类的这些静态代码块，类变量全部整合到一块，按照代码编写的顺序来执行。</strong></p><p><code>&lt;init&gt;()</code>也是如此，不过整合的是普通代码块和普通的成员变量了。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200610133639.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载子系统</title>
      <link href="/2020/06/09/java/jvm/2-1/"/>
      <url>/2020/06/09/java/jvm/2-1/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><h3 id="一个类的生命周期"><a href="#一个类的生命周期" class="headerlink" title="一个类的生命周期"></a>一个类的生命周期</h3><p><img src="https://image.cclblog.cn/blog/20200609204057.png" alt=""></p><p>其中加载，验证，准备，初始化，和卸载这五个阶段顺序是确定的，解析阶段则不一定，在某些情况下可以在初始化阶段之后再进行，这是为了支持java语言的运行时绑定特性。</p><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载阶段，java虚拟机需要完成：</p><ol><li><p>通过一个类的全限定名来获取定义此类的二进制字节流。</p></li><li><p>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构。</p></li><li><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p></li></ol><blockquote><p><strong>这个java.lang.Class对象，将相当于一个模具，假如你在家里面自制雪糕，必须有个模具吧，用这个模具来生产雪糕，假如你这个模具是塑料的。</strong></p><p><strong>1.中的字节流就相当于这个模具的第一道加工，把塑料的原料加工成塑料</strong></p><p><strong>2.中的就是相当于第二道加工，塑料模具基本成型，然后运输到方法区</strong></p><p><strong>3.就相当于这个模具上色美化等，真正的成为了一个可以使用的模具了，然后你就可以用它来制作雪糕，你制作的每个雪糕就是一个个对象，他们的形状是一样的，但是具体的内容即原料颜色等可能不一样，这也就是对象的具体内容可能不同</strong></p></blockquote><p><img src="https://image.cclblog.cn/blog/20200609204148.png" alt=""></p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ol><li><strong>文件格式验证</strong>，验证字节流是否符合Class文件格式规范。</li></ol><blockquote><p><strong>就是看看你这个文件是不是符合我要加载的，就相当于一个图片还有各种格式.jpg.png，不能你把随便一个文件的后缀名改成.class就加载你吧。</strong></p></blockquote><ol start="2"><li><strong>元数据验证</strong>，对字节码描述的信息进行验证，保证描述的信息符合，比如一个类是否继承了被final修饰的类，如果一个类不是抽象类，是否实现了其父类或接口中要求实现的方法等。</li></ol><blockquote><p><strong>就是看看程序中代码是否做了规定以外的事情，这个规定就好java的语言规范，就相当于一个人要遵守法律一样，就相当于查一下你有没有犯法，做了规定以外的事情。比如你不是我老婆，我和你睡在了一块？？？</strong></p></blockquote><ol start="3"><li><strong>字节码验证</strong>，验证程序语义是否为合法的，符合逻辑的。</li></ol><blockquote><p><strong>就是详细的检查程序代码是否是安全的，会不会对虚拟机造成威胁，这个阶段最为复杂，三言两语很难说清，要检查的东西有很多</strong></p></blockquote><ol start="4"><li><strong>符号引用验证</strong>，验证一个类是否缺少或者被禁止访问它依赖的某些外部类、方法等。</li></ol><blockquote><p><strong>就是我依赖的类，我能不能访问。比如买了一个苹果手机，看一下我能不能使用它，不能使用的话不就出问题了</strong></p></blockquote><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值阶段。</p><p>例如一个变量定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>那变量在准备阶段过后的初始值为0而不是123，真正把value赋值的操作是在类的初始化阶段才会被执行。</p><p>但是如果 value被声明为 <strong>final</strong>那么在准备阶段就会给value赋值为123</p><p><strong>例如</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test2 instance = Test2.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test2 test2 = <span class="keyword">new</span> Test2();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a="</span> + a);</span><br><span class="line">        System.out.println(<span class="string">"b="</span> + b);</span><br><span class="line">        <span class="keyword">return</span> test2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序的输出结果为 a=1 b=0 并不是a=1 b=1</strong></p><blockquote><p>分析：</p><ol><li>准备阶段，会将静态变量从上到下设置为默认值，a=0,test2=null,b=0</li><li>当调用一个类的静态变量或静态方法会导致该类初始化，并设置成实际的默认值</li><li>此时a还是0，因为它并没有默认值，然后test2 赋值，调用了Test2()构造方法，对a++,b++ ,此时a = 1 b = 1</li><li>然后给b赋值默认值0，这样就导致了覆盖了前面的1，导致最后b=0</li></ol><p>如果变成private static int b = 0;private static Test2 test2 = new Test2();那最后的结果就变成了a=1 b=1了，和代码的顺序有关。</p></blockquote><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。这个阶段很重要，需要了解Class文件的类文件结构。后续会详细讲解。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类的初始化是类加载过程的最后一个步骤，直到初始化阶段，Java虚拟机才真正开始执行类中编写的java程序代码。</p><p>这个阶段是为静态变量赋予正确的初始值，执行静态代码块，执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。</p><p><strong>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，可以赋值但是不能访问。例如：</strong></p><p><img src="https://image.cclblog.cn/blog/20200609204234.png" alt="">    </p><p><strong>java虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。这个说明父类中定义的静态语句块肯定优先于子类执行。例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a =  <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Test1.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果为2，这不就说明了Test父类中的静态代码块被执行了吗。</p><p><strong>如果一个类中没有静态语句块，也没有对变量的赋值操作，编译器就不会生成<code>&lt;clinit&gt;()</code>方法。</strong></p><p><strong>执行接口的<code>&lt;clint&gt;()</code>方法无需先执行父类的<code>&lt;clinit&gt;()</code>方法</strong>，因为当只有父接口中定义的变量被使用时，父接口才会被初始化。接口的实现类在初始化时也不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p><p><strong><code>&lt;clinit&gt;()</code>在多线程环境下是安全的，并且只会被执行一次</strong>，只会有一个线程去执行，其它线程阻塞，直到执行完该方法后，其它线程才能操作，否则一直阻塞，并且<code>&lt;clinit&gt;()</code>只会被多个线程执行一次，执行完后，其它线程将不会再次执行。</p><blockquote><p><strong>这就好比你的目的是制作一辆汽车（一个类的模板），你有必要去生产两个车壳子（其中的静态代码块，赋值操作）吗？程序中只需要一个类模板就行了，<code>&lt;clinit&gt;()</code>方法就相当于类模板的装饰，装饰这个类一开始有哪些属性，也就是出厂设置吧。其他你初始化赋值<code>&lt;init&gt;()</code>方法，就是你自定义的值了。你开多个线程，就相当于多个工厂，一旦其中一个工厂接下了这份活，你得赶紧通知其他的工厂不要做了，如果几个工厂都生产的话，你总不能只给一份钱吧（浪费系统资源）。</strong></p></blockquote><p>这就相当于生产一个汽车零件，你的目的只是制作一辆汽车，你完全没有必要去生产</p><h4 id="lt-clinit-gt-与-lt-init-gt-方法"><a href="#lt-clinit-gt-与-lt-init-gt-方法" class="headerlink" title="&lt;clinit&gt;()与&lt;init&gt;()方法"></a><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code>方法</h4><p>详情见 <strong><a href="/2020/06/10/java/jvm/2-1-1/"><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code>详解</a></strong></p><h3 id="类加载器ClassLoader"><a href="#类加载器ClassLoader" class="headerlink" title="类加载器ClassLoader"></a>类加载器ClassLoader</h3><p><img src="https://image.cclblog.cn/blog/20200611160308.png" alt=""></p><ul><li>启动类加载器（Bootstrap Class Loader）</li></ul><blockquote><ol><li>这个类加载器使用C/C++语言实现的，嵌套在JVM内部。所以java程序中是获取不到的。</li><li>负责加载放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，并且必须被java虚拟机识别（按照文件名识别，.jar），名字不符合即使放在此目录下也不能加载。</li><li>不继承自java.lang.ClassLoader，没有父加载器</li><li>出于安全考虑，只能加载包名为java、javax、sun等开头的类</li></ol></blockquote><ul><li>扩展类加载器（Extension Class Loader）</li></ul><blockquote><ol><li>这个类加载器是在sun.misc.Launcher$ExtClassLoader中以java代码的形式实现的。</li><li>负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li></ol></blockquote><ul><li>应用程序类加载器（Application Class Loader）</li></ul><blockquote><p>这个类加载器由sun.misc.Launcher$AppClassLoader来实现。它负责加载用户类路径上所有的类库。如果应用程序中没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p></blockquote><h4 id="自定义类加载器步骤"><a href="#自定义类加载器步骤" class="headerlink" title="自定义类加载器步骤"></a>自定义类加载器步骤</h4><ol><li>继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器。</li><li>jdk1.2之前，继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载，之后不在建议这样做，而是建议把自定义的类加载逻辑写在findClass()方法中。</li><li>在编写自定义类加载器时，如果需求简单，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，可以使自定义类加载器编写更加简洁。</li></ol><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><blockquote><p>JVM对class文件采用的是<strong>按需加载</strong>的方式，当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，JVM采用的是<strong>双亲委派机制</strong>。</p></blockquote><p><img src="https://image.cclblog.cn/blog/20200611134915.png" alt=""></p><p><strong>双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的类加载器中，只有当父加载器反馈自己无法完成这个加载请求时（它的搜索范围内没有找到所需的类）时，子加载器才会尝试自己去完成加载。</strong></p><blockquote><p>双亲委派机制就是：<code>自底向上检查类是否已经加载，自顶向下尝试是否可以加载类</code></p></blockquote><p><strong>类加载流程图：</strong></p><p><img src="https://image.cclblog.cn/blog/20200611143430.jfif" alt=""></p><p><strong>使用双亲委派机制的优势？（为什么要使用双亲委派机制？优点有哪些？）</strong></p><blockquote><ol><li>避免类的重复加载。</li><li>保护核心API被随意篡改。通过委托方式，不会去篡改核心<code>.class</code>，即使篡改也不会去加载，即使加载也不会是同一个<code>.class</code>对象了。不同的加载器加载同一个<code>.class</code>也不是同一个<code>Class</code>对象。这样保证了<code>Class</code>执行安全。</li></ol></blockquote><p><strong>弊端：</strong></p><blockquote><p>双亲委派模型是单向的，永远是子加载器请求父加载器，这就造成了上层的类加载器无法访问下层类加载器所加载的类。例如常见的JDBC就是这样，JDBC在java.sql.Driver中只定义了接口，具体的实现是由具体的数据库厂商来实现的，例如你使用msql，mysql肯定实现了Driver中的接口，但是它的jar在你的目录下，系统类加载器无法识别，你要是用mysql的话就会出现问题，自然就会出现解决的办法。线程上下文类加载器，和jdk6提供的java.util.ServiceLoader类具体不过多介绍。</p></blockquote><h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><p>当父加载器去委托子加载器去加载类的时候就破坏了这个双亲委派模型，双亲委派模型有三次被破坏，具体不做说明。</p><p>这两篇文章写得挺好。</p><p><a href="https://blog.csdn.net/awake_lqh/article/details/106171219" target="_blank" rel="noopener">双亲委派模型的破坏(JDBC例子)</a></p><p><a href="https://blog.csdn.net/sinat_34976604/article/details/86723663" target="_blank" rel="noopener">双亲委派模式破坏-JDBC</a></p><h4 id="jdk9下发生的变化（简）"><a href="#jdk9下发生的变化（简）" class="headerlink" title="jdk9下发生的变化（简）"></a>jdk9下发生的变化（简）</h4><p>jdk9对java进行了模块化，是一次重大的变化，这个模型也随之而变。</p><p><img src="https://image.cclblog.cn/blog/20200611152410.png" alt=""></p><ol><li>扩展类加载器被平台类加载器替代。</li><li>它们都不在派生自java.net.URLClassLoader，而是全部继承于jdk.internal.loader.BuiltinClassLoader。</li><li>这个双亲委派模型发生了变化。</li></ol><blockquote><p>jdk9相当于对java核心代码进行了重构，变成模块化，启动类加载器，平台类加载器，应用程序类加载器，都被明确规定了加载哪些模块的类，这样类的加载过程就变成了，在委派给父类加载器的时候首先看自己是否可以加载此类，这个变化可以说破坏了双亲委派的这个模型。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM简介</title>
      <link href="/2020/06/08/java/jvm/1-1/"/>
      <url>/2020/06/08/java/jvm/1-1/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM（Hotspot）"><a href="#JVM（Hotspot）" class="headerlink" title="JVM（Hotspot）"></a>JVM（Hotspot）</h2><p><img src="https://image.cclblog.cn/blog/20200612162656.png" alt=""></p><p><code>java虚拟机是运行在操作系统之上的，它与硬件没有直接的交互！！！</code></p><h3 id="程序运行的过程"><a href="#程序运行的过程" class="headerlink" title="程序运行的过程"></a>程序运行的过程</h3><p><img src="https://image.cclblog.cn/blog/20200611155155.png" alt=""></p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p><img src="https://image.cclblog.cn/blog/20200611160308.png" alt=""></p><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p><img src="https://image.cclblog.cn/blog/20200611161129.png" alt=""></p><ul><li>99%的垃圾回收操作都是在堆上，所谓的JVM调优实际上就是在对堆的一个调优！！！</li></ul><h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><p><img src="https://image.cclblog.cn/blog/20200611170207.png" alt=""></p><h3 id="JDK不同版本JVM变化"><a href="#JDK不同版本JVM变化" class="headerlink" title="JDK不同版本JVM变化"></a>JDK不同版本JVM变化</h3><ul><li><p>jdk6：存在永久代，静态变量存放在永久代。</p></li><li><p>jdk7：存在永久代，逐步去永久代；将<strong>字符串常量池</strong>和<strong>静态变量</strong>移动到了堆空间中。</p></li><li><p>jdk8：永久代，类型信息、字段、方法、常量保存在本地内存的元空间（Metaspace），字符串常量池、静态变量仍然在堆中。</p></li></ul><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol><li><p>为什么将字符串常量池移入到堆中？（为什么去永久代，改为元空间？）</p><blockquote><ol><li>字符串存在永久代中，容易出现性能问题和内存溢出，因为字符串应该是程序中非常常用的。</li><li>类及方法的信息等比较难确定大小，因此对于永久代的大小指定比较困难。</li><li>永久代会为GC带来不必要的复杂度，并且回收效率很低。</li><li>Oracle将HotSpot与JRockit合二为一，借鉴了后者虚拟机的优点。</li></ol></blockquote></li></ol><h3 id="其他虚拟机"><a href="#其他虚拟机" class="headerlink" title="其他虚拟机"></a>其他虚拟机</h3><p>BEA JRockit，IBM J9不做过多介绍。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2020/06/06/java/jvm/jvm/"/>
      <url>/2020/06/06/java/jvm/jvm/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><ol><li><strong><a href="/2020/06/08/java/jvm/1-1/">JVM简介</a></strong></li></ol><hr><h2 id="内存结构篇"><a href="#内存结构篇" class="headerlink" title="内存结构篇"></a>内存结构篇</h2><ol><li><strong><a href="/2020/06/09/java/jvm/2-1/">类加载子系统</a></strong> </li><li><a href="/2020/06/12/java/jvm/2-2/"><strong>虚拟机栈</strong></a></li><li>本地方法栈（×）</li><li><strong><a href="/2020/06/12/java/jvm/2-4/">程序计数器</a></strong></li><li>堆（×）</li><li>方法区（×）</li><li>执行引擎（×）</li><li>本地方法接口/本地方法库（×）</li></ol><hr><h2 id="垃圾回收篇"><a href="#垃圾回收篇" class="headerlink" title="垃圾回收篇"></a>垃圾回收篇</h2><ol><li>垃圾收集器（×）</li><li>内存分配策略（×）</li></ol><h2 id="性能监控与调优篇"><a href="#性能监控与调优篇" class="headerlink" title="性能监控与调优篇"></a>性能监控与调优篇</h2><ol><li>性能监控（×）</li><li>性能调优（×）</li></ol><hr><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><ol><li>StringTable（×）</li><li>字节码（×）</li></ol><hr><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol><li>…（×）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>感悟</title>
      <link href="/2020/06/06/life/life/"/>
      <url>/2020/06/06/life/life/</url>
      
        <content type="html"><![CDATA[<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol><li>算法/多线程/JVM/网络/MySql/Redis/</li><li>提高架构思想/思维</li></ol>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
            <tag> 主题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
