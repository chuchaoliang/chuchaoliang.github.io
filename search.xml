<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>类加载子系统</title>
      <link href="/2020/06/09/java/jvm/jvm_classloader/"/>
      <url>/2020/06/09/java/jvm/jvm_classloader/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><h3 id="一个类的生命周期"><a href="#一个类的生命周期" class="headerlink" title="一个类的生命周期"></a>一个类的生命周期</h3><p><img src="https://image.cclblog.cn/blog/20200609204057.png" alt=""></p><p>其中加载，验证，准备，初始化，和卸载这五个阶段顺序是确定的，解析阶段则不一定，在某些情况下可以在初始化阶段之后再进行，这是为了支持java语言的运行时绑定特性。</p><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载阶段，java虚拟机需要完成：</p><ol><li><p>通过一个类的全限定名来获取定义此类的二进制字节流。</p></li><li><p>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构。</p></li><li><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p><blockquote><p><strong>这个java.lang.Class对象，将相当于一个模具，假如你在家里面自制雪糕，必须有个模具吧，用这个模具来生产雪糕，假如你这个模具是塑料的。</strong></p><p><strong>1.中的字节流就相当于这个模具的第一道加工，把塑料的原料加工成塑料</strong></p><p><strong>2.中的就是相当于第二道加工，塑料模具基本成型，然后运输到方法区</strong></p><p><strong>3.就相当于这个模具上色美化等，真正的成为了一个可以使用的模具了，然后你就可以用它来制作雪糕，你制作的每个雪糕就是一个个对象，他们的形状是一样的，但是具体的内容即原料颜色等可能不一样，这也就是对象的具体内容可能不同</strong></p></blockquote></li></ol><p><img src="https://image.cclblog.cn/blog/20200609204148.png" alt=""></p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ol><li><p><strong>文件格式验证</strong>，验证字节流是否符合Class文件格式规范。</p><blockquote><p><strong>就是看看你这个文件是不是符合我要加载的，就相当于一个图片还有各种格式.jpg.png，不能你把随便一个文件的后缀名改成.class就加载你吧。</strong></p></blockquote></li><li><p><strong>元数据验证</strong>，对字节码描述的信息进行验证，保证描述的信息符合，比如一个类是否继承了被final修饰的类，如果一个类不是抽象类，是否实现了其父类或接口中要求实现的方法等。</p><blockquote><p><strong>就是看看程序中代码是否做了规定以外的事情，这个规定就好java的语言规范，就相当于一个人要遵守法律一样，就相当于查一下你有没有犯法，做了规定以外的事情。比如你不是我老婆，我和你睡在了一块？？？</strong></p></blockquote></li><li><p><strong>字节码验证</strong>，验证程序语义是否为合法的，符合逻辑的。</p><blockquote><p><strong>就是详细的检查程序代码是否是安全的，会不会对虚拟机造成威胁，这个阶段最为复杂，三言两语很难说清，要检查的东西有很多</strong></p></blockquote></li><li><p><strong>符号引用验证</strong>，验证一个类是否缺少或者被禁止访问它依赖的某些外部类、方法等。</p><blockquote><p><strong>就是我依赖的类，我能不能访问，比如你是我老婆，我能不能和你睡在一块？？？不能这就不出问题了</strong></p></blockquote></li></ol><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值阶段。</p><p>例如一个变量定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>那变量在准备阶段过后的初始值为0而不是123，真正把value赋值的操作是在类的初始化阶段才会被执行。</p><p>但是如果 value被声明为 <strong>final</strong>那么在准备阶段就会给value赋值为123</p><p><strong>例如</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test2 instance = Test2.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test2 test2 = <span class="keyword">new</span> Test2();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a="</span> + a);</span><br><span class="line">        System.out.println(<span class="string">"b="</span> + b);</span><br><span class="line">        <span class="keyword">return</span> test2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序的输出结果为 a=1 b=0 并不是a=1 b=1</strong></p><blockquote><p>分析：</p><ol><li>准备阶段，会将静态变量从上到下设置为默认值，a=0,test2=null,b=0</li><li>当调用一个类的静态变量或静态方法会导致该类初始化，并设置成实际的默认值</li><li>此时a还是0，因为它并没有默认值，然后test2 赋值，调用了Test2()构造方法，对a++,b++ ,此时a = 1 b = 1</li><li>然后给b赋值默认值0，这样就导致了覆盖了前面的1，导致最后b=0</li></ol><p>如果变成private static int b = 0;private static Test2 test2 = new Test2();那最后的结果就变成了a=1 b=1了，和代码的顺序有关。</p></blockquote><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。这个阶段很重要，需要了解Class文件的类文件结构。后续会详细讲解。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类的初始化是类加载过程的最后一个步骤，直到初始化阶段，Java虚拟机才真正开始执行类中编写的java程序代码。</p><p>这个阶段是为静态变量赋予正确的初始值，执行静态代码块，执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。</p><p><strong>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，可以赋值但是不能访问。例如：</strong></p><p><img src="https://image.cclblog.cn/blog/20200609204234.png" alt="">    </p><p><strong>java虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。这个说明父类中定义的静态语句块肯定优先于子类执行。例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a =  <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Test1.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果为2，这不就说明了Test父类中的静态代码块被执行了吗。</p><p><strong>如果一个类中没有静态语句块，也没有对变量的赋值操作，编译器就不会生成<code>&lt;clinit&gt;()</code>方法。</strong></p><p><strong>执行接口的<code>&lt;clint&gt;()</code>方法无需先执行父类的<code>&lt;clinit&gt;()</code>方法</strong>，因为当只有父接口中定义的变量被使用时，父接口才会被初始化。接口的实现类在初始化时也不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p><p><strong><code>&lt;clinit&gt;()</code>在多线程环境下是安全的，并且只会被执行一次</strong>，只会有一个线程去执行，其它线程阻塞，直到执行完该方法后，其它线程才能操作，否则一直阻塞，并且<code>&lt;clinit&gt;()</code>只会被多个线程执行一次，执行完后，其它线程将不会再次执行。</p><blockquote><p><strong>这就好比你的目的是制作一辆汽车（一个类的模板），你有必要去生产两个车壳子（其中的静态代码块，赋值操作）吗？程序中只需要一个类模板就行了，<clinit>()方法就相当于类模板的装饰，装饰这个类一开始有哪些属性，也就是出厂设置吧。其他你初始化赋值<init>()方法，就是你自定义的值了。你开多个线程，就相当于多个工厂，一旦其中一个工厂接下了这份活，你得赶紧通知其他的工厂不要做了，如果几个工厂都生产的话，你总不能只给一份钱吧（浪费系统资源）。</strong></p></blockquote><p>这就相当于生产一个汽车零件，你的目的只是制作一辆汽车，你完全没有必要去生产</p><h4 id="lt-clinit-gt-与-lt-init-gt-方法"><a href="#lt-clinit-gt-与-lt-init-gt-方法" class="headerlink" title="&lt;clinit&gt;()与&lt;init&gt;()方法"></a><code>&lt;clinit&gt;()</code>与<code>&lt;init&gt;()</code>方法</h4><p>详情见</p><h3 id="类加载器ClassLoader"><a href="#类加载器ClassLoader" class="headerlink" title="类加载器ClassLoader"></a>类加载器ClassLoader</h3><p><img src="https://image.cclblog.cn/blog/20200609204422.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM简介</title>
      <link href="/2020/06/08/java/jvm/jvm_description/"/>
      <url>/2020/06/08/java/jvm/jvm_description/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM简介"><a href="#JVM简介" class="headerlink" title="JVM简介"></a>JVM简介</h2><h3 id="JVM家族"><a href="#JVM家族" class="headerlink" title="JVM家族"></a>JVM家族</h3><h4 id="HotSpot-VM"><a href="#HotSpot-VM" class="headerlink" title="HotSpot VM"></a>HotSpot VM</h4><p>Oracle官方指定java虚拟机，也是我们日常使用的java虚拟机，大概结构如下（简图）。</p><p><img src="https://image.cclblog.cn/blog/20200609204335.png" alt=""></p><p>图中红色区域（方法区，堆）为线程公有，蓝色区域（虚拟机栈，本地方法栈，程序计数器）为线程私有。</p><p>JVM中内存通常划分为两部分，分别为<code>堆内存</code>和<code>栈内存</code>。</p><p>堆内存常见错误<strong>OOM（OutOfMemoryError）</strong></p><p>栈内存溢出常见错误<strong>StackOverflowError</strong>，程序有递归调用时容易发生。</p><h4 id="JDK不同版本JVM变化"><a href="#JDK不同版本JVM变化" class="headerlink" title="JDK不同版本JVM变化"></a>JDK不同版本JVM变化</h4><p>jdk7之前，使用永久代来实现方法区，其中jdk7提出去永久代，并且将<strong>字符串常量池</strong>和<strong>静态变量</strong>移动到了堆空间中。由于把字符串常量池放入了堆中这就导致了jdk7之前和jdk7之后版本的字符串的存储比较发生了不小的变化。这个会在之后详细说明。</p><p>jdk8中，已经彻底没有了永久代，将方法区直接放在了一个与堆不想连得本地内存区域，这个区域就叫做元空间（Metaspace）。</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol><li><p>为什么将字符串常量池移入到堆中？（为什么去永久代，改为元空间？）</p><blockquote><ol><li>字符串存在永久代中，容易出现性能问题和内存溢出，因为字符串应该是程序中非常常用的。</li><li>类及方法的信息等比较难确定大小，因此对于永久代的大小指定比较困难。</li><li>永久代会为GC带来不必要的复杂度，并且回收效率很低。</li><li>Oracle将HotSpot与JRockit合二为一，借鉴了后者虚拟机的优点。</li></ol></blockquote></li></ol><h4 id="其他虚拟机"><a href="#其他虚拟机" class="headerlink" title="其他虚拟机"></a>其他虚拟机</h4><p>BEA JRockit，IBM J9不做过多介绍。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2020/06/06/java/jvm/jvm/"/>
      <url>/2020/06/06/java/jvm/jvm/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><ol><li>JVM简介（×）</li></ol><hr><h2 id="内存结构篇"><a href="#内存结构篇" class="headerlink" title="内存结构篇"></a>内存结构篇</h2><ol><li><a href="/2020/06/09/java/jvm/jvm_classloader/">类加载子系统</a> </li><li>虚拟机栈（×）</li><li>本地方法栈（×）</li><li>程序计数器（×）</li><li>堆（×）</li><li>方法区（×）</li><li>执行引擎（×）</li><li>本地方法接口/本地方法库（×）</li></ol><hr><h2 id="垃圾回收篇"><a href="#垃圾回收篇" class="headerlink" title="垃圾回收篇"></a>垃圾回收篇</h2><ol><li>垃圾收集器（×）</li><li>内存分配策略（×）</li></ol><h2 id="性能监控与调优篇"><a href="#性能监控与调优篇" class="headerlink" title="性能监控与调优篇"></a>性能监控与调优篇</h2><ol><li>性能监控（×）</li><li>性能调优（×）</li></ol><hr><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><ol><li>StringTable（×）</li><li>字节码（×）</li></ol><hr><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol><li>…（×）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>感悟</title>
      <link href="/2020/06/06/life/life/"/>
      <url>/2020/06/06/life/life/</url>
      
        <content type="html"><![CDATA[<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol><li>算法/多线程/JVM/网络/MySql/Redis/</li><li>提高架构思想/思维</li></ol>]]></content>
      
      
      <categories>
          
          <category> 主题 </category>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
            <tag> 主题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
