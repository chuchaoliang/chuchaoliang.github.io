<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>题集（第二周） | 琦玉老师</title><meta name="description" content="2020-06-22 第一周"><meta name="keywords" content="JAVA,题集"><meta name="author" content="褚超亮"><meta name="copyright" content="褚超亮"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="题集（第二周）"><meta name="twitter:description" content="2020-06-22 第一周"><meta name="twitter:image" content="https://www.cclblog.cn/img/avatar.png"><meta property="og:type" content="article"><meta property="og:title" content="题集（第二周）"><meta property="og:url" content="https://www.cclblog.cn/2020/06/29/java/question/2/"><meta property="og:site_name" content="琦玉老师"><meta property="og:description" content="2020-06-22 第一周"><meta property="og:image" content="https://www.cclblog.cn/img/avatar.png"><meta property="article:published_time" content="2020-06-29T02:00:52.000Z"><meta property="article:modified_time" content="2020-07-05T02:47:07.677Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://www.cclblog.cn/2020/06/29/java/question/2/"><link rel="prev" title="抽象类VS接口" href="https://www.cclblog.cn/2020/06/29/java/javase/17/"><link rel="next" title="设计模式" href="https://www.cclblog.cn/2020/06/28/java/theme/design_mode/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"top-center"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">36</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">10</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">20</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第二周"><span class="toc-text">第二周</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础"><span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1"><span class="toc-text">1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2"><span class="toc-text">2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3"><span class="toc-text">3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4"><span class="toc-text">4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5"><span class="toc-text">5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6"><span class="toc-text">6</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7"><span class="toc-text">7</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8"><span class="toc-text">8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9"><span class="toc-text">9</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10"><span class="toc-text">10</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11"><span class="toc-text">11</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12"><span class="toc-text">12</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13"><span class="toc-text">13</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14"><span class="toc-text">14</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15"><span class="toc-text">15</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16"><span class="toc-text">16</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17"><span class="toc-text">17</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19"><span class="toc-text">19</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20"><span class="toc-text">20</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21"><span class="toc-text">21</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22"><span class="toc-text">22</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23"><span class="toc-text">23</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24"><span class="toc-text">24</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25"><span class="toc-text">25</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26"><span class="toc-text">26</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27"><span class="toc-text">27</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28"><span class="toc-text">28</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29"><span class="toc-text">29</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#try-catch-finally-规则"><span class="toc-text">try-catch-finally 规则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程"><span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#30"><span class="toc-text">30</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO"><span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31"><span class="toc-text">31</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法"><span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#32"><span class="toc-text">32</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#33"><span class="toc-text">33</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://image.cclblog.cn/a3bd9cb49cbd3ffa4c9e178577b6dffe.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">琦玉老师</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">题集（第二周）</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-29 10:00:52"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-06-29</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-05 10:47:07"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-07-05</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JAVA/">JAVA</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JAVA/%E9%A2%98%E9%9B%86/">题集</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">7.3k</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p><strong>尝试编译以下程序会产生怎么样的结果？（）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">var</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">long</span> param)</span> </span>&#123; <span class="keyword">var</span> = param; &#125;<span class="comment">//(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClass a, b;</span><br><span class="line">        a =<span class="keyword">new</span> MyClass();<span class="comment">//(2)</span></span><br><span class="line">        b =<span class="keyword">new</span> MyClass(<span class="number">5</span>);<span class="comment">//(3)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>编译错误将发生在（1），因为构造函数不能指定返回值</li>
<li><strong>B：</strong>编译错误将发生在（2），因为该类没有默认构造函数</li>
<li><strong>C：</strong>编译错误将在（3）处发生，因为该类没有构造函数，该构造函数接受一个int类型的参数</li>
<li><strong>D：</strong>该程序将正确编译和执行</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：C</span></span>

<p><strong>解析：</strong></p>
<p>这道题一定要看仔细了，<strong>MyClass方法并不是构造参数</strong>，而是返回类型为void的普通方法，普通方法自然需要实例化对象然后去调用它，所以124不对，第三个是正确的，因为没有带参数的构造器，所以自然不能传一个int进去。</p>
</blockquote>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>从内存实现或者反射的角度来看，关于继承的说法正确的是（）。</p>
<p><strong>注：此处的继承不代表能调用</strong></p>
<ul>
<li><strong>A：</strong>子类将继承父类的所有的数据域和方法</li>
<li><strong>B：</strong>子类将继承父类的其可见的数据域和方法</li>
<li><strong>C：</strong>子类只继承父类public方法和数据域</li>
<li><strong>D：</strong>子类只继承父类的方法，而不继承数据域</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p>子类可以继承父类的全部数据域和方法，但是这里继承代表的是“拥有”，即：只是拥有父类的全部数据域和方法，但不具备对某些私有数据域或私有方法的使用权（调用）。</p>
<p><strong>这道题明确标注：此处的继承不代表能调用。</strong></p>
</blockquote>
<h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p><strong>java语言的下面几种数组复制方法中，哪个效率最高？</strong></p>
<ul>
<li><strong>A：</strong>for 循环逐一复制</li>
<li><strong>B：</strong>System.arraycopy</li>
<li><strong>C：</strong>Array.copyOf</li>
<li><strong>D：</strong>使用clone方法</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：B</span></span>

<p><strong>解析：</strong></p>
<p> 复制的效率<strong>System.arraycopy&gt;clone&gt;Arrays.copyOf&gt;for循环</strong></p>
<p>这里面在System类源码中给出了arraycopy的方法，是native方法，也就是本地方法，肯定是最快的。而Arrays.copyOf(注意是Arrays类，不是Array实现的，在源码中是调用System.copyOf的，多了一个步骤，肯定就不是最快的。</p>
</blockquote>
<h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p><strong>下列代码的输出结果是_</strong></p>
<ul>
<li><strong>A：</strong>true</li>
<li><strong>B：</strong>false</li>
<li><strong>C：</strong>null</li>
<li><strong>D：</strong>空字符串</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：B</span></span>

<p><strong>解析：</strong></p>
<p>==  优先级高于 三目运算符，先判断   true == true，此时返回为  true,</p>
<p>这时表达式为   boolean b = true?false:true?false:true</p>
<p>此时三目运算符从右向左执行,true?false:true，返回false</p>
<p>这时表达式为  boolean b = true?false:false;</p>
<p>结果为：boolean b = false ;</p>
</blockquote>
<h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p><strong>（多选）Which statement declares a variable a which is suitable for referring to an array of 50 string objects?（Java）</strong></p>
<ul>
<li><strong>A：</strong>char a[][];</li>
<li><strong>B：</strong>String a[];</li>
<li><strong>C：</strong>String[] a;</li>
<li><strong>D：</strong>Object a[50];</li>
<li><strong>E：</strong>String a[50];</li>
<li><strong>F：</strong>Object a[];</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：BCF</span></span>

<p><strong>解析：</strong></p>
<p><strong>在java 中，声明一个数组时，不能直接限定数组长度，只有在创建实例化对象时，才能对给定数组长度。</strong></p>
<p>如下，1、2、3可以通过编译，4、5不行。而String是Object的子类，所以上述BCF均可定义一个存放50个String类型对象的数组。</p>
<ol>
<li><p>String a[]=new String[50];</p>
</li>
<li><p>String b[];</p>
</li>
<li><p>char c[];</p>
</li>
<li><p>String d[50];</p>
</li>
<li><p>char e[50];</p>
</li>
</ol>
</blockquote>
<h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><p><strong>运行代码，输出的结果是（）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> abc = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"P is init"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">S</span> <span class="keyword">extends</span> <span class="title">P</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"S is init"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(S.abc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>P is init<br />123</li>
<li><strong>B：</strong>S is init<br />P is init<br />123</li>
<li><strong>C：</strong>P is init<br />S is init<br />123</li>
<li><strong>D：</strong>S is init<br />123</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p><strong>被动引用不会出发子类初始化</strong> </p>
<p> 1.子类引用父类的静态字段，只会触发子类的加载、父类的初始化，不会导致子类初始化 </p>
<p> 2.通过数组定义来引用类，不会触发此类的初始化 </p>
<p> 3.常量在编译阶段会进行常量优化，将常量存入调用类的常量池中， 本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 </p>
</blockquote>
<h4 id="7"><a href="#7" class="headerlink" title="7"></a>7</h4><p><strong>下列哪个选项是Java调试器？如果编译器返回程序代码的错误，可以用它对程序进行调试。</strong></p>
<ul>
<li><strong>A：</strong>java.exe</li>
<li><strong>B：</strong>javadoc.exe</li>
<li><strong>C：</strong>jdb.exe</li>
<li><strong>D：</strong>javaprof.exe</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：C</span></span>

<p><strong>解析：</strong></p>
<p>javac.exe是编译.java文件</p>
<p>java.exe是执行编译好的.class文件</p>
<p>javadoc.exe是生成Java说明文档</p>
<p>jdb.exe是Java调试器</p>
<p>javaprof.exe是剖析工具</p>
</blockquote>
<p><strong>class A {}</strong><br><strong>class B extends A {}</strong><br><strong>class C extends A {}</strong><br><strong>class D extends B {}</strong><br><strong>（多选）Which four statements are true ?</strong></p>
<ul>
<li><strong>A：</strong>The type List<A>is assignable to List.</li>
<li><strong>B：</strong>The type List<B>is assignable to List<A>.</li>
<li><strong>C：</strong>The type List<Object>is assignable to List&lt;?&gt;.</li>
<li><strong>D：</strong>The type List<D>is assignable to List&lt;?extends B&gt;.</li>
<li><strong>E：</strong>The type List&lt;?extends A&gt;is assignable to List<A>.</li>
<li><strong>F：</strong>The type List<Object>is assignable to any List reference.</li>
<li><strong>G：</strong>The type List&lt;?extends B&gt;is assignable to List&lt;?extends A&gt;.</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：ACDG</span></span>

<p><strong>解析：</strong></p>
<p><strong>1.  只看尖括号里边的！！明确点和范围两个概念</strong></p>
<p><strong>2. 如果尖括号里的是一个类，那么尖括号里的就是一个点，比如List<A>,List<B>,List<Object></strong></p>
<p><strong>3. 如果尖括号里面带有问号，那么代表一个范围，<? extends A> 代表小于等于A的范围，<? super A>代表大于等于A的范围，<?>代表全部范围</strong></p>
<p><strong>4. 尖括号里的所有点之间互相赋值都是错，除非是俩相同的点</strong></p>
<p><strong>5. 尖括号小范围赋值给大范围，对，大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值，否则，不能赋值</strong></p>
<p><strong>6. List&lt;?&gt;和List 是相等的，都代表最大范围</strong></p>
<p><strong>7. List既是点也是范围，当表示范围时，表示最大范围</strong></p>
<hr>
<p>A：√ List就是List&lt;?&gt;代表最大的范围，A只是其中的一个点，肯定包含在内。</p>
<p>B：× 点与点之间不能相互赋值</p>
<p>C：√ List&lt;?&gt;表示最大的范围，List<Object>只是一个点，肯定被包含在内</p>
<p>D：√ List&lt;? extends B&gt;代表小于等于B的范围，List<D>是一个点，在其中。</p>
<p>E：× 点不能赋值给点</p>
<p>F：× List<Object>是一个点</p>
<p>G：√ 小于等于A的范围包含小于等于B的范围</p>
</blockquote>
<h4 id="8"><a href="#8" class="headerlink" title="8"></a>8</h4><p><strong>（多选）如下哪些是 java 中有效的关键字（）</strong></p>
<ul>
<li><strong>A：</strong>native</li>
<li><strong>B：</strong>NULL</li>
<li><strong>C：</strong>false</li>
<li><strong>D：</strong>this</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：AD</span></span>

<p><strong>解析：</strong></p>
<p>true、false、null都不是关键字</p>
<p>goto、const、是保留的关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span>                <span class="keyword">continue</span>           <span class="keyword">for</span>            <span class="keyword">new</span>       </span><br><span class="line"><span class="keyword">switch</span>                  <span class="keyword">default</span>            <span class="keyword">if</span>             <span class="keyword">package</span>   </span><br><span class="line"><span class="keyword">synchronized</span>            <span class="keyword">do</span>                 goto           <span class="keyword">private</span>   </span><br><span class="line"><span class="keyword">this</span>                    <span class="keyword">break</span>              <span class="keyword">double</span>         implements </span><br><span class="line"><span class="keyword">protected</span>               <span class="keyword">throw</span>              <span class="keyword">byte</span>           <span class="keyword">else</span>       </span><br><span class="line"><span class="keyword">import</span>                  <span class="keyword">public</span>             <span class="keyword">throws</span>         <span class="keyword">case</span>       </span><br><span class="line"><span class="keyword">enum</span>                    <span class="keyword">instanceof</span>         <span class="keyword">return</span>         <span class="keyword">transient</span> </span><br><span class="line"><span class="keyword">catch</span>                   extends            <span class="keyword">int</span>            <span class="keyword">short</span>     </span><br><span class="line"><span class="keyword">try</span>                     <span class="keyword">char</span>               <span class="keyword">final</span>          <span class="class"><span class="keyword">interface</span> </span></span><br><span class="line"><span class="class"><span class="title">static</span>                  <span class="title">void</span>               <span class="title">class</span>          <span class="title">finally</span>   </span></span><br><span class="line"><span class="class"><span class="title">long</span>                    <span class="title">strictfp</span>           <span class="title">volatile</span>       <span class="title">const</span>    </span></span><br><span class="line"><span class="class"><span class="title">float</span>                   <span class="title">native</span>             <span class="title">super</span>          <span class="title">while</span></span></span><br><span class="line"><span class="class"><span class="title">boolean</span>                 <span class="title">assert</span> </span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="9"><a href="#9" class="headerlink" title="9"></a>9</h4><p><strong>What results from the following code fragment?</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">System.out.println(i + ~j);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>Compilation error because”~”doesn’t operate on integers</li>
<li><strong>B：</strong>-5</li>
<li><strong>C：</strong>-6</li>
<li><strong>D：</strong>15</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：C</span></span>

<p><strong>解析：</strong></p>
<p><strong>公式-n= ~ n+1可推出 ~ n=-n-1，所以~10=-11再加5结果为-6</strong></p>
<p>计算机本身储存的就是补码：</p>
<p>那么10的补码就是10的原码：0000 0000 0000 1010——这是补码，因为现在是计算机在计算</p>
<p>~10的补码就是：1111 1111 1111 0101</p>
<p>~10的反码就是：1111 1111 1111 0100——补码减1</p>
<p>~10的原码就是：1000 0000 0000 1011——反码取反：这个才是正常二进制数，换算为整数为-11</p>
<p>原码才可以对应为正常的整数，补码只有转换为原码才能被正常人类识别。</p>
</blockquote>
<h4 id="10"><a href="#10" class="headerlink" title="10"></a>10</h4><p><strong>抽象类方法的访问权限默认都是public。（  ）</strong></p>
<ul>
<li><strong>A：</strong>正确</li>
<li><strong>B：</strong>错误</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：B</span></span>

<p><strong>解析：</strong></p>
<p><strong>关于抽象类</strong></p>
<p>JDK 1.8以前，抽象类的方法默认访问权限为protected</p>
<p>JDK 1.8时，抽象类的方法默认访问权限变为default</p>
<p><strong>关于接口</strong></p>
<p>JDK 1.8以前，接口中的方法必须是public的</p>
<p>JDK 1.8时，接口中的方法可以是public的，也可以是default的</p>
<p>JDK 1.9时，接口中的方法可以是private的</p>
</blockquote>
<h4 id="11"><a href="#11" class="headerlink" title="11"></a>11</h4><p><strong>（多选）Java创建对象的说法正确的有（）</strong></p>
<ul>
<li><strong>A：</strong>用new语句创建对象，是最常见的创建对象的方法。</li>
<li><strong>B：</strong>运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。</li>
<li><strong>C：</strong>调用对象的clone()方法。</li>
<li><strong>D：</strong>运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：ABCD</span></span>

<p><strong>解析：</strong></p>
<p>Java有5种方式来创建对象：</p>
<ol>
<li>使用 new 关键字（最常用）： ObjectName obj = new ObjectName();</li>
<li>使用反射的Class类的newInstance()方法： ObjectName obj = ObjectName.class.newInstance(); </li>
<li>使用反射的Constructor类的newInstance()方法： ObjectName obj = ObjectName.class.getConstructor.newInstance();</li>
<li>使用对象克隆clone()方法： ObjectName obj = obj.clone(); </li>
<li>使用反序列化（ObjectInputStream）的readObject()方法： try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FILE_NAME))) { ObjectName obj = ois.readObject(); }</li>
</ol>
</blockquote>
<h4 id="12"><a href="#12" class="headerlink" title="12"></a>12</h4><p><strong>（多选）关于Java中的数组，下面的一些描述，哪些描述是准确的：（  ）</strong></p>
<ul>
<li><strong>A：</strong>数组是一个对象，不同类型的数组具有不同的类</li>
<li><strong>B：</strong>数组长度是可以动态调整的</li>
<li><strong>C：</strong>数组是一个连续的存储结构</li>
<li><strong>D：</strong>一个固定长度的数组可类似这样定义: int array[100]</li>
<li><strong>E：</strong>两个数组用equals方法比较时，会逐个便利其中的元素，对每个元素进行比较</li>
<li><strong>F：</strong>可以二维数组，且可以有多维数组，都是在Java中合法的</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：ACF</span></span>

<p><strong>解析：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] i = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] j = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] k = i;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">double</span>[] array_1 = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">100</span>];</span><br><span class="line">        System.out.println(array);</span><br><span class="line">        System.out.println(array_1);</span><br><span class="line">        System.out.println(i.equals(j));</span><br><span class="line">        System.out.println(i.equals(k));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[I@<span class="number">6</span>d6f6e28</span><br><span class="line">[D@<span class="number">135f</span>baa4</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>A 数组是对象，因为可以调用方法，从上面的输出结果可以看出不同类型的数组具有不同的类</p>
<p>B 数组长度是不能动态调整的</p>
<p>C Java中的数组中的数据是连续存储在一块内存中的，所以可以通过下标(即偏移量)的方式访问</p>
<p>D 固定长度的数组定义如上</p>
<p>E 查看源码可以知道数组的equals方法是object的equals，比较的是内存地址，Arrays.equal()可以比较数组元素。</p>
<p>F java可以有多维数组</p>
</blockquote>
<h4 id="13"><a href="#13" class="headerlink" title="13"></a>13</h4><p><strong>以下JAVA程序的运行结果是什么(  )</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Object o1 = <span class="keyword">true</span> ? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">Object o2;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">             o2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">o2 = <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(o1);</span><br><span class="line">System.out.print(<span class="string">" "</span>);         </span><br><span class="line">System.out.print(o2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>1 1</li>
<li><strong>B：</strong>1.0 1.0</li>
<li><strong>C：</strong>1 1.0</li>
<li><strong>D：</strong>1.0 1</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：D</span></span>

<p><strong>解析：</strong></p>
<p>三元操作符类型的转换规则：</p>
<ol>
<li><p>若两个操作数不可转换，则不做转换，返回值为Object类型</p>
</li>
<li><p>若两个操作数是明确类型的表达式（比如变量），则按照正常的二进制数字来转换，int类型转换为long类型，long类型转换为float类型等。</p>
</li>
<li><p>若两个操作数中有一个是数字S,另外一个是表达式，且其类型标示为T，那么，若数字S在T的范围内，则转换为T类型；若S超出了T类型的范围，则T转换为S类型。</p>
</li>
<li><p>若两个操作数都是直接量数字，则返回值类型为范围较大者</p>
</li>
</ol>
</blockquote>
<h4 id="14"><a href="#14" class="headerlink" title="14"></a>14</h4><p><strong>以下关于Object类的说法正确的是（）</strong></p>
<ul>
<li><strong>A：</strong>Java中所有的类都直接或间接继承自Object，无论是否明确的指明，无论其是否是抽象类。</li>
<li><strong>B：</strong>Java中的接口(interface)也继承了Object类</li>
<li><strong>C：</strong>利用“==”比较两个对象时，Java调用继承自Object的equals方法，判断是否相等。</li>
<li><strong>D：</strong>如果类的定义中没有重新定义toString()方法，则该类创建的对象无法使用toStrig()方法。</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p><strong>A：</strong>Object 是基类 Java中的所有的类都直接或间接的继承；所以A对<br><strong>B：</strong>从一个class派生的必然是另一个class。Object是一个class，如果interface继承自Object，那么interface必然是一个class，所以B错<br><strong>C：</strong>利用equals()方法进行比较时 会调用== 可以看equals()方法的源码，可以这样说， == 比equal更加强大，所以C错<br><strong>D：</strong>toString()方法是Object类中 即使不重写也能使用 所以D错</p>
</blockquote>
<h4 id="15"><a href="#15" class="headerlink" title="15"></a>15</h4><p><strong>（多选）Java类Demo中存在方法func0、func1、func2、func3和func4，请问该方法中，哪些是不合法的定义？( )</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">float</span> <span class="title">func0</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　　<span class="keyword">byte</span> i=<span class="number">1</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">float</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　　<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">　　　　<span class="keyword">return</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">float</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　　<span class="keyword">short</span> i=<span class="number">2</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">float</span> <span class="title">func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　　<span class="keyword">long</span> i=<span class="number">3</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">float</span> <span class="title">func4</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　　<span class="keyword">double</span> i=<span class="number">4</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>func1</li>
<li><strong>B：</strong>func2</li>
<li><strong>C：</strong>func3</li>
<li><strong>D：</strong>func4</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：AD</span></span>

<p><strong>解析：</strong></p>
<p>数据类型的转换，分为自动转换和强制转换。自动转换是程序在执行过程中 “ 悄然 ” 进行的转换，不需要用户提前声明，一般是从位数低的类型向位数高的类型转换；强制类型转换则必须在代码中声明，转换顺序不受限制。</p>
<p><strong>自动数据类型转换</strong></p>
<p>自动转换按从低到高的顺序转换。不同类型数据间的优先关系如下：<br>低 ———————————————&gt; 高<br>byte,short,char-&gt; int -&gt; long -&gt; float -&gt; double</p>
<p>运算中，不同类型的数据先转化为同一类型，然后进行运算，转换规则如下：</p>
<table>
<thead>
<tr>
<th><strong>操作数 1</strong> <strong>类型</strong></th>
<th><strong>操作数 2</strong> <strong>类型</strong></th>
<th><strong>转换后的类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td>byte 、 short 、 char</td>
<td>int</td>
<td>int</td>
</tr>
<tr>
<td>byte 、 short 、 char 、 int</td>
<td>long</td>
<td>long</td>
</tr>
<tr>
<td>byte 、 short 、 char 、 int 、 long</td>
<td>float</td>
<td>float</td>
</tr>
<tr>
<td>byte 、 short 、 char 、 int 、 long 、 float</td>
<td>double</td>
<td>double</td>
</tr>
</tbody></table>
<p><strong>强制数据类型转换</strong></p>
<p>强制转换的格式是在需要转型的数据前加上 “( )” ，然后在括号内加入需要转化的数据类型。有的数据经过转型运算后，精度会丢失，而有的会更加精确</p>
</blockquote>
<h4 id="16"><a href="#16" class="headerlink" title="16"></a>16</h4><p><strong>Consider the following code:</strong></p>
<p><strong>String s=null;</strong></p>
<p><strong>Which code fragments cause an object of type NullPointerException to be thrown?</strong></p>
<ul>
<li><strong>A：</strong>if((s!=null)&amp;(s.length()&gt;0))</li>
<li><strong>B：</strong>if((s!=null)&amp;&amp;(s.length()&gt;0))</li>
<li><strong>C：</strong>if((s == null)|(s.length()==0))</li>
<li><strong>D：</strong>if((s == null)||(s.length()==0))</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：AC</span></span>

<p><strong>解析：</strong></p>
<p>s为null，因此只要调用了s.length()都会抛出空指针异常。因此这个题目就是考察if语句的后半部分会不会执行。<br>A：单个与操作的符号&amp; 用在整数上是按位与，用在布尔型变量上跟&amp;&amp;功能类似，但是区别是无论前面是否为真，后面必定执行，因此抛出异常<br>B：与操作，前半部分判断为假，后面不再执行<br>C：这里跟 &amp; 和&amp;&amp; 的区别类似，后面必定执行，因此抛出异常<br>D：或语句，前面为真，整个结果必定为真，后面不执行</p>
</blockquote>
<h4 id="17"><a href="#17" class="headerlink" title="17"></a>17</h4><p><strong>（重要）下面代码的输出是什么？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String baseName = <span class="string">"base"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        callName();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System. out. println(baseName);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String baseName = <span class="string">"sub"</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System. out. println (baseName) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Base b = <span class="keyword">new</span> Sub();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>null</li>
<li><strong>B：</strong>sub</li>
<li><strong>C：</strong>base</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p>1.首先，需要明白<strong>类的加载顺序</strong>。</p>
<p>(1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)</p>
<p>(2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )</p>
<p>(3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )</p>
<p>(4) 父类构造函数</p>
<p>(5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )</p>
<p>(6) 子类构造函数</p>
<p>其中：类中静态块按照声明顺序执行，并且(1)和(2)不需要调用new类实例的时候就执行了(意思就是在类加载到方法区的时候执行的)</p>
<p>2.其次，需要理解子类覆盖父类方法的问题，也就是<strong>方法重写实现多态</strong>问题。</p>
<p>Base b = new Sub();<strong>它为多态的一种表现形式，声明是Base,实现是Sub类，</strong> <strong>理解为</strong> <strong>b</strong> <strong>编译时表现为Base类特性，运行时表现为Sub类特性（这个非常重要）。</strong></p>
<p>当子类覆盖了父类的方法后，意思是父类的方法已经被重写，<strong>题中</strong> <strong>父类初始化调用的方法为子类实现的方法，子类实现的方法中调用的baseName为子类中的私有属性。</strong></p>
<p>由1.可知，此时只执行到步骤4.,子类非静态代码块和初始化步骤还没有到，子类中的baseName还没有被初始化。所以此时 baseName为空。 所以为null。</p>
</blockquote>
<h4 id="19"><a href="#19" class="headerlink" title="19"></a>19</h4><p><strong>设有下面两个赋值语句：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = Integer.parseInt(<span class="string">"1024"</span>);</span><br><span class="line">b = Integer.valueOf(<span class="string">"1024"</span>).intValue();</span><br></pre></td></tr></table></figure>

<p><strong>下述说法正确的是（）</strong></p>
<ul>
<li><strong>A：</strong>a是整数类型变量，b是整数类对象。</li>
<li><strong>B：</strong>a是整数类对象，b是整数类型变量。</li>
<li><strong>C：</strong>a和b都是整数类对象并且它们的值相等。</li>
<li><strong>D：</strong>a和b都是整数类型变量并且它们的值相等。</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：D</span></span>

<p><strong>解析：</strong></p>
<p>intValue()是把Integer对象类型变成int的基础数据类型；<br>parseInt()是把String 变成int的基础数据类型；<br>Valueof()是把String 转化成Integer对象类型；（现在JDK版本支持自动装箱拆箱了。）<br>本题：parseInt得到的是基础数据类型int，valueof得到的是装箱数据类型Integer，然后再通过intValue转换成int，所以选择D</p>
</blockquote>
<h4 id="20"><a href="#20" class="headerlink" title="20"></a>20</h4><p><strong>A 是抽象父类或接口， B ， C 派生自 A ，或实现 A ，现在 Java 源代码中有如下声明：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. A  a0 = <span class="keyword">new</span>  A();</span><br><span class="line"><span class="number">2</span>. A  a1 = <span class="keyword">new</span>  B();</span><br><span class="line"><span class="number">3</span>. A  a2 = <span class="keyword">new</span>  C();</span><br></pre></td></tr></table></figure>

<p><strong>问以下哪个说法是正确的？（ ）</strong></p>
<ul>
<li><strong>A：</strong>第1行不能通过编译</li>
<li><strong>B：</strong>第1、2行能通过编译，但第3行编译出错</li>
<li><strong>C：</strong>第1、2、3行能通过编译，但第2、3行运行时出错</li>
<li><strong>D：</strong>第1行、第2行和第3行的声明都是正确的</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p><strong>抽象类和接口不能实例化了</strong>这个我竟然没注意。。。</p>
</blockquote>
<h4 id="21"><a href="#21" class="headerlink" title="21"></a>21</h4><p><strong>以下代码执行后输出结果为（ ）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Test t1 = <span class="keyword">new</span> Test();</span><br><span class="line">    &#123;</span><br><span class="line">         System.out.println(<span class="string">"blockA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"blockB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Test t2 = <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>blockAblockBblockA</li>
<li><strong>B：</strong>blockAblockAblockB</li>
<li><strong>C</strong>：blockBblockBblockA</li>
<li><strong>D</strong>：blockBblockAblockB</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p>首先区别<clinit>是类初始化，<init>是实例初始化</p>
<p>类装载准备阶段-&gt;类初始化clinit阶段</p>
<p>类装载准备阶段：变量赋系统要求的初始值（0或者null等），final变量会在此时赋用户定义的初始值</p>
<p>类初始化<clinit>过程：</p>
<p>Step1 编译器收集t1的赋值动作，static语句块，main方法语句块</p>
<p>Step2 执行收集好的语句块：</p>
<p>Step2.1 执行t1 = new Test，发现clinit过程已经调用，于是可以开始触发init过程，执行成员变量的初始化（此处没有），以及非静态代码块，输出blockA，最后调用构造函数（此处没有）</p>
<p>Step2.2 按照顺序，执行static语句块，输出blockB</p>
<p>Step2.3 按照顺序，执行main方法语句块，执行t2 = new Test，触发init方法，执行非静态代码块,输出blockA</p>
<p><strong>其实这题很简单，第一你要搞懂，这程序是怎么走的，从上往下。第二你要知道静态块和构造块，静态块是程序走到静态快的位置就自动执行，仅且执行一次，构造块是创建类对象（实例化）操作时就加载一次。最后把题目从上往下执行，遵循第一和第二，就得到答案了。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String word=<span class="string">" "</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWord</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.word=word;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setI</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        Data0bject. i=I;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="22"><a href="#22" class="headerlink" title="22"></a>22</h4><p><strong>创建一个如下方式的DataObject:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataObject object=<span class="keyword">new</span> Data0bject ( );</span><br><span class="line">object. setWord(<span class="string">"123"</span>);</span><br><span class="line">object. setI(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><strong>将此对象序列化为文件，并在另外一个JVM中读取文件，进行反序列化，请问此时读出的Data0bject对象中的word和i的值分别为：</strong></p>
<ul>
<li><strong>A：</strong>“”, 0</li>
<li><strong>B：</strong>“”, 2</li>
<li><strong>C：</strong>“123”, 2</li>
<li><strong>D：</strong>“123”, 0</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：D</span></span>

<p><strong>解析：</strong></p>
<p><strong>Java在序列化时不会实例化static变量和transient修饰的变量，因为static代表类的成员，transient代表对象的临时数据，被声明这两种类型的数据成员不能被序列化。</strong></p>
</blockquote>
<h4 id="23"><a href="#23" class="headerlink" title="23"></a>23</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1=<span class="number">1</span>,b2=<span class="number">2</span>,b3,b6,b8;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span> b4=<span class="number">4</span>,b5=<span class="number">6</span>,b7;</span><br><span class="line">b3=(b1+b2);  <span class="comment">/*语句1*/</span></span><br><span class="line">b6=b4+b5;    <span class="comment">/*语句2*/</span></span><br><span class="line">b8=(b1+b4);  <span class="comment">/*语句3*/</span></span><br><span class="line">b7=(b2+b5);  <span class="comment">/*语句4*/</span></span><br><span class="line">System.out.println(b3+b6);</span><br></pre></td></tr></table></figure>

<p><strong>（多选）下列代码片段中，存在编译错误的语句是()</strong></p>
<ul>
<li><strong>A：</strong>语句2</li>
<li><strong>B：</strong>语句1</li>
<li><strong>C：</strong>语句3</li>
<li><strong>D：</strong>语句4</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：BCD</span></span>

<p><strong>解析：</strong></p>
<p>Java表达式转型规则<strong>由低到高转换</strong>：</p>
<p>1、所有的byte,short,char型的值将被提升为int型；</p>
<p>2、如果有一个操作数是long型，计算结果是long型；</p>
<p>3、如果有一个操作数是float型，计算结果是float型；</p>
<p>4、如果有一个操作数是double型，计算结果是double型；</p>
<p>5、被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。</p>
<hr>
<p>语句1错误：b3=(b1+b2);自动转为int，所以正确写法为b3=(byte)(b1+b2);或者将b3定义为int；</p>
<p>语句2正确：b6=b4+b5;b4、b5为final类型，不会自动提升，所以和的类型视左边变量类型而定，即b6可以是任意数值类型；</p>
<p>语句3错误：b8=(b1+b4);虽然b4不会自动提升，但b1仍会自动提升，所以结果需要强转，b8=(byte)(b1+b4);</p>
<p>语句4错误：b7=(b2+b5); 同上。同时注意b7是<strong>final修饰，即只可赋值一次，便不可再改变</strong>。</p>
</blockquote>
<h4 id="24"><a href="#24" class="headerlink" title="24"></a>24</h4><p><strong>（多选）Java语言中，下面哪个语句是创建数组的正确语句？(     )</strong></p>
<ul>
<li><strong>A：</strong>float f[][] = new float<code>[6][6]</code>;</li>
<li><strong>B：</strong>float []f[] = new float<code>[6][6]</code>;</li>
<li><strong>C：</strong>float f[][] = new float<code>[][6]</code>;</li>
<li><strong>D：</strong>float [][]f = new float<code>[6][6]</code>;</li>
<li><strong>E：</strong>float [][]f = new float<code>[6][]</code>;</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：ABD</span></span>

<p>解析：注意B选项就行，还有就是第一个框中必须有值！！</p>
</blockquote>
<h4 id="25"><a href="#25" class="headerlink" title="25"></a>25</h4><p><strong>（多选）以下类型为Final类型的为（）</strong></p>
<ul>
<li><strong>A：</strong>HashMap</li>
<li><strong>B：</strong>StringBuffer</li>
<li><strong>C：</strong>String</li>
<li><strong>D：</strong>Hashtable</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：BC</span></span>

<p><strong>解析：</strong></p>
<p>StringBuilder , StringBuffer ,String 都是 final 的，但是为什么StringBuilder , StringBuffer可以进行修改呢，因为不可变包括的是，引用不可变以及对象不可变，而这三个都是属于引用不可变，（也就是地址不要变，里面的内容随心所欲），而StringBuilder , StringBuffer 中都包含右append方法，可对对象中的内容进行增加。</p>
<p>而String a=”123”+new String(“456”);实际上底层是用了一个StringBuffer 进行append；</p>
</blockquote>
<h4 id="26"><a href="#26" class="headerlink" title="26"></a>26</h4><p><strong>（多选）Java1.8版本之前的前提，Java特性中,abstract class和interface有什么区别（）</strong></p>
<ul>
<li><strong>A：</strong>抽象类可以有构造方法，接口中不能有构造方法</li>
<li><strong>B：</strong>抽象类中可以有普通成员变量，接口中没有普通成员变量</li>
<li><strong>C：</strong>抽象类中不可以包含静态方法，接口中可以包含静态方法</li>
<li><strong>D：</strong>一个类可以实现多个接口，但只能继承一个抽象类。</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：ABD</span></span>

<p><strong>解析：</strong></p>
<p>A B D显然都是对的。主要说C选项：</p>
<p>在JDK1.8之前的版本（不包括JDK1.8），接口中不能有静态方法，抽象类中因为有普通方法，故也可以有静态方法。</p>
<p>在JDK1.8后（包括JDK1.8），在抽象类中依旧可以有静态方法，同时在接口中也可以定义静态方法了。</p>
<p>以下代码在JDK1.8之后是没有问题的（可以通过接口名来调用静态方法  ：Main.prinf(); ）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS：</p>
<p>在JDK1.7，接口中只包含抽象方法，使用public abstract  修饰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在JDK1.8，接口中新加了默认方法和静态方法：</strong></p>
<p>​        默认方法：使用default修饰，在接口的实现类中，可以直接调用该方法，也可以重写该方法。</p>
<p>​        静态方法：使用static修饰，通过接口直接调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;    </span><br><span class="line">    <span class="comment">//默认方法    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">"default method..."</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//静态方法    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">"static method..."</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在JDK1.9，接口中新加了私有方法，使用private修饰，私有方法供接口内的默认方法和静态方法调用。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="27"><a href="#27" class="headerlink" title="27"></a>27</h4><p><strong>（）运算符把其操作数中所有值为0和所有值为1的位分别在结果的相应中设置1和0</strong></p>
<ul>
<li><strong>A：</strong>&amp;</li>
<li><strong>B：</strong>|</li>
<li><strong>C：</strong>！</li>
<li><strong>D：</strong>~</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：D</span></span>

<p><strong>解析：</strong></p>
<p><del>是<a href="https://www.baidu.com/s?wd=位运算符&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">位运算符</a>，意义是 按位非（NOT）<br>按位非也叫做补，<a href="https://www.baidu.com/s?wd=一元运算符&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">一元运算符</a>NOT“</del>”是对其运算数的每一位取反。</p>
<ul>
<li>仅用于整数值</li>
<li>反转位，即0位变为1位，1变成0</li>
<li>在所有情况下〜x等于（-x）- 1</li>
</ul>
<p>例如</p>
<figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="number">0111</span> (<span class="number">7</span>) <span class="built_in">=</span> <span class="number">1000</span> (<span class="number">8</span>)</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="28"><a href="#28" class="headerlink" title="28"></a>28</h4><p><strong>Java 源程序文件的扩展名为（）</strong></p>
<ul>
<li><strong>A：</strong>.java</li>
<li><strong>B：</strong>.class</li>
<li><strong>C：</strong>.exe</li>
<li><strong>D：</strong>.jar</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p>java中源文件的后缀为.java，经过javac.exe编译后生成字节码文件，后缀为.class，再经过java.exe编译为可执行文件，后缀为.exe。</p>
</blockquote>
<h4 id="29"><a href="#29" class="headerlink" title="29"></a>29</h4><p><strong>下列程序的运行结果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCustomerInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// do something that may cause an Exception</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.FileNotFoundException ex) &#123;</span><br><span class="line">            System.out.print(<span class="string">"FileNotFoundException!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException ex) &#123;</span><br><span class="line">            System.out.print(<span class="string">"IOException!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.lang.Exception ex) &#123;</span><br><span class="line">            System.out.print(<span class="string">"Exception!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>IOException!</li>
<li><strong>B：</strong>IOException!Exception!</li>
<li><strong>C：</strong>FileNotFoundException!IOException!</li>
<li><strong>D：</strong>FileNotFoundException!IOException!Exception!</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<h4 id="try-catch-finally-规则"><a href="#try-catch-finally-规则" class="headerlink" title="try-catch-finally 规则"></a><strong>try-catch-finally 规则</strong></h4><p>1)  必须在 try 之后添加 catch 或 finally 块。try 块后可同时接 catch 和 finally 块，但至少有一个块。</p>
<p>2) 必须遵循块顺序：若代码同时使用 catch 和 finally 块，则必须将 catch 块放在 try 块之后。<br>3) catch 块与相应的异常类的类型相关。<br>4) 一个 try 块可能有多个 catch 块。若如此，则执行第一个匹配块。即Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或 其子类的实例，就执行这个catch代码块，不会再执行其他的 catch代码块<br>5) 可嵌套 try-catch-finally 结构。<br>6) 在 try-catch-finally 结构中，可重新抛出异常。<br>由此可以看出，<strong>catch只会匹配一个，因为只要匹配了一个，虚拟机就会使整个语句退出</strong></p>
</blockquote>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h4 id="30"><a href="#30" class="headerlink" title="30"></a>30</h4><p><strong>（多选）下面有关java threadlocal说法正确的有？</strong></p>
<ul>
<li><strong>A：</strong>ThreadLocal存放的值是线程封闭，线程间互斥的，主要用于线程内共享一些数据，避免通过参数来传递</li>
<li><strong>B：</strong>线程的角度看，每个线程都保持一个对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收</li>
<li><strong>C：</strong>在Thread类中有一个Map，用于存储每一个线程的变量的副本。</li>
<li><strong>D：</strong>对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：ABCD</span></span>

<p><strong>解析：</strong></p>
<p><strong>ThreadLocal类用来提供线程内部的局部变量。</strong>这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。 可以总结为一句话：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 <strong>ThreadLocal设计的初衷：提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。</strong></p>
</blockquote>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h4 id="31"><a href="#31" class="headerlink" title="31"></a>31</h4><p><strong>（多选）下面的类哪些可以处理Unicode字符?</strong></p>
<ul>
<li><strong>A：</strong>InputStreamReader</li>
<li><strong>B：</strong>BufferedReader</li>
<li><strong>C：</strong>Writer</li>
<li><strong>D：</strong>PipedInputStream</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：ABC</span></span>

<p><strong>解析：</strong></p>
<p>后缀是Stream的都是字节流，其他的都是字符流。</p>
</blockquote>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h4 id="32"><a href="#32" class="headerlink" title="32"></a>32</h4><p><strong>下面程序段的时间复杂度是（）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>( k &lt; n )&#123;</span><br><span class="line">   i ++ ;</span><br><span class="line">k += i ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>O(n)</li>
<li><strong>B：</strong>O(n^1/2)</li>
<li><strong>C：</strong>O(n*i)</li>
<li><strong>D：</strong>O(n+i)</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：B</span></span>

<p><strong>解析：</strong></p>
<p>设q为一共要执行的次数 </p>
<p>k=0+1; k=1+1</p>
<p>q ^ 2+q+1/4=2n+1/4</p>
<p>(q+1/2)=(2n+1/4) ^ 1/2</p>
<p>q=(2n+1/4)^1/2-1/2</p>
<p>所以 T(n)=O(n^1/2)</p>
</blockquote>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h4 id="33"><a href="#33" class="headerlink" title="33"></a>33</h4><p><strong>运用下列哪个命令能够获取JVM的内存映像</strong></p>
<ul>
<li><strong>A：</strong>jinfo</li>
<li><strong>B：</strong>jmap</li>
<li><strong>C：</strong>jhat</li>
<li><strong>D：</strong>jstat</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：B</span></span>

<p><strong>解析：</strong></p>
<ol>
<li><p>jps：查看本机java进程信息。</p>
</li>
<li><p>jstack：打印线程栈信息，制作线程dump文件。</p>
</li>
<li><p>jmap：打印内存映射，制作<strong>堆</strong>dump文件</p>
</li>
<li><p>jstat：性能监控工具。</p>
</li>
<li><p>jhat：内存分析工具</p>
</li>
<li><p>jconsole：简易的可视化控制台</p>
</li>
<li><p>jvisualvm：功能强大的控制台</p>
</li>
<li><p>jinfo<br>如何查看当前运行程序的配置<br>jps -l查看当前所有的进程及进程号<br>方式一：jinfo -flag 配置项 进程号<br>方式二：jinfo -flags 进程号（可查看所有配置项，包括系统默认的和人工自己配置的）</p>
</li>
</ol>
</blockquote>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">褚超亮</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.cclblog.cn/2020/06/29/java/question/2/">https://www.cclblog.cn/2020/06/29/java/question/2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.cclblog.cn" target="_blank">琦玉老师</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/%E9%A2%98%E9%9B%86/">题集</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/06/29/java/javase/17/"><img class="prev_cover" src="[&quot;https://image.cclblog.cn/a3bd9cb49cbd3ffa4c9e178577b6dffe.jpg&quot;]" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">抽象类VS接口</div></div></a></div><div class="next-post pull_right"><a href="/2020/06/28/java/theme/design_mode/"><img class="next_cover" src="https://image.cclblog.cn/blog/20200628163855.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">设计模式</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/06/22/java/question/1/" title="题集（第一周）"><img class="relatedPosts_cover" src="https://image.cclblog.cn/a3bd9cb49cbd3ffa4c9e178577b6dffe.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-22</div><div class="relatedPosts_title">题集（第一周）</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/22/java/theme/question/" title="Java基础习题整理"><img class="relatedPosts_cover" src="https://image.cclblog.cn/blog/20200622085700.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-22</div><div class="relatedPosts_title">Java基础习题整理</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/09/java/designMode/SingletonPattern/" title="单例模式"><img class="relatedPosts_cover" src="https://image.cclblog.cn/a3bd9cb49cbd3ffa4c9e178577b6dffe.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-09</div><div class="relatedPosts_title">单例模式</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/16/java/javase/1/" title="重载与重写规则"><img class="relatedPosts_cover" src="https://image.cclblog.cn/a3bd9cb49cbd3ffa4c9e178577b6dffe.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-16</div><div class="relatedPosts_title">重载与重写规则</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/21/java/javase/15/" title="成员变量与局部变量"><img class="relatedPosts_cover" src="https://image.cclblog.cn/a3bd9cb49cbd3ffa4c9e178577b6dffe.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-21</div><div class="relatedPosts_title">成员变量与局部变量</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/29/java/javase/17/" title="抽象类VS接口"><img class="relatedPosts_cover" src="https://image.cclblog.cn/a3bd9cb49cbd3ffa4c9e178577b6dffe.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-29</div><div class="relatedPosts_title">抽象类VS接口</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 褚超亮</div><div class="footer_custom_text"><a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank" rel="noopener"><img style="width:60px;" src="/img/logo.png" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>冀ICP备19034261号-2</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>