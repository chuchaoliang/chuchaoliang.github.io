<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>题集（第一周） | 琦玉老师</title><meta name="description" content="2020-06-22 第一周"><meta name="keywords" content="JAVA,题集"><meta name="author" content="褚超亮"><meta name="copyright" content="褚超亮"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="题集（第一周）"><meta name="twitter:description" content="2020-06-22 第一周"><meta name="twitter:image" content="https://www.cclblog.cn/img/avatar.png"><meta property="og:type" content="article"><meta property="og:title" content="题集（第一周）"><meta property="og:url" content="https://www.cclblog.cn/2020/06/22/java/question/1/"><meta property="og:site_name" content="琦玉老师"><meta property="og:description" content="2020-06-22 第一周"><meta property="og:image" content="https://www.cclblog.cn/img/avatar.png"><meta property="article:published_time" content="2020-06-22T02:00:52.000Z"><meta property="article:modified_time" content="2020-06-23T08:20:46.608Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://www.cclblog.cn/2020/06/22/java/question/1/"><link rel="prev" title="数组题集" href="https://www.cclblog.cn/2020/06/23/java/arithmetic/1/"><link rel="next" title="java习题整理" href="https://www.cclblog.cn/2020/06/22/java/theme/question/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"top-center"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">7</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1"><span class="toc-text">1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#jvm"><span class="toc-text">jvm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础"><span class="toc-text">基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计算机基础"><span class="toc-text">计算机基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合"><span class="toc-text">集合</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://image.cclblog.cn/a3bd9cb49cbd3ffa4c9e178577b6dffe.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">琦玉老师</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">题集（第一周）</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-22 10:00:52"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-06-22</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-06-23 16:20:46"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-23</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JAVA/">JAVA</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JAVA/%E9%A2%98%E9%9B%86/">题集</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">7.5k</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><h2 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h2><p><strong>对于JVM内存配置参数：</strong></p>
<blockquote>
<p><strong>-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3</strong></p>
</blockquote>
<p><strong>,其最小内存值和Survivor区总大小分别是（）</strong></p>
<ul>
<li><strong>A：</strong>5120m，1024m</li>
<li><strong>B：</strong>5120m，2048m</li>
<li><strong>C：</strong>10240m，1024m</li>
<li><strong>D：</strong>10240m，2048m</li>
</ul>
<blockquote>
<p><strong>解析：</strong></p>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：D</span></span>

<p>-Xmx：最大堆大小</p>
<p>-Xms：初始堆大小</p>
<p>-Xmn:年轻代大小</p>
<p>-XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值</p>
<p>年轻代5120m， Eden：Survivor=3，Survivor区大小=1024m（Survivor区有两个，即将年轻代分为5份，每个Survivor区占一份），总大小为2048m。</p>
<p>-Xms初始堆大小即最小内存值为10240m</p>
</blockquote>
<p><strong>（多选）关于OutOfMemoryError，下面说法正确的是（）？</strong></p>
<ul>
<li>java.lang.OutOfMemoryError: PermGen space 增加-XX:MaxPermSize这个参数的值的话，这个问题通常会得到解决。</li>
<li>java.lang.OutOfMemoryError: Requested array size exceeds VM limit当你正准备创建一个超过虚拟机允许的大小的数组时，这条错误将会出现</li>
<li>java.lang.OutOfMemoryError: Java heap space 一般情况下解决这个问题最快的方法就是通过-Xmx参数来增加堆的大小</li>
<li>java.lang.OutOfMemoryError: nativeGetNewTLA这个异常只有在jRockit虚拟机时才会碰到</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：ABC</span></span>

<p><strong>解析：</strong></p>
<p>A：属于运行时常量池导致的溢出，设置-XX：MaxPermSize可以解决这个问题，</p>
<p>B：属于堆空间不足导致的错误，解决方式和C相同，</p>
<p>C：属于java堆内存问题，一般的手段是通过内存映像分析工具，对Dump出来的堆转储存快照进行分析，重点是确认内存中的对象是否是有必要的，也就是要判断是出现了内存泄漏，还是出现了内存溢出。如果是内存泄露，通过工具检查泄露对象打GC Roots的引用链信息，可以准确的确定出泄露代码的位置，不存在泄露，就应该检查虚拟机的堆参数，如果可以继续调大，可以设置-Xmx解决问题</p>
<p>D：java.lang.OutOfMemoryError: nativeGetNewTLA指当虚拟机不能分配新的线程本地空间(Thread Local Area）的时候错误信息，此错误是线程申请一个新的TLA时产生的，这个异常一般只会发生在jRockit虚拟机，只有过于绝对。</p>
</blockquote>
<p><strong>下面有关java classloader说法错误的是（）?</strong></p>
<ul>
<li><strong>A：</strong> Java默认提供的三个ClassLoader是BootStrap ClassLoader，Extension ClassLoader，App ClassLoader、</li>
<li><strong>B：</strong>ClassLoader使用的是双亲委托模型来搜索类的</li>
<li><strong>C：</strong>VM在判定两个class是否相同时，只用判断类名相同即可，和类加载器无关</li>
<li><strong>D：</strong>ClassLoader就是用来动态加载class文件到内存当中用的</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：C</span></span>

<p><strong>解析：</strong></p>
<p>比较两个类是否相等，只有这两个类是由同一个类加载器加载才有意义。否则，即使这两个类是来源于同一个Class文件，只要加载它们的类加载器不同，那么这两个类必定不相等。</p>
<p>补充：</p>
<p><strong>1.</strong> <strong>什么是类加载器？</strong></p>
<p>把类加载的过程放到Java虚拟机外部去实现，让应用程序决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。  </p>
<p><strong>2.</strong> <strong>有哪些类加载器，分别加载哪些类</strong></p>
<p>类加载器按照层次，从顶层到底层，分为以下三种：<br>(1)启动类加载器 : 它用来加载 Java 的核心库，比如String、System这些类<br>(2)扩展类加载器 : 它用来加载 Java 的扩展库。</p>
<p>(3) 应用程序类加载器 : 负责加载用户类路径上所指定的类库，一般来说，Java 应用的类都是由它来完成加载的。</p>
<p><strong>3.</strong> <strong>双亲委派模型</strong></p>
<p>我们应用程序都是由以上三种类加载器互相配合进行加载的，还可以加入自己定义的类加载器。称为 <strong>类加载器的双亲委派模型</strong> ，这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用 <strong>组合关系</strong> 来复用父加载器的。</p>
<p><strong>4.</strong> <strong>双亲委托模型的工作原理</strong></p>
<p>是当一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法加载这个加载请求的时候，子加载器才会尝试自己去加载。</p>
<p><strong>5.</strong> <strong>使用双亲委派模型好处？（原因）</strong></p>
<p>第一：可以避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载。</p>
<p>第二：考虑到安全因素，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时被加载，所以用户自定义类是无法加载一个自定义的类装载器。</p>
</blockquote>
<p><strong>（多选）关于Java中的ClassLoader下面的哪些描述是错误的：(   )</strong></p>
<ul>
<li><strong>A：</strong>默认情况下，Java应用启动过程涉及三个ClassLoader: Boostrap, Extension, System</li>
<li><strong>B：</strong>一般的情况不同ClassLoader装载的类是不相同的，但接口类例外，对于同一接口所有类装载器装载所获得的类是相同的</li>
<li><strong>C：</strong>类装载器需要保证类装载过程的线程安全</li>
<li><strong>D：</strong>ClassLoader的loadClass在装载一个类时，如果该类不存在它将返回null</li>
<li><strong>E：</strong>ClassLoader的父子结构中，默认装载采用了父优先</li>
<li><strong>F：</strong>所有ClassLoader装载的类都来自CLASSPATH环境指定的路径</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：BDF</span></span>

<p><strong>解析：</strong></p>
<p><strong>A.Java系统提供3种类加载器：启动类加载器（Bootstrap ClassLoader）  扩展类加载器（Extension ClassLoader） 应用程序类加载器（Application ClassLoader）. A正确</strong></p>
<p><strong>B.《深入理解Java虚拟机》P228：对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类必定不相等。</strong>接口类是一种特殊类，因此对于同一接口不同的类装载器装载所获得的类是不相同的。<strong>B错误</strong></p>
<p><strong>C.类只需加载一次就行，因此要保证类加载过程线程安全，防止类加载多次。C正确</strong></p>
<p><strong>D.</strong> <strong>Java程序的类加载器采用双亲委派模型，实现双亲委派的代码集中在java.lang.ClassLoader的loadClass()方法中，此方法实现的大致逻辑是：先检查是否已经被加载，若没有加载则调用父类加载器的loadClass()方法，若父类加载器为空则默认使用启动类加载器作为父类加载器。如果父类加载失败，抛出ClassNotFoundException异常。D错误</strong></p>
<p><strong>E.双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。E正确</strong></p>
<p><strong>F.应用程序类加载器（Application ClassLoader）负责加载</strong>用户类路径（ClassPath）上所指定的类库，不是所有的ClassLoader都加载此路径。F错误</p>
</blockquote>
<p><strong>以下代码执行的结果显示是多少（）？</strong></p>
<ul>
<li><strong>A：</strong>505000</li>
<li><strong>B：</strong>0</li>
<li><strong>C：</strong>运行时错误</li>
<li><strong>D：</strong>5050</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：B</span></span>

<p><strong>解析：</strong></p>
<p>count = count++  原理是 temp = count； count = count+1 ； count = temp；   因此count始终是0 这仅限于java 与c是不一样的</p>
<p>count=count++就是先把局部变量表中count的值0放入操作数栈中，然后直接对局部变量表中的count加1，然后再把操作数栈中的0出栈赋值给局部变量表中的count，最终局部变量表中的count值仍为0</p>
</blockquote>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><strong>（多选）有关静态初始化块说法正确的是？</strong></p>
<ul>
<li><strong>A：</strong>无法直接调用静态初始化块</li>
<li><strong>B：</strong>在创建第一个实例前或引用任何静态成员之前，将自动调用静态初始化块来初始化</li>
<li><strong>C：</strong>静态初始化块既没有访问修饰符，也没有参数</li>
<li><strong>D：</strong>在程序中，用户可以控制合适执行静态初始化块</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：ABC</span></span>

<p><strong>解析：</strong></p>
<p><strong>java对象初始化顺序</strong><br>先说结论：</p>
<ol>
<li>父类静态代码块，父类静态成员变量（同级，按代码顺序执行）</li>
<li>子类静态代码块，子类静态成员变量（同级，按代码顺序执行）</li>
<li>父类普通代码块，父类普通成员变量（同级，按代码顺序执行）</li>
<li>父类构造方法</li>
<li>子类普通代码块，子类普通成员变量（同级，按代码顺序执行）</li>
<li>子类构造方法</li>
</ol>
<p>注意点：</p>
<ol>
<li>静态内容只在类加载时执行一次，之后不再执行。</li>
<li>默认调用父类的无参构造方法，可以在子类构造方法中利用super指定调用父类的哪个构造方法。</li>
</ol>
</blockquote>
<p><strong>执行如下程序代码</strong></p>
<p>char chr = 127;</p>
<p>int sum = 200;</p>
<p>chr += 1;</p>
<p>sum += chr;</p>
<p>后，sum的值是   ; （     ）</p>
<p>备注：同时考虑c/c++和Java的情况的话</p>
<ul>
<li><strong>A：</strong>72</li>
<li><strong>B：</strong>99</li>
<li><strong>C：</strong>328</li>
<li><strong>D：</strong>327</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：D</span></span> 

<p><strong>解析：</strong></p>
<p>java中只有byte, boolean是一个字节, char是两个字节, 所以对于java来说127不会发生溢出, 输出328</p>
<p>但是对于c/c++语言来说, char是一个字节, 会发生溢出, 对127加一发生溢出,  0111 1111 –&gt; 1000 0000, 1000 0000为补码-128, 所以结果为200-128=72</p>
</blockquote>
<p><strong>下列关于包（package）的描述，正确的是（）</strong></p>
<ul>
<li><strong>A：</strong>包（package）是Java中描述操作系统对多个源代码文件组织的一种方式。</li>
<li><strong>B：</strong>import语句将所对应的Java源文件拷贝到此处执行。</li>
<li><strong>C：</strong>包（package）是Eclipse组织Java项目特有的一种方式。</li>
<li><strong>D：</strong>定义在同一个包（package）内的类可以不经过import而直接相互使用。</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：D</span></span>        

<p><strong>解析：</strong></p>
<p>1、为了更好地组织类，Java提供了包机制。包是类的容器，用于分隔类名空间。如果没有指定包名，所有的示例都属于一个默认的无名包。Java中的包一般均包含相关的类，java是跨平台的，所以java中的包和操作系统没有任何关系，java的包是用来组织文件的一种虚拟文件系统。A错</p>
<p>2、import语句并没有将对应的java源文件拷贝到此处仅仅是引入，告诉编译器有使用外部文件，编译的时候要去读取这个外部文件。B错<br>3、Java提供的包机制与IDE没有关系。C错<br>4、定义在同一个包（package）内的类可以不经过import而直接相互使用。        </p>
</blockquote>
<p><strong>（多选）哪个是不正确的字符常量？</strong></p>
<ul>
<li><strong>A：</strong>”\n”</li>
<li><strong>B：</strong>”1”</li>
<li><strong>C：</strong>”a”</li>
<li><strong>D：</strong>”\101”</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：ABCD</span></span>

<p>解析：文字游戏注意是<strong>字符常量（’’）</strong>而不是<strong>字符串常量（””）</strong></p>
</blockquote>
<p><strong>（多选）以下关于JAVA语言异常处理描述正确的有？</strong></p>
<ul>
<li><strong>A：</strong>throw关键字可以在方法上声明该方法要抛出的异常。</li>
<li><strong>B：</strong>throws用于抛出异常对象。</li>
<li><strong>C：</strong>try是用于检测被包住的语句块是否出现异常，如果有异常，则抛出异常，并执行catch语句。</li>
<li><strong>D：</strong>finally语句块是不管有没有出现异常都要执行的内容。<br>在try块中不可以抛出异常</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：CD</span></span>

<p><strong>解析：</strong></p>
<p>Java语言中的异常处理包括声明异常、抛出异常、捕获异常和处理异常四个环节。</p>
<ul>
<li><p>throws关键字可以在方法上声明该方法要抛出的异常，然后在方法内部通过throw抛出异常对象。<strong>A选项应该为throws B选项应该为throw</strong>。</p>
</li>
<li><p>C选项不严谨，这个异常不是用try抛出来的，而是用了try能检测到底层抛出的异常，然后进行处理。这里应该用“<strong>捕获</strong>”这个异常才对。</p>
<p>这个“如果有异常，则抛出异常”。在捕获异常的时候使用throw，才会抛出这个异常，否则只是捕获到，而不是抛出。这个是需要显式写出来的。</p>
<p>但是答案中存在，忽略这个细节。AB错误太明显。</p>
</li>
</ul>
</blockquote>
<p><strong>下列语句正确的是：</strong></p>
<ul>
<li><strong>A：</strong>形式参数可被字段修饰符修饰</li>
<li><strong>B：</strong>形式参数不可以是对象</li>
<li><strong>C：</strong>形式参数为方法被调用时真正被传递的参数</li>
<li><strong>D：</strong>形式参数可被视为local variable</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：D</span></span>

<p><strong>解析：</strong></p>
<p><img src="https://image.cclblog.cn/blog/20200623100219.png" alt=""></p>
</blockquote>
<p><strong>关于C++/JAVA类中static 成员和对象成员的说法正确的是？</strong></p>
<ul>
<li><strong>A：</strong>static 成员变量在对象构造时生成</li>
<li><strong>B：</strong>static 成员函数在对象成员函数中无法调用</li>
<li><strong>C：</strong>虚成员函数不可能是static 成员函数</li>
<li><strong>D：</strong>static 成员函数不能访问static 成员变量</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：C</span></span>

<p><strong>解析：</strong></p>
<ul>
<li>static为成员变量或函数，在类初始化是加载完成，可以被成员函数调用或访问</li>
<li>static成员函数既可以通过类名直接调用，也可以通过对象名进行调用</li>
<li>虚函数是C++中的，虚函数不可能是static的</li>
<li>static成员函数可以访问static成员变量</li>
</ul>
</blockquote>
<p><strong>给定以下JAVA代码，这段代码运行后输出的结果是（）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aMethod</span><span class="params">(<span class="keyword">int</span> i)</span><span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"exception in a Method"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">"finally"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            aMethod(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.printf(<span class="string">"exception in main"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>exception in main finished</li>
<li><strong>B：</strong>finally finished</li>
<li><strong>C：</strong>exception in main finally</li>
<li><strong>D：</strong>finally exception in main finished</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：B</span></span>

<p><strong>解析：</strong></p>
<p>题目中是i/10 不是 10/i 绝对不会报异常</p>
<p>1、finally块一定会执行，无论是否try…catch。</p>
<p>2、finally前有return，会先执行return语句，并保存下来，再执行finally块，最后return。</p>
<p>3、finally前有return、finally块中也有return，先执行前面的return，保存下来，再执行finally的return，覆盖之前的结果，并返回。</p>
</blockquote>
<p><strong>What is the result?</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.print(c);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] argv )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( foo(<span class="string">'A'</span>); foo(<span class="string">'B'</span>) &amp;&amp; (i &lt; <span class="number">2</span>); foo(<span class="string">'C'</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            i++ ;</span><br><span class="line">            foo(<span class="string">'D'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>ABDCBDCB</li>
<li><strong>B：</strong>ABCDABCD</li>
<li><strong>C：</strong>Compilation fails.</li>
<li><strong>D：</strong>An exception is thrown at runtime.</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p>for(条件1;条件2;条件3) {</p>
<p>​    //语句</p>
<p>}</p>
<p>执行顺序是条件1-&gt;条件2-&gt;语句-&gt;条件3-&gt;条件2-&gt;语句-&gt;条件3-&gt;条件2……..</p>
<p>如果条件2为true，则一直执行。如果条件2位false，则for循环结束21. </p>
</blockquote>
<p><strong>Which lines of the following will produce an error?</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="keyword">byte</span> a1 = <span class="number">2</span>, a2 = <span class="number">4</span>, a3;</span><br><span class="line"><span class="number">2</span>. <span class="keyword">short</span> s = <span class="number">16</span>;</span><br><span class="line"><span class="number">3</span>. a2 = s;</span><br><span class="line"><span class="number">4</span>. a3 = a1 * a2;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>Line 3 and Line 4</li>
<li><strong>B：</strong>Line 1 only</li>
<li><strong>C：</strong>Line 3 only</li>
<li><strong>D：</strong>Line 4 only</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p>short类型转为byte类型出错</p>
<p>a1*a2结果为int类型，转为byte类型出错</p>
<p><strong>java中如果碰到char、byte和short参与运算时，会自动将这些值转换为int类型然后再进行运算。这里a1和a2就自动转为int类型了，结果也为Int类型。把一个int类型赋值给byte需要转型。</strong></p>
</blockquote>
<p><strong>What is displayed when the following is executed;</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1=-<span class="number">0.5</span>;</span><br><span class="line">System.out.println(<span class="string">"Ceil d1="</span>+Math.ceil(d1));</span><br><span class="line">System.out.println(<span class="string">"floor d1="</span>+Math.floor(d1));</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>Ceil d1=-0.0<br>floor d1=-1.0</li>
<li><strong>B：</strong>Ceil d1=0.0<br>floor d1=-1.0</li>
<li><strong>C：</strong>Ceil d1=-0.0<br>floor d1=-0.0</li>
<li><strong>D：</strong>Ceil d1=0.0<br>floor d1=0.0</li>
<li><strong>E：</strong>Ceil d1=0<br>floor d1=-1</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p><strong>ceil：天花板数，向上取整。</strong></p>
<p><strong>floor：地板数，向下取整</strong></p>
<p>这里主要是有一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Math.ceil(d1) `</span><br></pre></td></tr></table></figure>

<p>ceil 方法上有这么一段注释：If the argument value is less than zero but greater than -1.0, then the result is negative zero</p>
<p>如果参数小于0且大于-1.0，结果为 -0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Math.floor(d1)`</span><br></pre></td></tr></table></figure>

<p>ceil 和 floor 方法 上都有一句话：If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as  the argument，意思为：如果参数是 NaN、无穷、正 0、负 0，那么结果与参数相同，</p>
<p>如果是 -0.0，那么其结果是 -0.0</p>
</blockquote>
<p><strong>java中将ISO8859-1字符串转成GB2312编码，语句为 ？</strong>  </p>
<ul>
<li><strong>A：</strong>new String(“ISO8859-1”.getBytes(“ISO8859-1”),”GB2312”)</li>
<li><strong>B：</strong>new String(String.getBytes(“GB2312”）, ISO8859-1)</li>
<li><strong>C：</strong>new String(String.getBytes(“ISO8859-1”))</li>
<li><strong>D：</strong>new String(String.getBytes(“GB2312”))</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p>注意这里”ISO8859-1”是一个普通字符串，不要被迷惑了</p>
<p>new String(“这是要转换的字符串”.getBytes(“ISO-8859-1”), “GB2312”);</p>
</blockquote>
<p><strong>（多选）已知String a=”a”,String b=”b”,String c=a+b,String d=new String(“ab”) 以下操作结果为true的是</strong></p>
<ul>
<li><strong>A：</strong>(a+b).equals(c)</li>
<li><strong>B：</strong>a+b==c</li>
<li><strong>C：</strong>c==d</li>
<li><strong>D：</strong>c.equals(d)</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：AD</span></span>

<p><strong>解析：</strong></p>
<p>1.== 和 equals():</p>
<p>(1)“==” 用于比较基本数据类型时比较的是值，用于比较引用类型时比较的是引用指向的地址。</p>
<p>(2)Object 中的equals() 与 “==” 的作用相同，但String类重写了equals()方法，比较的是对象中的内容。</p>
<p>2.String对象的两种创建方式:</p>
<p>(1)第一种方式: String str1 = “aaa”;  是在常量池中获取对象(“aaa” 属于字符串字面量，因此编译时期会在常量池中创建一个字符串对象，如果常量池中已经存在该字符串对象则直接引用)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>3.String类型的常量池比较特殊。它的主要使用方法有两种</p>
<p>(1)直接使用双引号声明出来的String对象会直接存储在常量池中。</p>
<p>(2)如果不是用双引号声明的String对象,可以使用 String 提供的 intern 方法。 String.intern() 是一个 Native 方法，它的作用是： 如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用； 如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"AAA"</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 = <span class="string">"AAA"</span>;</span><br><span class="line">System.out.println(s2);<span class="comment">//AAA</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false，因为一个是堆内存中的String对象一个是常量池中的String对象，</span></span><br><span class="line">System.out.println(s2 == s3);<span class="comment">//true， s1,s2指向常量池中的”AAA“</span></span><br></pre></td></tr></table></figure>

<p>4字符串拼接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"a"</span>;</span><br><span class="line">String b = <span class="string">"b"</span>;</span><br><span class="line">  </span><br><span class="line">String str1 = <span class="string">"a"</span> + <span class="string">"b"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">String str2 = a + b; <span class="comment">//在堆上创建的新的对象     </span></span><br><span class="line">String str3 = <span class="string">"ab"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//true </span></span><br><span class="line">System.out.println(str2 == str3);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>对于java类型变量char c,short s,float f,double d,表达式c*s+f+d的结果类型为（）</strong></p>
<ul>
<li><strong>A：</strong>float</li>
<li><strong>B：</strong>char</li>
<li><strong>C：</strong>short</li>
<li><strong>D：</strong>double</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：D</span></span>

<p><strong>解析：</strong></p>
<p><strong>基本数据类型的运算，会自动向上转型。boolean不可以和其他基本数据类型相互转换。</strong></p>
<p><strong>byte-&gt;short,char -&gt; int -&gt; long</strong>      </p>
<p><strong>float -&gt; double</strong></p>
<p><strong>int -&gt; float</strong></p>
<p><strong>long -&gt; double</strong></p>
<p><img src="https://image.cclblog.cn/blog/20200622161949.png" alt=""></p>
</blockquote>
<p><strong>在运行时，由java解释器自动引入，而不用import语句引入的包是()。</strong></p>
<ul>
<li><strong>A：</strong>java.lang</li>
<li><strong>B：</strong>java.system</li>
<li><strong>C：</strong>java.io</li>
<li><strong>D：</strong>java.util</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p>java.lang包是java语言的核心包，lang是language的缩写</p>
<p>java.lang包定义了一些基本的类型，包括Integer,String之类的，是java程序必备的包，有解释器自动引入，无需手动导入</p>
</blockquote>
<p><strong>由3 个“1”和 5 个“0”组成的 8 位二进制补码，能表示的最小整数（）</strong></p>
<ul>
<li><strong>A：</strong>-126</li>
<li><strong>B：</strong>-125</li>
<li><strong>C：</strong>-32</li>
<li><strong>D：</strong>-3</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：B</span></span>

<p><strong>解析：</strong></p>
<p>既然求最小整数，那肯定先想到负数，则最高位（符号位）一定为1，原码中肯定是1所在的位数越高，值越小，而补码是由原码取反加1（符号位不变）得到的，则在补码中1所在的位数一定要越低，即补码为1000 0011；由补码求得原码：1111 1101=-(64+32+16+8+4+1)=-125;</p>
</blockquote>
<p><strong>关于访问权限，说法正确的是？ ( )</strong></p>
<ul>
<li><strong>A：</strong>类A和类B在同一包中，类B有个protected的方法testB，类A不是类B的子类（或子类的子类），类A可以访问类B的方法testB</li>
<li><strong>B：</strong>类A和类B在同一包中，类B有个protected的方法testB，类A不是类B的子类（或子类的子类），类A不可以访问类B的方法testB</li>
<li><strong>C：</strong>访问权限大小范围：public &gt; 包权限 &gt; protected &gt; private</li>
<li><strong>D：</strong>访问权限大小范围：public &gt; 包权限 &gt; private &gt; protected</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p><img src="https://image.cclblog.cn/blog/20200622110227.jpg" alt=""></p>
</blockquote>
<p><strong>以下程序程序运行后的输出结果是（）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">12</span>,n=<span class="number">34</span>;</span><br><span class="line">    System.out.printf(<span class="string">"%d%d"</span>,m++,++n);</span><br><span class="line">    System.out.printf(<span class="string">"%d%d\n"</span>,n++,++m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>12353514</li>
<li><strong>B：</strong>12353513</li>
<li><strong>C：</strong>12343514</li>
<li><strong>D：</strong>12343513</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p><strong>不要忘记前面已经自加过后，变量的值已经改变了（明白了这个肯定就没问题了）</strong></p>
<p>​          第一个输出：m++值：12，m的值：13</p>
<p>​                              ++n值：35，n的值：35</p>
<p>​          第一个输出：n++值：35，n的值：36</p>
<p>​                              ++m值：14，n的值：14</p>
<p>​          故最终输出：12353514</p>
</blockquote>
<p><strong>在jdk1.8之前，下列哪一种叙述是正确的（ ）</strong></p>
<ul>
<li><strong>A：</strong>abstract修饰符可修饰字段、方法和类</li>
<li><strong>B：</strong>抽象方法的body部分必须用一对大括号{ }包住</li>
<li><strong>C：</strong>声明抽象方法，大括号可有可无</li>
<li><strong>D：</strong>声明抽象方法不可写出大括号</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style=""> 查看答案
  </a><span class="hide-content">答案：D</span></span>

<p><strong>解析：</strong></p>
<p>A:abstract修饰方法和类</p>
<p>B、C:抽象方法没有方法体，有没有方法体看有没有大括号。</p>
</blockquote>
<p><strong>以下不是修饰符final的作用的是( )。</strong></p>
<ul>
<li><strong>A：</strong>修饰常量</li>
<li><strong>B：</strong>修饰不可被继承的类</li>
<li><strong>C：</strong>修饰不可变类</li>
<li><strong>D：</strong>修饰不可覆盖的方法</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：C</span></span>

<p><strong>解析：</strong></p>
<p>final的作用：</p>
<p>​    1. 修饰变量，变量的引用地址不可变，但是地址中的内容可以变。</p>
<p>​    2. 修饰方法，方法不可被重写，但是还是可以重载</p>
<p>​    3. 修饰类，类不可继承。</p>
<p><strong>不可变类：</strong>说的是一个类一旦被实例化，就不可改变自身的状态。常见的比如String和基本数据类型的包装类，对于这种不可变类，一旦在进行引用传递的时候，形参一开始就和实际参数指向的不是一个地址，所以在方法中对形参的改变，并不会影响实际参数。</p>
</blockquote>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><p><strong>变量a是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF;变量b是一个64位有符号的整数，初始值用16进制表示为：0x8000000000000000。则a+b的结果用10进制表示为多少？</strong></p>
<ul>
<li><strong>A：</strong>1</li>
<li><strong>B：</strong>-1</li>
<li><strong>C：</strong>2^63+2^62+…+2^2+2^1+2^0</li>
<li><strong>D：</strong>–(2^63+2^62+…+2^2+2^1+2^0)</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：B</span></span>

<p><strong>解析：</strong></p>
<p>0x7FFFFFFFFFFFFFFF +  0x8000000000000000 =  0xFFFFFFFFFFFFFFFF</p>
<p>（1）a+b的16进制表示为：OxFFFFFFFFFFFFFFF（16位F），转为2进制为111……111（64位1，每个F-&gt;4位2进制）。</p>
<p>（2）有符号数：是针对二进制来讲的。用最高位作为符号位，“0”代表“+”，“1”代表“-”。所以a+b的结果是一个负数。</p>
<p>（3）计算机中负数是以补码的形式保存的，将补码转换成原码的计算方式如下：</p>
<p>​        ①. 对于正数，原码与补码相同。</p>
<p>​        ②.对于负数：</p>
<p>​                （1）<strong>符号位保持不变</strong>，按位取反，末位加1，即得到原码。</p>
<p>​                （2）<strong>符号位保持不变</strong>，先-1，然后其他位按位取反            </p>
<p>​                    这两种方法都可以    </p>
<p>（4）a + b = 111……111（64位1）</p>
<p>​          取反：100……000（1位1，后面63位0）</p>
<p>​          加一：100……00（中间62位0）</p>
<p>​      结果10进制：-1。</p>
</blockquote>
<p><strong>存根（Stub）与以下哪种技术有关</strong> </p>
<ul>
<li><strong>A：</strong>交换</li>
<li><strong>B：</strong>动态链接</li>
<li><strong>C：</strong>动态加载</li>
<li><strong>D：</strong>磁盘调度</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：B</span></span>

<p><strong>解析：</strong></p>
<p>存根类是一个类，它实现了一个接口，它的作用是：如果一个接口有很多方法，如果要实现这个接口，就要实现所有的方法。但是一个类从业务来说，可能只需要其中一两个方法。如果直接去实现这个接口，除了实现所需的方法，还要实现其他所有的无关方法。而如果通过继承存根类就实现接口，就免去了这种麻烦。<br>RMI 采用stubs 和 skeletons 来进行远程对象(remote object)的通讯。stub 充当远程对象的客户端<strong>，有着和远程对象相同的远程接口，远程对象的调用实际是通过调用该对象的客户端</strong>对象stub来完成的。<br>每个远程对象都包含一个<strong>对象stub，当运行在本地Java虚拟机上的程序调用运行在远程Java虚拟机上的对象方法时，它首先在本地创建该对象的</strong>对象stub, 然后调用对象上匹配的方法。每一个远程对象同时也包含一个skeleton对象，skeleton运行在远程对象所在的虚拟机上，接受来自stub对象的调用。这种方式符合等到程序要运行时将目标文件动态进行链接的思想</p>
</blockquote>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><strong>（多选）关于java集合下列说法不正确的有哪些（）</strong></p>
<ul>
<li><strong>A：</strong>HashSet 它是线程安全的，不允许存储相同的对象</li>
<li><strong>B：</strong>ConcurrentHashMap 它是线程安全的，其中存储的键对象可以重复，值对象不能重复</li>
<li><strong>C：</strong>Collection接口是List接口和Set接口的父接口，通常情况下不被直接使用</li>
<li><strong>D：</strong>ArrayList线程安全的，允许存放重复对象</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：ABD</span></span>

<p><strong>解析：</strong></p>
<p><strong>注意：常见并非全部</strong></p>
<p><strong>线程安全(Thread-safe)的集合对象：</strong></p>
<ul>
<li>Vector 线程安全：</li>
<li>HashTable 线程安全：</li>
<li>StringBuffer 线程安全：</li>
</ul>
<p><strong>非线程安全的集合对象：</strong></p>
<ul>
<li>ArrayList ：</li>
<li>LinkedList：</li>
<li>HashMap：</li>
<li>HashSet：</li>
<li>TreeMap：</li>
<li>TreeSet：</li>
<li>StringBulider：</li>
</ul>
</blockquote>
<p><strong>list是一个ArrayList的对象，哪个选项的代码填到//todo delete处，可以在Iterator遍历的过程中正确并安全的删除一个list中保存的对象？（）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = list.iterator();</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">    Object obj = it.next();</span><br><span class="line">    <span class="keyword">if</span> (needDelete(obj))  <span class="comment">//needDelete返回boolean，决定是否要删除</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//todo delete</span></span><br><span class="line">    &#125;</span><br><span class="line">    index ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>it.remove();</li>
<li><strong>B：</strong>list.remove(obj);</li>
<li><strong>C：</strong>list.remove(index);</li>
<li><strong>D：</strong>list.remove(obj,index);</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p>源码是这么描述的：<strong>ArrayList</strong> 继承了 <strong>AbstractList，</strong> 其中<strong>AbstractList</strong> 中有个<strong>modCount</strong> 代表了集合修改的次数。在<strong>ArrayList的iterator方法中会判断</strong> <strong>expectedModCount与</strong> <strong>modCount是否相等，如果相等继续执行，不相等报错，只有iterator的remove方在调用自身的remove之后让</strong> <strong>expectedModCount与modCount再相等，所以是安全的。</strong></p>
</blockquote>
<p><strong>（多选）Hashtable 和 HashMap 的区别是：</strong></p>
<ul>
<li><strong>A：</strong>Hashtable 是一个哈希表，该类继承了 AbstractMap，实现了 Map 接口</li>
<li><strong>B：</strong>HashMap 是内部基于哈希表实现，该类继承AbstractMap，实现Map接口</li>
<li><strong>C：</strong>Hashtable 线程安全的，而 HashMap 是线程不安全的</li>
<li><strong>D：</strong>Properties 类 继承了 Hashtable 类，而 Hashtable 类则继承Dictionary 类</li>
<li><strong>E：</strong>HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：BCDE</span></span>

<p><strong>解析：</strong></p>
<p><strong>Hashtable</strong>：</p>
<p>（1）Hashtable 是一个散列表，它存储的内容是键值对(key-value)映射。</p>
<p>（2）Hashtable 的函数都是同步的，这意味着它是<strong>线程安全</strong>的。它的key、value都不可以为null。</p>
<p>（3）HashTable直接使用对象的hashCode。</p>
<p><strong>HashMap：</strong></p>
<p>（1）由<strong>数组+链表</strong>(jdk1.8以前)组成的，基于<strong>哈希表的Map</strong>实现，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</p>
<p>（2）不是线程安全的，HashMap可以接受为null的键(key)和值(value)。</p>
<p>（3）HashMap重新计算hash值</p>
<p><strong>Hashtable,HashMap,Properties</strong>继承关系如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Properties</span> <span class="keyword">extends</span> <span class="title">Hashtable</span>&lt;<span class="title">Object</span>,<span class="title">Object</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Objecct</span><br><span class="line">java.util.Dictionary&lt;K,V&gt;</span><br><span class="line"> java.util.Hashtable&lt;Object,Object&gt;</span><br><span class="line">   java.util.Properties </span><br></pre></td></tr></table></figure>

</blockquote>
<p><strong>(多选)对</strong> <strong>Map</strong> <strong>的用法，正确的有：</strong></p>
<ul>
<li><strong>A：</strong>new java.util.Map().put(“key” , “value”) ;</li>
<li><strong>B：</strong>new java.util.SortedMap().put(“key” , “value”) ;</li>
<li><strong>C：</strong>new java.util.HashMap().put( null , null ) ;</li>
<li><strong>D：</strong>new java.util.TreeMap().put( 0 , null ) ;</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：CD</span></span>

<p><strong>解析：</strong></p>
<p>选C、D。考察的是<strong>Map接口</strong>实现类的<strong>创建对象</strong>以及对象类型包含的<strong>方法</strong>。</p>
<p>A选项<strong>Map属于接口类型</strong>，不可以new的方式创建对象。所以A错误。</p>
<p>B选项<strong>SortedMap属于接口类型</strong>，不可以new的方式创建对象。所以B错误。</p>
<p>C选项<strong>HashMap</strong>基于哈希表实现Map接口的类，<strong>并允许null的值和null键</strong>。</p>
<p>D选项<strong>TreeMap</strong>通过红黑树实现Map接口的类，key不可以为null，会报<strong>NullPointerException</strong>异常,value可以为null。</p>
</blockquote>
<p><strong>（多选）以下哪些继承自 Collection 接口（）</strong></p>
<ul>
<li><strong>A：</strong>List</li>
<li><strong>B：</strong>Set</li>
<li><strong>C：</strong>Map</li>
<li><strong>D：</strong>Array</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：AB</span></span>

<p><strong>解析：</strong></p>
<p>├List</p>
<p>​    │├LinkedList</p>
<p>​    │├ArrayList</p>
<p>​    │└Vector</p>
<p>​        │└Stack</p>
<p>└Set</p>
<p>Map</p>
<p>​    ├Hashtable</p>
<p>​    ├HashMap</p>
<p>​    └WeakHashMap</p>
</blockquote>
<p><strong>（多选）下面哪些类实现或继承了 Collection 接口？</strong></p>
<ul>
<li>A：HashMap</li>
<li>B：ArrayList</li>
<li>C：Vector</li>
<li>D：Iterator</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：BC</span></span>

<p><strong>解析：</strong></p>
<p><img src="https://image.cclblog.cn/blog/20200623094232.png" alt=""></p>
</blockquote>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">褚超亮</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.cclblog.cn/2020/06/22/java/question/1/">https://www.cclblog.cn/2020/06/22/java/question/1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.cclblog.cn" target="_blank">琦玉老师</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/%E9%A2%98%E9%9B%86/">题集</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/06/23/java/arithmetic/1/"><img class="prev_cover" src="[&quot;https://image.cclblog.cn/a3bd9cb49cbd3ffa4c9e178577b6dffe.jpg&quot;]" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数组题集</div></div></a></div><div class="next-post pull_right"><a href="/2020/06/22/java/theme/question/"><img class="next_cover" src="https://image.cclblog.cn/blog/20200622085700.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java习题整理</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/06/22/java/theme/question/" title="java习题整理"><img class="relatedPosts_cover" src="https://image.cclblog.cn/blog/20200622085700.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-22</div><div class="relatedPosts_title">java习题整理</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/19/java/jvm/2-6/" title="方法区"><img class="relatedPosts_cover" src="https://image.cclblog.cn/a3bd9cb49cbd3ffa4c9e178577b6dffe.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-19</div><div class="relatedPosts_title">方法区</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/17/java/theme/juc/" title="JUC"><img class="relatedPosts_cover" src="https://image.cclblog.cn/blog/20200617103606.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-17</div><div class="relatedPosts_title">JUC</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/06/java/theme/arithmetic/" title="算法"><img class="relatedPosts_cover" src="https://image.cclblog.cn/blog/20200623165013.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-06</div><div class="relatedPosts_title">算法</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/10/java/jvm/2-1-1/" title="clinit()与init()"><img class="relatedPosts_cover" src="https://image.cclblog.cn/a3bd9cb49cbd3ffa4c9e178577b6dffe.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-10</div><div class="relatedPosts_title">clinit()与init()</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/16/java/jvm/2-2-1/" title="分派"><img class="relatedPosts_cover" src="https://image.cclblog.cn/a3bd9cb49cbd3ffa4c9e178577b6dffe.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-16</div><div class="relatedPosts_title">分派</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 褚超亮</div><div class="footer_custom_text"><a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank" rel="noopener"><img style="width:60px;" src="/img/logo.png" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>冀ICP备19034261号-2</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>