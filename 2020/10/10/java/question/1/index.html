<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>题集（第一周） | 琦玉</title><meta name="description" content="2020-06-22 第一周"><meta name="keywords" content="JAVA,题集"><meta name="author" content="琦玉"><meta name="copyright" content="琦玉"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/qiyu.jpeg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="题集（第一周）"><meta name="twitter:description" content="2020-06-22 第一周"><meta name="twitter:image" content="https://www.cclblog.cn/img/head.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="题集（第一周）"><meta property="og:url" content="https://www.cclblog.cn/2020/10/10/java/question/1/"><meta property="og:site_name" content="琦玉"><meta property="og:description" content="2020-06-22 第一周"><meta property="og:image" content="https://www.cclblog.cn/img/head.jpeg"><meta property="article:published_time" content="2020-10-10T02:00:52.000Z"><meta property="article:modified_time" content="2021-03-23T14:00:56.135Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://www.cclblog.cn/2020/10/10/java/question/1/"><link rel="prev" title="桥接模式" href="https://www.cclblog.cn/2020/10/18/java/designMode/BridgePattern/"><link rel="next" title="设计模式" href="https://www.cclblog.cn/2020/10/03/java/theme/design_mode/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://www.cclblog.cn/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"梅,梅","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"top-center"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: true,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/head.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">43</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">10</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">19</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第一周"><span class="toc-text">第一周</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1"><span class="toc-text">1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2"><span class="toc-text">2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3"><span class="toc-text">3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4"><span class="toc-text">4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5"><span class="toc-text">5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6"><span class="toc-text">6</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础"><span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7"><span class="toc-text">7</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8"><span class="toc-text">8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9"><span class="toc-text">9</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10"><span class="toc-text">10</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11"><span class="toc-text">11</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12"><span class="toc-text">12</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13"><span class="toc-text">13</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14"><span class="toc-text">14</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15"><span class="toc-text">15</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16"><span class="toc-text">16</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17"><span class="toc-text">17</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18"><span class="toc-text">18</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19"><span class="toc-text">19</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20"><span class="toc-text">20</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21"><span class="toc-text">21</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22"><span class="toc-text">22</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23"><span class="toc-text">23</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24"><span class="toc-text">24</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25"><span class="toc-text">25</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26"><span class="toc-text">26</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27"><span class="toc-text">27</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28"><span class="toc-text">28</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29"><span class="toc-text">29</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30"><span class="toc-text">30</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31"><span class="toc-text">31</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32"><span class="toc-text">32</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33"><span class="toc-text">33</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34"><span class="toc-text">34</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35"><span class="toc-text">35</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#36"><span class="toc-text">36</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#37"><span class="toc-text">37</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#38"><span class="toc-text">38</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#39"><span class="toc-text">39</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40"><span class="toc-text">40</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41"><span class="toc-text">41</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42"><span class="toc-text">42</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43"><span class="toc-text">43</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#44"><span class="toc-text">44</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#45"><span class="toc-text">45</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#46"><span class="toc-text">46</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#47"><span class="toc-text">47</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计算机基础"><span class="toc-text">计算机基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#48"><span class="toc-text">48</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#49"><span class="toc-text">49</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#50"><span class="toc-text">50</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#51"><span class="toc-text">51</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#52"><span class="toc-text">52</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合"><span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#53"><span class="toc-text">53</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#54"><span class="toc-text">54</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#55"><span class="toc-text">55</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#56"><span class="toc-text">56</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#57"><span class="toc-text">57</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#58"><span class="toc-text">58</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#59"><span class="toc-text">59</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#60"><span class="toc-text">60</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#61"><span class="toc-text">61</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程"><span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#62"><span class="toc-text">62</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#63"><span class="toc-text">63</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#64"><span class="toc-text">64</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#65"><span class="toc-text">65</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO"><span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#66"><span class="toc-text">66</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://image.cclblog.cn/a3bd9cb49cbd3ffa4c9e178577b6dffe.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">琦玉</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">题集（第一周）</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-10-10 10:00:52"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-10-10</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-03-23 22:00:56"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-03-23</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JAVA/">JAVA</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JAVA/%E9%A2%98%E9%9B%86/">题集</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon far fa-file-word" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">13.2k</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h1><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p><strong>假如某个JAVA进程的JVM参数配置如下：</strong><br><strong>-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3,</strong><br><strong>请问eden区最终分配的大小是多少？</strong></p>
<ul>
<li><strong>A：</strong>64M</li>
<li><strong>B：</strong>500M</li>
<li><strong>C：</strong>300M</li>
<li><strong>D：</strong>100M</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：C</span></span>

<p><strong>解析：</strong></p>
<p>-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3,</p>
<p>-Xms1G    设置Java堆最小值为1G    </p>
<p>-Xmx2G    设置Java堆最大值为2G</p>
<p>-Xmn500M    设置新生代大小为500M（一个Eden区，两个Survivor区）</p>
<p>-XX:MaxPermSize=64M    设置永久代大小为64M</p>
<p>-XX:+UseConcMarkSweepGC     设置使用CMS收集器</p>
<p>-XX:SurvivorRatio=3    设置Eden区与Survivor区大小的比例</p>
<p>本题看新生代大小，新生代为500M，三个区比例为3：1：1，很容易计算出Eden大小为300M</p>
</blockquote>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p><strong>对于JVM内存配置参数：</strong></p>
<blockquote>
<p><strong>-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3</strong></p>
</blockquote>
<p><strong>,其最小内存值和Survivor区总大小分别是（）</strong></p>
<ul>
<li><strong>A：</strong>5120m，1024m</li>
<li><strong>B：</strong>5120m，2048m</li>
<li><strong>C：</strong>10240m，1024m</li>
<li><strong>D：</strong>10240m，2048m</li>
</ul>
<blockquote>
<p><strong>解析：</strong></p>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：D</span></span>

<p>-Xmx：最大堆大小</p>
<p>-Xms：初始堆大小</p>
<p>-Xmn:年轻代大小</p>
<p>-XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值</p>
<p>年轻代5120m， Eden：Survivor=3，Survivor区大小=1024m（Survivor区有两个，即将年轻代分为5份，每个Survivor区占一份），总大小为2048m。</p>
<p>-Xms初始堆大小即最小内存值为10240m</p>
</blockquote>
<h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p><strong>（多选）关于OutOfMemoryError，下面说法正确的是（）？</strong></p>
<ul>
<li>java.lang.OutOfMemoryError: PermGen space 增加-XX:MaxPermSize这个参数的值的话，这个问题通常会得到解决。</li>
<li>java.lang.OutOfMemoryError: Requested array size exceeds VM limit当你正准备创建一个超过虚拟机允许的大小的数组时，这条错误将会出现</li>
<li>java.lang.OutOfMemoryError: Java heap space 一般情况下解决这个问题最快的方法就是通过-Xmx参数来增加堆的大小</li>
<li>java.lang.OutOfMemoryError: nativeGetNewTLA这个异常只有在jRockit虚拟机时才会碰到</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：ABC</span></span>

<p><strong>解析：</strong></p>
<p>A：属于运行时常量池导致的溢出，设置-XX：MaxPermSize可以解决这个问题，</p>
<p>B：属于堆空间不足导致的错误，解决方式和C相同，</p>
<p>C：属于java堆内存问题，一般的手段是通过内存映像分析工具，对Dump出来的堆转储存快照进行分析，重点是确认内存中的对象是否是有必要的，也就是要判断是出现了内存泄漏，还是出现了内存溢出。如果是内存泄露，通过工具检查泄露对象打GC Roots的引用链信息，可以准确的确定出泄露代码的位置，不存在泄露，就应该检查虚拟机的堆参数，如果可以继续调大，可以设置-Xmx解决问题</p>
<p>D：java.lang.OutOfMemoryError: nativeGetNewTLA指当虚拟机不能分配新的线程本地空间(Thread Local Area）的时候错误信息，此错误是线程申请一个新的TLA时产生的，这个异常一般只会发生在jRockit虚拟机，只有过于绝对。</p>
</blockquote>
<h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p><strong>下面有关java classloader说法错误的是（）?</strong></p>
<ul>
<li><strong>A：</strong> Java默认提供的三个ClassLoader是BootStrap ClassLoader，Extension ClassLoader，App ClassLoader、</li>
<li><strong>B：</strong>ClassLoader使用的是双亲委托模型来搜索类的</li>
<li><strong>C：</strong>VM在判定两个class是否相同时，只用判断类名相同即可，和类加载器无关</li>
<li><strong>D：</strong>ClassLoader就是用来动态加载class文件到内存当中用的</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：C</span></span>

<p><strong>解析：</strong></p>
<p>比较两个类是否相等，只有这两个类是由同一个类加载器加载才有意义。否则，即使这两个类是来源于同一个Class文件，只要加载它们的类加载器不同，那么这两个类必定不相等。</p>
<p>补充：</p>
<p><strong>1.</strong> <strong>什么是类加载器？</strong></p>
<p>把类加载的过程放到Java虚拟机外部去实现，让应用程序决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。  </p>
<p><strong>2.</strong> <strong>有哪些类加载器，分别加载哪些类</strong></p>
<p>类加载器按照层次，从顶层到底层，分为以下三种：<br>(1)启动类加载器 : 它用来加载 Java 的核心库，比如String、System这些类<br>(2)扩展类加载器 : 它用来加载 Java 的扩展库。</p>
<p>(3) 应用程序类加载器 : 负责加载用户类路径上所指定的类库，一般来说，Java 应用的类都是由它来完成加载的。</p>
<p><strong>3.</strong> <strong>双亲委派模型</strong></p>
<p>我们应用程序都是由以上三种类加载器互相配合进行加载的，还可以加入自己定义的类加载器。称为 <strong>类加载器的双亲委派模型</strong> ，这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用 <strong>组合关系</strong> 来复用父加载器的。</p>
<p><strong>4.</strong> <strong>双亲委托模型的工作原理</strong></p>
<p>是当一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法加载这个加载请求的时候，子加载器才会尝试自己去加载。</p>
<p><strong>5.</strong> <strong>使用双亲委派模型好处？（原因）</strong></p>
<p>第一：可以避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载。</p>
<p>第二：考虑到安全因素，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时被加载，所以用户自定义类是无法加载一个自定义的类装载器。</p>
</blockquote>
<h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p><strong>（多选）关于Java中的ClassLoader下面的哪些描述是错误的：(   )</strong></p>
<ul>
<li><strong>A：</strong>默认情况下，Java应用启动过程涉及三个ClassLoader: Boostrap, Extension, System</li>
<li><strong>B：</strong>一般的情况不同ClassLoader装载的类是不相同的，但接口类例外，对于同一接口所有类装载器装载所获得的类是相同的</li>
<li><strong>C：</strong>类装载器需要保证类装载过程的线程安全</li>
<li><strong>D：</strong>ClassLoader的loadClass在装载一个类时，如果该类不存在它将返回null</li>
<li><strong>E：</strong>ClassLoader的父子结构中，默认装载采用了父优先</li>
<li><strong>F：</strong>所有ClassLoader装载的类都来自CLASSPATH环境指定的路径</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：BDF</span></span>

<p><strong>解析：</strong></p>
<p><strong>A.Java系统提供3种类加载器：启动类加载器（Bootstrap ClassLoader）  扩展类加载器（Extension ClassLoader） 应用程序类加载器（Application ClassLoader）. A正确</strong></p>
<p><strong>B.《深入理解Java虚拟机》P228：对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类必定不相等。</strong>接口类是一种特殊类，因此对于同一接口不同的类装载器装载所获得的类是不相同的。<strong>B错误</strong></p>
<p><strong>C.类只需加载一次就行，因此要保证类加载过程线程安全，防止类加载多次。C正确</strong></p>
<p><strong>D.</strong> <strong>Java程序的类加载器采用双亲委派模型，实现双亲委派的代码集中在java.lang.ClassLoader的loadClass()方法中，此方法实现的大致逻辑是：先检查是否已经被加载，若没有加载则调用父类加载器的loadClass()方法，若父类加载器为空则默认使用启动类加载器作为父类加载器。如果父类加载失败，抛出ClassNotFoundException异常。D错误</strong></p>
<p><strong>E.双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。E正确</strong></p>
<p><strong>F.应用程序类加载器（Application ClassLoader）负责加载</strong>用户类路径（ClassPath）上所指定的类库，不是所有的ClassLoader都加载此路径。F错误</p>
</blockquote>
<h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><p><strong>以下代码执行的结果显示是多少（）？</strong></p>
<ul>
<li><strong>A：</strong>505000</li>
<li><strong>B：</strong>0</li>
<li><strong>C：</strong>运行时错误</li>
<li><strong>D：</strong>5050</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：B</span></span>

<p><strong>解析：</strong></p>
<p>count = count++  原理是 temp = count； count = count+1 ； count = temp；   因此count始终是0 这仅限于java 与c是不一样的</p>
<p>count=count++就是先把局部变量表中count的值0放入操作数栈中，然后直接对局部变量表中的count加1，然后再把操作数栈中的0出栈赋值给局部变量表中的count，最终局部变量表中的count值仍为0</p>
</blockquote>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h4 id="7"><a href="#7" class="headerlink" title="7"></a>7</h4><p><strong>在java中，下列对继承的说法，正确的是（ ）</strong></p>
<ul>
<li><strong>A：</strong>子类能继承父类的所有成员</li>
<li><strong>B：</strong>子类继承父类的非私有方法和状态</li>
<li><strong>C：</strong>子类只能继承父类的public方法和状态</li>
<li><strong>D：</strong>子类只能继承父类的方法</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p>使用反射可以看出子类是继承了父类的私有方法的(不管是否是final)，只是直接调用父类的私有方法是不可以的，但是利用反射的方式可以调用。字段同理。</p>
<p><strong>其实private方法是可以继承的，只是不能调用</strong></p>
</blockquote>
<h4 id="8"><a href="#8" class="headerlink" title="8"></a>8</h4><p><strong>有如下一段程序：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        Test test=<span class="keyword">new</span> Test();</span><br><span class="line">        Test testObject=<span class="keyword">new</span> Test();</span><br><span class="line">        test.getNext();</span><br><span class="line">        testObject.getNext();</span><br><span class="line">        System.out.println(testObject.getNext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>请问最后打印出来的是什么？（）</strong></p>
<ul>
<li><strong>A：</strong>2</li>
<li><strong>B：</strong>3</li>
<li><strong>C：</strong>4</li>
<li><strong>D：</strong>5</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：B</span></span>

<p><strong>解析：</strong></p>
<p>return i++, 先返回i，然后i+1；</p>
<p>第一次调用getNext()方法时，返回的是1，但此时i=2；</p>
<p>第二次调用 getNext()方法时，返回的是2，但此时i=3；</p>
<p>第三次调用 getNext()方法时，返回的是3，但此时i=4；</p>
</blockquote>
<h4 id="9"><a href="#9" class="headerlink" title="9"></a>9</h4><p><strong>（多选）下面的switch语句中，x可以是哪些类型的数据：()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>long</li>
<li><strong>B：</strong>char</li>
<li><strong>C：</strong>float</li>
<li><strong>D：</strong>byte</li>
<li><strong>E：</strong>double</li>
<li><strong>F：</strong>Object</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：BD</span></span>

<p><strong>解析：</strong></p>
<p>jdk1.7之前byte,short ,int ,char</p>
<p>jdk1.7之后加入String </p>
</blockquote>
<h4 id="10"><a href="#10" class="headerlink" title="10"></a>10</h4><p><strong>输出结果为：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str =<span class="string">""</span>;</span><br><span class="line">System.out.print(str.split(<span class="string">","</span>).length);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>0</li>
<li><strong>B：</strong>1</li>
<li><strong>C：</strong>出现异常</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：B</span></span>

<p><strong>解析：</strong></p>
<p>String split() 这个方法默认返回一个数组，如果没有找到分隔符，会把整个字符串当成一个长度为1的字符串数组，返回到结果， 所以此处结果就是1 。</p>
</blockquote>
<h4 id="11"><a href="#11" class="headerlink" title="11"></a>11</h4><p><strong>以下程序执行的结果是：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span>&#123;</span><br><span class="line">    Y y=<span class="keyword">new</span> Y();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">X</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"X"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Y</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Y"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Z</span> <span class="keyword">extends</span> <span class="title">X</span></span>&#123;</span><br><span class="line">    Y y=<span class="keyword">new</span> Y();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Z</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Z"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Z();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A：ZYXX</li>
<li>B：ZYXY</li>
<li>C：YXYZ</li>
<li>D：XYZX</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：C</span></span>

<p><strong>解析：</strong></p>
<p><strong>java对象初始化顺序</strong><br>先说结论：</p>
<ol>
<li>父类静态代码块，父类静态成员变量（同级，按代码顺序执行）</li>
<li>子类静态代码块，子类静态成员变量（同级，按代码顺序执行）</li>
<li>父类普通代码块，父类普通成员变量（同级，按代码顺序执行）</li>
<li>父类构造方法</li>
<li>子类普通代码块，子类普通成员变量（同级，按代码顺序执行）</li>
<li>子类构造方法</li>
</ol>
<p>注意点：</p>
<ol>
<li>静态内容只在类加载时执行一次，之后不再执行。</li>
<li>默认调用父类的无参构造方法，可以在子类构造方法中利用super指定调用父类的哪个构造方法。</li>
</ol>
<hr>
<p><strong>（1）初始化父类的普通成员变量和代码块，执行  Y y=new</strong> <strong>Y();</strong>  <strong>输出Y</strong> </p>
<p><strong>（2）再执行父类的构造方法；输出X</strong></p>
<p><strong>（3）</strong> <strong>初始化子类的普通成员变量和代码块，执行  Y y=new</strong>   <strong>Y();</strong>  <strong>输出Y</strong> </p>
<p><strong>（4）再执行子类的构造方法；输出Z</strong></p>
</blockquote>
<h4 id="12"><a href="#12" class="headerlink" title="12"></a>12</h4><p><strong>设三个整型变量 x = 1 , y = 2 , z = 3，则表达式 y＋＝z－－/＋＋x 的值是( )。</strong></p>
<ul>
<li><strong>A：</strong>3</li>
<li><strong>B：</strong>3.5</li>
<li><strong>C：</strong>4</li>
<li><strong>D：</strong>5</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p>y是2，返回的结果是2+（z–/++x），再来看z–/++x，结果应该是3/2，但是因为x,y,z都是int型的，所以最后的返回值只能是int，这时候z–/++x的值就是1，那么最终的结果就是2+1=3</p>
</blockquote>
<h4 id="13"><a href="#13" class="headerlink" title="13"></a>13</h4><p><strong>instanceof运算符能够用来判断一个对象是否为:</strong></p>
<ul>
<li><strong>A：</strong>一个类的实例</li>
<li><strong>B：</strong>一个实现指定接口的类的实例</li>
<li><strong>C：</strong>全部正确</li>
<li><strong>D：</strong>一个子类的实例</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：C</span></span>

<p><strong>解析：</strong></p>
<p><strong>instance是java的二元运算符，用来判断他左边的对象是否为右面类（接口，抽象类，父类）的实例</strong></p>
</blockquote>
<h4 id="14"><a href="#14" class="headerlink" title="14"></a>14</h4><p><strong>以下代码将打印出</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    String classFile = <span class="string">"com.jd."</span>. replaceAll(<span class="string">"."</span>, <span class="string">"/"</span>) + <span class="string">"MyClass.class"</span>;</span><br><span class="line">    System.out.println(classFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>com. jd</li>
<li><strong>B：</strong>com/jd/MyClass.class</li>
<li><strong>C：</strong>///////MyClass.class</li>
<li><strong>D：</strong>com.jd.MyClass</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：C</span></span>

<p><strong>解析：</strong></p>
<p>由于replaceAll方法的第一个参数是一个正则表达式，而”.”在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成”/“。如果想替换的只是”.”，那么久要写成”\.”.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1=<span class="number">1</span>,b2=<span class="number">2</span>,b3,b6; </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span> b4=<span class="number">4</span>,b5=<span class="number">6</span>; </span><br><span class="line">b6=b4+b5; </span><br><span class="line">b3=(b1+b2); </span><br><span class="line">System.out.println(b3+b6);</span><br></pre></td></tr></table></figure>

<h4 id="15"><a href="#15" class="headerlink" title="15"></a>15</h4><p><strong>关于上面代码片段叙述正确的是（）</strong></p>
<ul>
<li><strong>A：</strong>输出结果：13</li>
<li><strong>B：</strong>语句：b6=b4+b5编译出错</li>
<li><strong>C：</strong>语句：b3=b1+b2编译出错</li>
<li><strong>D：</strong>运行期抛出异常</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：C</span></span>

<p><strong>解析：</strong></p>
<p>被final修饰的变量是常量，这里的b6=b4+b5可以看成是b6=10；在编译时就已经变为b6=10了</p>
<p>而b1和b2是byte类型，java中进行计算时候将他们提升为int类型，再进行计算，b1+b2计算后已经是int类型，赋值给b3，b3是byte类型，类型不匹配，编译不会通过，需要进行强制转换。</p>
<p>Java中的byte，short，char进行计算时都会提升为int类型。</p>
</blockquote>
<h4 id="16"><a href="#16" class="headerlink" title="16"></a>16</h4><p><strong>下面有关java基本类型的默认值和取值范围，说法错误的是？</strong></p>
<ul>
<li><strong>A：</strong>字节型的类型默认值是0，取值范围是-2^7—2^7-1</li>
<li><strong>B：</strong>boolean类型默认值是false，取值范围是true\false</li>
<li><strong>C：</strong>字符型类型默认是0，取值范围是-2^15 —2^15-1</li>
<li><strong>D：</strong>long类型默认是0，取值范围是-2^63—2^63-1</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：C</span></span>

<p><strong>解析：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>More Actions  默认值</th>
<th>存储需求（字节）</th>
<th>取值范围</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>0</td>
<td>1</td>
<td>-2^7—2^7-1</td>
<td>byte b=10;</td>
</tr>
<tr>
<td>char</td>
<td>‘ \u0000′</td>
<td>2</td>
<td>0—2^16-1</td>
<td>char c=’c’ ;</td>
</tr>
<tr>
<td>short</td>
<td>0</td>
<td>2</td>
<td>-2^15—2^15-1</td>
<td>short s=10;</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
<td>4</td>
<td>-2^31—2^31-1</td>
<td>int i=10;</td>
</tr>
<tr>
<td>long</td>
<td>0</td>
<td>8</td>
<td>-2^63—2^63-1</td>
<td>long o=10L;</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
<td>4</td>
<td>-2^31—2^31-1</td>
<td>float f=10.0F</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
<td>8</td>
<td>-2^63—2^63-1</td>
<td>double d=10.0;</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
<td>1</td>
<td>true\false</td>
<td>boolean flag=true;</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="17"><a href="#17" class="headerlink" title="17"></a>17</h4><p><strong>java有8种基本类型，请问byte、int、long、char、float、double、boolean各占多少个字节？</strong></p>
<ul>
<li><strong>A：</strong>1 2 8 2 4 8 1</li>
<li><strong>B：</strong>1 4 8 2 4 8 1</li>
<li><strong>C：</strong>1 4 4 2 4 4 2</li>
<li><strong>D：</strong>1 4 4 2 4 8 2</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：B</span></span>
</blockquote>
<h4 id="18"><a href="#18" class="headerlink" title="18"></a>18</h4><p><strong>对于abstract声明的类，下面说法正确的是</strong></p>
<ul>
<li><strong>A：</strong>可以实例化</li>
<li><strong>B：</strong>不可以被继承</li>
<li><strong>C：</strong>子类为abstract</li>
<li><strong>D：</strong>只能被继承</li>
<li><strong>E：</strong>可以被抽象类继承</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：E</span></span>

<p><strong>解析：</strong></p>
<p>A：抽象类不能实例化，因为有抽象方法未实现</p>
<p>B：可以被继承。派生类可以实现抽象方法</p>
<p>C：子类可以是抽象的，也可以非抽象的</p>
<p>D：只能被继承说法太肯定，不正确</p>
<p>E：可以被抽象类继承，也可以被非抽象类继承</p>
</blockquote>
<h4 id="19"><a href="#19" class="headerlink" title="19"></a>19</h4><p><strong>（多选）final、finally和finalize的区别中，下述说法正确的有？</strong></p>
<ul>
<li><strong>A：</strong>final用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。</li>
<li><strong>B：</strong>finally是异常处理语句结构的一部分，表示总是执行。</li>
<li><strong>C：</strong>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源的回收，例如关闭文件等。</li>
<li><strong>D：</strong>引用变量被final修饰之后，不能再指向其他对象，它指向的对象的内容也是不可变的。</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：AB</span></span>

<p><strong>解析：</strong></p>
<p>A，D考的一个知识点，final修饰变量，变量的引用（也就是指向的地址）不可变，但是引用的内容可以变（地址中的内容可变）。</p>
<p>B，finally表示总是执行。但是其实finally也有不执行的时候，但是这个题不要扣字眼。</p>
<ol>
<li><p>在try中调用System.exit(0)，强制退出了程序，finally块不执行。</p>
</li>
<li><p>在进入try块前，出现了异常，finally块不执行。</p>
</li>
</ol>
<p>C，finalize方法，这个选项错就错在，<strong>这个方法一个对象只能执行一次，只能在第一次进入被回收的队列，而且对象所属于的类重写了finalize方法才会被执行。</strong>第二次进入回收队列的时候，不会再执行其finalize方法，而是直接被二次标记，在下一次GC的时候被GC。</p>
</blockquote>
<h4 id="20"><a href="#20" class="headerlink" title="20"></a>20</h4><p><strong>（多选）以下关于final关键字说法错误的是（）</strong></p>
<ul>
<li><strong>A：</strong>final是java中的修饰符，可以修饰类、接口、抽象类、方法和属性</li>
<li><strong>B：</strong>final修饰的类肯定不能被继承</li>
<li><strong>C：</strong>final修饰的方法不能被重载</li>
<li><strong>D：</strong>final修饰的变量不允许被再次赋值</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：AC</span></span>

<p><strong>解析：</strong></p>
<p>1.final修饰变量，则等同于常量</p>
<p>2.final修饰方法中的参数，称为最终参数。</p>
<p>3.final修饰类，则类不能被继承</p>
<p>4.final修饰方法，则方法不能被重写。</p>
<p>5.final 不能修饰抽象类</p>
<p>6.final修饰的方法可以被重载 但不能被重写</p>
</blockquote>
<h4 id="21"><a href="#21" class="headerlink" title="21"></a>21</h4><p><strong>（多选）下面属于java包装类的是？</strong></p>
<ul>
<li><strong>A：</strong>String</li>
<li><strong>B：</strong>Long</li>
<li><strong>C：</strong>Character</li>
<li><strong>D：</strong>Short</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：BCD</span></span>

<p><strong>解析：</strong></p>
<p>包装类是针对 <strong>基本数据类型</strong> 的。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="22"><a href="#22" class="headerlink" title="22"></a>22</h4><p><strong>（多选）在java中重写方法应遵循规则的包括（）</strong></p>
<ul>
<li><strong>A：</strong>访问修饰符的限制一定要大于被重写方法的访问修饰符</li>
<li><strong>B：</strong>可以有不同的访问修饰符</li>
<li><strong>C：</strong>参数列表必须完全与被重写的方法相同</li>
<li><strong>D：</strong>必须具有不同的参数列表</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：BC</span></span>

<p><strong>解析：</strong></p>
<p>A：错在访问修饰符还可以相等。</p>
<p><strong>方法重写的规则：</strong></p>
<hr>
<ul>
<li>​    1）参数列表必须完全与被重写方法的相同；     </li>
<li>​    2）<strong>返回类型必须完全与被重写方法的返回类型相同；（备注:这条信息是标准的重写方法的规则,但是在java1.5 版本之前返回类型必须一样,1.5(包含) 版本之后java放宽了限制,返回类型必须小于或者等于父类方法的返回类型 才有了子类返回类型小于等于父类方法返回类型。</strong>。    </li>
<li>​       3）访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。     </li>
<li>​    4）父类的成员方法只能被它的子类重写。     </li>
<li>​    5）声明为final的方法不能被重写。     </li>
<li>​    6）声明为static的方法不能被重写，但是能够被再次声明。     </li>
<li>​    7）子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。     </li>
<li>​    8）子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。     </li>
<li>​       9）重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。     </li>
<li>​    10）构造方法不能被重写。     </li>
<li>​    11）如果不能继承一个方法，则不能重写这个方法。</li>
</ul>
</blockquote>
<h4 id="23"><a href="#23" class="headerlink" title="23"></a>23</h4><p><strong>以下代码段执行后的输出结果为()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = -<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y = -<span class="number">12</span>;</span><br><span class="line">System.out.println(y % x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>A：-1</li>
<li>B：2</li>
<li>C：1</li>
<li>D：-2</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：D</span></span>

<p><strong>解析：</strong></p>
<p>取模运算，结果的符号和被除数符号一致，切记切记</p>
</blockquote>
<h4 id="24"><a href="#24" class="headerlink" title="24"></a>24</h4><p><strong>（多选）以下关于final关键字说法错误的是</strong></p>
<ul>
<li><strong>A：</strong>final是java中的修饰符，可以修饰类、接口、抽象类、方法和属性</li>
<li><strong>B：</strong>final修饰的类肯定不能被继承</li>
<li><strong>C：</strong>final修饰的方法不能被重载</li>
<li><strong>D：</strong>final修饰的变量不允许被再次赋值</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：AC</span></span>

<p><strong>解析：</strong></p>
<ul>
<li><p>final修饰类、方法、属性！不能修饰抽象类，因为抽象类一般都是需要被继承的，final修饰后就不能继承了。</p>
</li>
<li><p>final修饰的方法不能被重写而不是重载！ </p>
</li>
<li><p>final修饰属性，此属性就是一个常量，不能被再次赋值！ </p>
</li>
<li><p>final也不能修饰接口，接口可以只能被public&amp;abstract修饰</p>
</li>
<li><p>final如果修饰的是基本类型的变量，那么这个变量就表示为一个常数，只能赋值一次，要么在定义时赋值，要么在初始化时赋值；final修饰应用类型的变量是，变量不能再次被赋值意思是变量的地址（引用）不可以被改变，当变量所指向的内容可以被改变。</p>
</li>
</ul>
</blockquote>
<h4 id="25"><a href="#25" class="headerlink" title="25"></a>25</h4><p><strong>静态内部类不可以直接访问外围类的非静态数据，而非静态内部类可以直接访问外围类的数据，包括私有数据。（ ）</strong></p>
<ul>
<li><strong>A：</strong>正确</li>
<li><strong>B：</strong>错误</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<ol>
<li><p><strong>静态内部类：</strong></p>
<ol>
<li>静态内部类本身可以访问外部的静态资源，包括静态私有资源。但是不能访问非静态资源，可以不依赖外部类实例而实例化。</li>
</ol>
</li>
<li><p><strong>成员内部类：</strong></p>
<ol>
<li>成员内部类本身可以访问外部的所有资源，但是自身不能定义静态资源，因为其实例化本身就还依赖着外部类。</li>
</ol>
</li>
<li><p><strong>局部内部类：</strong></p>
<ol>
<li>局部内部类就像一个局部方法，不能被访问修饰符修饰，也不能被static修饰。</li>
<li>局部内部类只能访问所在代码块或者方法中被定义为final的局部变量。</li>
</ol>
</li>
<li><p><strong>匿名内部类：</strong></p>
<ol>
<li>没有类名的内部类，不能使用class，extends和implements，没有构造方法。</li>
</ol>
<p>​    2.  多用于GUI中的事件处理。</p>
<p>​    3.  不能定义静态资源</p>
<p>​    4.  只能创建一个匿名内部类实例。</p>
<p>​    5. 一个匿名内部类一定是在new后面的，这个匿名类必须继承一个父类或者实现一个接口。</p>
<p>​    6. 匿名内部类是局部内部类的特殊形式，所以局部内部类的所有限制对匿名内部类也有效。</p>
</li>
</ol>
</blockquote>
<h4 id="26"><a href="#26" class="headerlink" title="26"></a>26</h4><p><strong>有如下4条语句：()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i01=<span class="number">59</span>;</span><br><span class="line"><span class="keyword">int</span> i02=<span class="number">59</span>;</span><br><span class="line">Integer i03=Integer.valueOf(<span class="number">59</span>);</span><br><span class="line">Integer i04=<span class="keyword">new</span> Integer(<span class="number">59</span>);</span><br></pre></td></tr></table></figure>

<p><strong>以下输出结果为false的是:</strong></p>
<ul>
<li>System.out.println(i01==i02);</li>
<li>System.out.println(i01==i03);</li>
<li>System.out.println(i03==i04);</li>
<li>System.out.println(i02==i04);</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：D</span></span>

<p><strong>解析：</strong></p>
<ul>
<li>无论如何，Integer与new Integer不会相等。不会经历拆箱过程，</li>
<li>两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false；java在编译Integer i2 = 128的时候,被翻译成-&gt; Integer i2 = Integer.valueOf(128);而valueOf()函数会对-128到127之间的数进行缓存</li>
</ul>
<blockquote>
<p>Integer.valueOf方法中也有判断，如果传递的整型变量&gt;= -128并且小于127时会返回IntegerCache类中一个静态数组中的某一个对象， 否则会返回一个新的Integer对象,代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<ul>
<li>两个都是new出来的,都为false</li>
<li>int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比</li>
</ul>
</blockquote>
<h4 id="27"><a href="#27" class="headerlink" title="27"></a>27</h4><p><strong>定义有StringBuffer s1=new StringBuffer(10);s1.append(“1234”)则s1.length()和s1.capacity()分别是多少?</strong></p>
<ul>
<li><strong>A：</strong>4   10</li>
<li><strong>B：</strong>4   4</li>
<li><strong>C：</strong>10  10</li>
<li><strong>D：</strong>10  4</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p>StringBuffer s = new StringBuffer(x);  x为初始化容量长度</p>
<p>s.append(“Y”); “Y”表示长度为y的字符串</p>
<p>length始终返回当前长度即y；</p>
<p>对于s.capacity()：</p>
<p>1.当y&lt;x时，值为x</p>
<p>以下情况，容器容量需要扩展</p>
<p>2.当x&lt;y&lt;2<em>x+2时，值为 2</em>x+2</p>
<p>3.当y&gt;2x+2时，值为y</p>
</blockquote>
<h4 id="28"><a href="#28" class="headerlink" title="28"></a>28</h4><p><strong>（多选）有关静态初始化块说法正确的是？</strong></p>
<ul>
<li><strong>A：</strong>无法直接调用静态初始化块</li>
<li><strong>B：</strong>在创建第一个实例前或引用任何静态成员之前，将自动调用静态初始化块来初始化</li>
<li><strong>C：</strong>静态初始化块既没有访问修饰符，也没有参数</li>
<li><strong>D：</strong>在程序中，用户可以控制合适执行静态初始化块</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：ABC</span></span>

<p><strong>解析：</strong></p>
<p><strong>java对象初始化顺序</strong><br>先说结论：</p>
<ol>
<li>父类静态代码块，父类静态成员变量（同级，按代码顺序执行）</li>
<li>子类静态代码块，子类静态成员变量（同级，按代码顺序执行）</li>
<li>父类普通代码块，父类普通成员变量（同级，按代码顺序执行）</li>
<li>父类构造方法</li>
<li>子类普通代码块，子类普通成员变量（同级，按代码顺序执行）</li>
<li>子类构造方法</li>
</ol>
<p>注意点：</p>
<ol>
<li>静态内容只在类加载时执行一次，之后不再执行。</li>
<li>默认调用父类的无参构造方法，可以在子类构造方法中利用super指定调用父类的哪个构造方法。</li>
</ol>
</blockquote>
<h4 id="29"><a href="#29" class="headerlink" title="29"></a>29</h4><p><strong>执行如下程序代码</strong></p>
<p>char chr = 127;</p>
<p>int sum = 200;</p>
<p>chr += 1;</p>
<p>sum += chr;</p>
<p>后，sum的值是   ; （     ）</p>
<p>备注：同时考虑c/c++和Java的情况的话</p>
<ul>
<li><strong>A：</strong>72</li>
<li><strong>B：</strong>99</li>
<li><strong>C：</strong>328</li>
<li><strong>D：</strong>327</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：D</span></span> 

<p><strong>解析：</strong></p>
<p>java中只有byte, boolean是一个字节, char是两个字节, 所以对于java来说127不会发生溢出, 输出328</p>
<p>但是对于c/c++语言来说, char是一个字节, 会发生溢出, 对127加一发生溢出,  0111 1111 –&gt; 1000 0000, 1000 0000为补码-128, 所以结果为200-128=72</p>
</blockquote>
<h4 id="30"><a href="#30" class="headerlink" title="30"></a>30</h4><p><strong>下列关于包（package）的描述，正确的是（）</strong></p>
<ul>
<li><strong>A：</strong>包（package）是Java中描述操作系统对多个源代码文件组织的一种方式。</li>
<li><strong>B：</strong>import语句将所对应的Java源文件拷贝到此处执行。</li>
<li><strong>C：</strong>包（package）是Eclipse组织Java项目特有的一种方式。</li>
<li><strong>D：</strong>定义在同一个包（package）内的类可以不经过import而直接相互使用。</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：D</span></span>        

<p><strong>解析：</strong></p>
<p>1、为了更好地组织类，Java提供了包机制。包是类的容器，用于分隔类名空间。如果没有指定包名，所有的示例都属于一个默认的无名包。Java中的包一般均包含相关的类，java是跨平台的，所以java中的包和操作系统没有任何关系，java的包是用来组织文件的一种虚拟文件系统。A错</p>
<p>2、import语句并没有将对应的java源文件拷贝到此处仅仅是引入，告诉编译器有使用外部文件，编译的时候要去读取这个外部文件。B错<br>3、Java提供的包机制与IDE没有关系。C错<br>4、定义在同一个包（package）内的类可以不经过import而直接相互使用。        </p>
</blockquote>
<h4 id="31"><a href="#31" class="headerlink" title="31"></a>31</h4><p><strong>（多选）哪个是不正确的字符常量？</strong></p>
<ul>
<li><strong>A：</strong>”\n”</li>
<li><strong>B：</strong>”1”</li>
<li><strong>C：</strong>”a”</li>
<li><strong>D：</strong>”\101”</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：ABCD</span></span>

<p>解析：文字游戏注意是<strong>字符常量（’’）</strong>而不是<strong>字符串常量（””）</strong></p>
</blockquote>
<h4 id="32"><a href="#32" class="headerlink" title="32"></a>32</h4><p><strong>（多选）以下关于JAVA语言异常处理描述正确的有？</strong></p>
<ul>
<li><strong>A：</strong>throw关键字可以在方法上声明该方法要抛出的异常。</li>
<li><strong>B：</strong>throws用于抛出异常对象。</li>
<li><strong>C：</strong>try是用于检测被包住的语句块是否出现异常，如果有异常，则抛出异常，并执行catch语句。</li>
<li><strong>D：</strong>finally语句块是不管有没有出现异常都要执行的内容。<br>在try块中不可以抛出异常</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：CD</span></span>

<p><strong>解析：</strong></p>
<p>Java语言中的异常处理包括声明异常、抛出异常、捕获异常和处理异常四个环节。</p>
<ul>
<li><p>throws关键字可以在方法上声明该方法要抛出的异常，然后在方法内部通过throw抛出异常对象。<strong>A选项应该为throws B选项应该为throw</strong>。</p>
</li>
<li><p>C选项不严谨，这个异常不是用try抛出来的，而是用了try能检测到底层抛出的异常，然后进行处理。这里应该用“<strong>捕获</strong>”这个异常才对。</p>
<p>这个“如果有异常，则抛出异常”。在捕获异常的时候使用throw，才会抛出这个异常，否则只是捕获到，而不是抛出。这个是需要显式写出来的。</p>
<p>但是答案中存在，忽略这个细节。AB错误太明显。</p>
</li>
</ul>
</blockquote>
<h4 id="33"><a href="#33" class="headerlink" title="33"></a>33</h4><p><strong>下列语句正确的是：</strong></p>
<ul>
<li><strong>A：</strong>形式参数可被字段修饰符修饰</li>
<li><strong>B：</strong>形式参数不可以是对象</li>
<li><strong>C：</strong>形式参数为方法被调用时真正被传递的参数</li>
<li><strong>D：</strong>形式参数可被视为local variable</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：D</span></span>

<p><strong>解析：</strong></p>
<p><img src="https://image.cclblog.cn/blog/20200623100219.png" alt=""></p>
</blockquote>
<h4 id="34"><a href="#34" class="headerlink" title="34"></a>34</h4><p><strong>关于C++/JAVA类中static 成员和对象成员的说法正确的是？</strong></p>
<ul>
<li><strong>A：</strong>static 成员变量在对象构造时生成</li>
<li><strong>B：</strong>static 成员函数在对象成员函数中无法调用</li>
<li><strong>C：</strong>虚成员函数不可能是static 成员函数</li>
<li><strong>D：</strong>static 成员函数不能访问static 成员变量</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：C</span></span>

<p><strong>解析：</strong></p>
<ul>
<li>static为成员变量或函数，在类初始化是加载完成，可以被成员函数调用或访问</li>
<li>static成员函数既可以通过类名直接调用，也可以通过对象名进行调用</li>
<li>虚函数是C++中的，虚函数不可能是static的</li>
<li>static成员函数可以访问static成员变量</li>
</ul>
</blockquote>
<h4 id="35"><a href="#35" class="headerlink" title="35"></a>35</h4><p><strong>给定以下JAVA代码，这段代码运行后输出的结果是（）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aMethod</span><span class="params">(<span class="keyword">int</span> i)</span><span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"exception in a Method"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">"finally"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            aMethod(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.printf(<span class="string">"exception in main"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>exception in main finished</li>
<li><strong>B：</strong>finally finished</li>
<li><strong>C：</strong>exception in main finally</li>
<li><strong>D：</strong>finally exception in main finished</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：B</span></span>

<p><strong>解析：</strong></p>
<p>题目中是i/10 不是 10/i 绝对不会报异常</p>
<p>1、finally块一定会执行，无论是否try…catch。</p>
<p>2、finally前有return，会先执行return语句，并保存下来，再执行finally块，最后return。</p>
<p>3、finally前有return、finally块中也有return，先执行前面的return，保存下来，再执行finally的return，覆盖之前的结果，并返回。</p>
</blockquote>
<h4 id="36"><a href="#36" class="headerlink" title="36"></a>36</h4><p><strong>What is the result?</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.print(c);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] argv )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( foo(<span class="string">'A'</span>); foo(<span class="string">'B'</span>) &amp;&amp; (i &lt; <span class="number">2</span>); foo(<span class="string">'C'</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            i++ ;</span><br><span class="line">            foo(<span class="string">'D'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>ABDCBDCB</li>
<li><strong>B：</strong>ABCDABCD</li>
<li><strong>C：</strong>Compilation fails.</li>
<li><strong>D：</strong>An exception is thrown at runtime.</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p>for(条件1;条件2;条件3) {</p>
<p>​    //语句</p>
<p>}</p>
<p>执行顺序是条件1-&gt;条件2-&gt;语句-&gt;条件3-&gt;条件2-&gt;语句-&gt;条件3-&gt;条件2……..</p>
<p>如果条件2为true，则一直执行。如果条件2位false，则for循环结束21. </p>
</blockquote>
<h4 id="37"><a href="#37" class="headerlink" title="37"></a>37</h4><p><strong>Which lines of the following will produce an error?</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="keyword">byte</span> a1 = <span class="number">2</span>, a2 = <span class="number">4</span>, a3;</span><br><span class="line"><span class="number">2</span>. <span class="keyword">short</span> s = <span class="number">16</span>;</span><br><span class="line"><span class="number">3</span>. a2 = s;</span><br><span class="line"><span class="number">4</span>. a3 = a1 * a2;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>Line 3 and Line 4</li>
<li><strong>B：</strong>Line 1 only</li>
<li><strong>C：</strong>Line 3 only</li>
<li><strong>D：</strong>Line 4 only</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p>short类型转为byte类型出错</p>
<p>a1*a2结果为int类型，转为byte类型出错</p>
<p><strong>java中如果碰到char、byte和short参与运算时，会自动将这些值转换为int类型然后再进行运算。这里a1和a2就自动转为int类型了，结果也为Int类型。把一个int类型赋值给byte需要转型。</strong></p>
</blockquote>
<h4 id="38"><a href="#38" class="headerlink" title="38"></a>38</h4><p><strong>What is displayed when the following is executed;</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1=-<span class="number">0.5</span>;</span><br><span class="line">System.out.println(<span class="string">"Ceil d1="</span>+Math.ceil(d1));</span><br><span class="line">System.out.println(<span class="string">"floor d1="</span>+Math.floor(d1));</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>Ceil d1=-0.0<br>floor d1=-1.0</li>
<li><strong>B：</strong>Ceil d1=0.0<br>floor d1=-1.0</li>
<li><strong>C：</strong>Ceil d1=-0.0<br>floor d1=-0.0</li>
<li><strong>D：</strong>Ceil d1=0.0<br>floor d1=0.0</li>
<li><strong>E：</strong>Ceil d1=0<br>floor d1=-1</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p><strong>ceil：天花板数，向上取整。</strong></p>
<p><strong>floor：地板数，向下取整</strong></p>
<p>这里主要是有一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Math.ceil(d1) `</span><br></pre></td></tr></table></figure>

<p>ceil 方法上有这么一段注释：If the argument value is less than zero but greater than -1.0, then the result is negative zero</p>
<p>如果参数小于0且大于-1.0，结果为 -0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Math.floor(d1)`</span><br></pre></td></tr></table></figure>

<p>ceil 和 floor 方法 上都有一句话：If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as  the argument，意思为：如果参数是 NaN、无穷、正 0、负 0，那么结果与参数相同，</p>
<p>如果是 -0.0，那么其结果是 -0.0</p>
</blockquote>
<h4 id="39"><a href="#39" class="headerlink" title="39"></a>39</h4><p><strong>java中将ISO8859-1字符串转成GB2312编码，语句为 ？</strong>  </p>
<ul>
<li><strong>A：</strong>new String(“ISO8859-1”.getBytes(“ISO8859-1”),”GB2312”)</li>
<li><strong>B：</strong>new String(String.getBytes(“GB2312”）, ISO8859-1)</li>
<li><strong>C：</strong>new String(String.getBytes(“ISO8859-1”))</li>
<li><strong>D：</strong>new String(String.getBytes(“GB2312”))</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p>注意这里”ISO8859-1”是一个普通字符串，不要被迷惑了</p>
<p>new String(“这是要转换的字符串”.getBytes(“ISO-8859-1”), “GB2312”);</p>
</blockquote>
<h4 id="40"><a href="#40" class="headerlink" title="40"></a>40</h4><p><strong>（多选）已知String a=”a”,String b=”b”,String c=a+b,String d=new String(“ab”) 以下操作结果为true的是</strong></p>
<ul>
<li><strong>A：</strong>(a+b).equals(c)</li>
<li><strong>B：</strong>a+b==c</li>
<li><strong>C：</strong>c==d</li>
<li><strong>D：</strong>c.equals(d)</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：AD</span></span>

<p><strong>解析：</strong></p>
<p>1.== 和 equals():</p>
<p>(1)“==” 用于比较基本数据类型时比较的是值，用于比较引用类型时比较的是引用指向的地址。</p>
<p>(2)Object 中的equals() 与 “==” 的作用相同，但String类重写了equals()方法，比较的是对象中的内容。</p>
<p>2.String对象的两种创建方式:</p>
<p>(1)第一种方式: String str1 = “aaa”;  是在常量池中获取对象(“aaa” 属于字符串字面量，因此编译时期会在常量池中创建一个字符串对象，如果常量池中已经存在该字符串对象则直接引用)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>3.String类型的常量池比较特殊。它的主要使用方法有两种</p>
<p>(1)直接使用双引号声明出来的String对象会直接存储在常量池中。</p>
<p>(2)如果不是用双引号声明的String对象,可以使用 String 提供的 intern 方法。 String.intern() 是一个 Native 方法，它的作用是： 如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用； 如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"AAA"</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 = <span class="string">"AAA"</span>;</span><br><span class="line">System.out.println(s2);<span class="comment">//AAA</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false，因为一个是堆内存中的String对象一个是常量池中的String对象，</span></span><br><span class="line">System.out.println(s2 == s3);<span class="comment">//true， s1,s2指向常量池中的”AAA“</span></span><br></pre></td></tr></table></figure>

<p>4字符串拼接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"a"</span>;</span><br><span class="line">String b = <span class="string">"b"</span>;</span><br><span class="line">  </span><br><span class="line">String str1 = <span class="string">"a"</span> + <span class="string">"b"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">String str2 = a + b; <span class="comment">//在堆上创建的新的对象     </span></span><br><span class="line">String str3 = <span class="string">"ab"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//true </span></span><br><span class="line">System.out.println(str2 == str3);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="41"><a href="#41" class="headerlink" title="41"></a>41</h4><p><strong>对于java类型变量char c,short s,float f,double d,表达式c*s+f+d的结果类型为（）</strong></p>
<ul>
<li><strong>A：</strong>float</li>
<li><strong>B：</strong>char</li>
<li><strong>C：</strong>short</li>
<li><strong>D：</strong>double</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：D</span></span>

<p><strong>解析：</strong></p>
<p><strong>基本数据类型的运算，会自动向上转型。boolean不可以和其他基本数据类型相互转换。</strong></p>
<p><strong>byte-&gt;short,char -&gt; int -&gt; long</strong>      </p>
<p><strong>float -&gt; double</strong></p>
<p><strong>int -&gt; float</strong></p>
<p><strong>long -&gt; double</strong></p>
<p><img src="https://image.cclblog.cn/blog/20200622161949.png" alt=""></p>
</blockquote>
<h4 id="42"><a href="#42" class="headerlink" title="42"></a>42</h4><p><strong>在运行时，由java解释器自动引入，而不用import语句引入的包是()。</strong></p>
<ul>
<li><strong>A：</strong>java.lang</li>
<li><strong>B：</strong>java.system</li>
<li><strong>C：</strong>java.io</li>
<li><strong>D：</strong>java.util</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p>java.lang包是java语言的核心包，lang是language的缩写</p>
<p>java.lang包定义了一些基本的类型，包括Integer,String之类的，是java程序必备的包，有解释器自动引入，无需手动导入</p>
</blockquote>
<h4 id="43"><a href="#43" class="headerlink" title="43"></a>43</h4><p><strong>由3 个“1”和 5 个“0”组成的 8 位二进制补码，能表示的最小整数（）</strong></p>
<ul>
<li><strong>A：</strong>-126</li>
<li><strong>B：</strong>-125</li>
<li><strong>C：</strong>-32</li>
<li><strong>D：</strong>-3</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：B</span></span>

<p><strong>解析：</strong></p>
<p>既然求最小整数，那肯定先想到负数，则最高位（符号位）一定为1，原码中肯定是1所在的位数越高，值越小，而补码是由原码取反加1（符号位不变）得到的，则在补码中1所在的位数一定要越低，即补码为1000 0011；由补码求得原码：1111 1101=-(64+32+16+8+4+1)=-125;</p>
</blockquote>
<h4 id="44"><a href="#44" class="headerlink" title="44"></a>44</h4><p><strong>关于访问权限，说法正确的是？ ( )</strong></p>
<ul>
<li><strong>A：</strong>类A和类B在同一包中，类B有个protected的方法testB，类A不是类B的子类（或子类的子类），类A可以访问类B的方法testB</li>
<li><strong>B：</strong>类A和类B在同一包中，类B有个protected的方法testB，类A不是类B的子类（或子类的子类），类A不可以访问类B的方法testB</li>
<li><strong>C：</strong>访问权限大小范围：public &gt; 包权限 &gt; protected &gt; private</li>
<li><strong>D：</strong>访问权限大小范围：public &gt; 包权限 &gt; private &gt; protected</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p><img src="https://image.cclblog.cn/blog/20200622110227.jpg" alt=""></p>
</blockquote>
<h4 id="45"><a href="#45" class="headerlink" title="45"></a>45</h4><p><strong>以下程序程序运行后的输出结果是（）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">12</span>,n=<span class="number">34</span>;</span><br><span class="line">    System.out.printf(<span class="string">"%d%d"</span>,m++,++n);</span><br><span class="line">    System.out.printf(<span class="string">"%d%d\n"</span>,n++,++m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>12353514</li>
<li><strong>B：</strong>12353513</li>
<li><strong>C：</strong>12343514</li>
<li><strong>D：</strong>12343513</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p><strong>不要忘记前面已经自加过后，变量的值已经改变了（明白了这个肯定就没问题了）</strong></p>
<p>​          第一个输出：m++值：12，m的值：13</p>
<p>​                              ++n值：35，n的值：35</p>
<p>​          第一个输出：n++值：35，n的值：36</p>
<p>​                              ++m值：14，n的值：14</p>
<p>​          故最终输出：12353514</p>
</blockquote>
<h4 id="46"><a href="#46" class="headerlink" title="46"></a>46</h4><p><strong>在jdk1.8之前，下列哪一种叙述是正确的（ ）</strong></p>
<ul>
<li><strong>A：</strong>abstract修饰符可修饰字段、方法和类</li>
<li><strong>B：</strong>抽象方法的body部分必须用一对大括号{ }包住</li>
<li><strong>C：</strong>声明抽象方法，大括号可有可无</li>
<li><strong>D：</strong>声明抽象方法不可写出大括号</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style=""> 查看答案
  </a><span class="hide-content">答案：D</span></span>

<p><strong>解析：</strong></p>
<p>A:abstract修饰方法和类</p>
<p>B、C:抽象方法没有方法体，有没有方法体看有没有大括号。</p>
</blockquote>
<h4 id="47"><a href="#47" class="headerlink" title="47"></a>47</h4><p><strong>以下不是修饰符final的作用的是( )。</strong></p>
<ul>
<li><strong>A：</strong>修饰常量</li>
<li><strong>B：</strong>修饰不可被继承的类</li>
<li><strong>C：</strong>修饰不可变类</li>
<li><strong>D：</strong>修饰不可覆盖的方法</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：C</span></span>

<p><strong>解析：</strong></p>
<p>final的作用：</p>
<p>​    1. 修饰变量，变量的引用地址不可变，但是地址中的内容可以变。</p>
<p>​    2. 修饰方法，方法不可被重写，但是还是可以重载</p>
<p>​    3. 修饰类，类不可继承。</p>
<p><strong>不可变类：</strong>说的是一个类一旦被实例化，就不可改变自身的状态。常见的比如String和基本数据类型的包装类，对于这种不可变类，一旦在进行引用传递的时候，形参一开始就和实际参数指向的不是一个地址，所以在方法中对形参的改变，并不会影响实际参数。</p>
</blockquote>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h4 id="48"><a href="#48" class="headerlink" title="48"></a>48</h4><p><strong>在一个基于分布式的游戏服务器系统中，不同的服务器之间，哪种通信方式是不可行的（）？</strong></p>
<ul>
<li><strong>A：</strong>管道</li>
<li><strong>B：</strong>消息队列</li>
<li><strong>C：</strong>高速缓存数据库</li>
<li><strong>D：</strong>套接字</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p><strong>管道( pipe )：</strong>管道是一种半双工的通信方式，数据只能单向流动，<strong>而且只能在具有亲缘关系的进程间使用</strong>。进程的亲缘关系通常是指父子进程关系。</p>
<p><strong>既然是不同的服务器之间进行通信，怎么可能会是具有亲缘关系的进程呢？</strong></p>
</blockquote>
<h4 id="49"><a href="#49" class="headerlink" title="49"></a>49</h4><p><strong>以下哪个式子有可能在某个进制下成立（）？</strong></p>
<ul>
<li><strong>A：</strong>13  * 14=204</li>
<li><strong>B：</strong>12 * 34=568</li>
<li><strong>C：</strong>14*14=140</li>
<li><strong>D：</strong>1+1=3</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p>A:  假设为x进制</p>
<p>13用10进制表示为 1 * x^1 + 3 * x ^ 0 =  x + 3</p>
<p>同理 14 ：x + 4 </p>
<p>204：2x^2 + 4</p>
<p>(x + 3)(x + 4 ) = 2x^2 + 4</p>
<p>解得 x1 = 8 x2 = -1</p>
<p>BCD同理可计算</p>
</blockquote>
<h4 id="50"><a href="#50" class="headerlink" title="50"></a>50</h4><p><strong>以下JAVA程序代码的输出是</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="number">17</span>^<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>12</li>
<li><strong>B：</strong>22</li>
<li><strong>C：</strong>20</li>
<li><strong>D：</strong>1419857</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：C</span></span>

<p><strong>解析：</strong></p>
<p>位异运算符号。</p>
<p>运算规则是：两个数转为二进制，然后从高位开始比较，如果相同则为0，不相同则为1。</p>
<p>17：0001 0001 </p>
<p>5：  0000 0101</p>
<p>结果：0001 0100 转10进制：20</p>
</blockquote>
<h4 id="51"><a href="#51" class="headerlink" title="51"></a>51</h4><p><strong>变量a是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF;变量b是一个64位有符号的整数，初始值用16进制表示为：0x8000000000000000。则a+b的结果用10进制表示为多少？</strong></p>
<ul>
<li><strong>A：</strong>1</li>
<li><strong>B：</strong>-1</li>
<li><strong>C：</strong>2^63+2^62+…+2^2+2^1+2^0</li>
<li><strong>D：</strong>–(2^63+2^62+…+2^2+2^1+2^0)</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：B</span></span>

<p><strong>解析：</strong></p>
<p>0x7FFFFFFFFFFFFFFF +  0x8000000000000000 =  0xFFFFFFFFFFFFFFFF</p>
<p>（1）a+b的16进制表示为：OxFFFFFFFFFFFFFFF（16位F），转为2进制为111……111（64位1，每个F-&gt;4位2进制）。</p>
<p>（2）有符号数：是针对二进制来讲的。用最高位作为符号位，“0”代表“+”，“1”代表“-”。所以a+b的结果是一个负数。</p>
<p>（3）计算机中负数是以补码的形式保存的，将补码转换成原码的计算方式如下：</p>
<p>​        ①. 对于正数，原码与补码相同。</p>
<p>​        ②.对于负数：</p>
<p>​                （1）<strong>符号位保持不变</strong>，按位取反，末位加1，即得到原码。</p>
<p>​                （2）<strong>符号位保持不变</strong>，先-1，然后其他位按位取反            </p>
<p>​                    这两种方法都可以    </p>
<p>（4）a + b = 111……111（64位1）</p>
<p>​          取反：100……000（1位1，后面63位0）</p>
<p>​          加一：100……00（中间62位0）</p>
<p>​      结果10进制：-1。</p>
</blockquote>
<h4 id="52"><a href="#52" class="headerlink" title="52"></a>52</h4><p><strong>存根（Stub）与以下哪种技术有关</strong> </p>
<ul>
<li><strong>A：</strong>交换</li>
<li><strong>B：</strong>动态链接</li>
<li><strong>C：</strong>动态加载</li>
<li><strong>D：</strong>磁盘调度</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：B</span></span>

<p><strong>解析：</strong></p>
<p>存根类是一个类，它实现了一个接口，它的作用是：如果一个接口有很多方法，如果要实现这个接口，就要实现所有的方法。但是一个类从业务来说，可能只需要其中一两个方法。如果直接去实现这个接口，除了实现所需的方法，还要实现其他所有的无关方法。而如果通过继承存根类就实现接口，就免去了这种麻烦。<br>RMI 采用stubs 和 skeletons 来进行远程对象(remote object)的通讯。stub 充当远程对象的客户端<strong>，有着和远程对象相同的远程接口，远程对象的调用实际是通过调用该对象的客户端</strong>对象stub来完成的。<br>每个远程对象都包含一个<strong>对象stub，当运行在本地Java虚拟机上的程序调用运行在远程Java虚拟机上的对象方法时，它首先在本地创建该对象的</strong>对象stub, 然后调用对象上匹配的方法。每一个远程对象同时也包含一个skeleton对象，skeleton运行在远程对象所在的虚拟机上，接受来自stub对象的调用。这种方式符合等到程序要运行时将目标文件动态进行链接的思想</p>
</blockquote>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h4 id="53"><a href="#53" class="headerlink" title="53"></a>53</h4><p><strong>（多选）对Collection和Collections描述正确的是</strong></p>
<ul>
<li><strong>A：</strong>Collection是java.util下的类，它包含有各种有关集合操作的静态方法</li>
<li><strong>B：</strong>Collection是java.util下的接口，它是各种集合结构的父接口</li>
<li><strong>C：</strong>Collections是java.util下的接口，它是各种集合结构的父接口</li>
<li><strong>D：</strong>Collections是java.util下的类，它包含有各种有关集合操作的静态方法</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：BD</span></span>

<p><strong>解析：</strong></p>
<ul>
<li><p>java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。</p>
</li>
<li><p>java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。</p>
</li>
</ul>
</blockquote>
<h4 id="54"><a href="#54" class="headerlink" title="54"></a>54</h4><p><strong>java8中，下面哪个类用到了解决哈希冲突的开放定址法</strong></p>
<ul>
<li><strong>A：</strong>LinkedHashSet</li>
<li><strong>B：</strong>HashMap</li>
<li><strong>C：</strong>ThreadLocal</li>
<li><strong>D：</strong>TreeMap</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：C</span></span>

<p><strong>解析：</strong></p>
<p>ThreadLocalMap中使用开放地址法来处理散列冲突，而HashMap中使用的是分离链表法。之所以采用不同的方式主要是因为：在ThreadLocalMap中的散列值分散得十分均匀，很少会出现冲突。并且ThreadLocalMap经常需要清除无用的对象，使用纯数组更加方便。</p>
</blockquote>
<h4 id="55"><a href="#55" class="headerlink" title="55"></a>55</h4><p><strong>列表(List)和集合(Set)下面说法正确的是？  ( )</strong></p>
<ul>
<li><strong>A：</strong>Set中至多只能有一个空元素</li>
<li><strong>B：</strong>List中至多只能有一个空元素</li>
<li><strong>C：</strong>List和Set都可以包含重复元素的有序集合</li>
<li><strong>D：</strong>List和Set都是有序集合</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<ul>
<li>Set 不能有重复的元素，且是无序的，要有空值也就只能有一个。因为它不允许重复。 L ist 可以有重复元素，且是有序的，要有空值也可以有多个，因为它可重复。</li>
<li>java里面讲的有序无序，指的是你按照顺序存进去数据，然后再按照顺序取出来，两者是一样的。比如List(0)我放的是“a”，那么我list.get(0)取出来也是“a”。并不代表我存了打乱顺序存1到10十个数，它会自己给按照升序或者降序给你排好序。</li>
</ul>
</blockquote>
<h4 id="56"><a href="#56" class="headerlink" title="56"></a>56</h4><p><strong>（多选）关于java集合下列说法不正确的有哪些（）</strong></p>
<ul>
<li><strong>A：</strong>HashSet 它是线程安全的，不允许存储相同的对象</li>
<li><strong>B：</strong>ConcurrentHashMap 它是线程安全的，其中存储的键对象可以重复，值对象不能重复</li>
<li><strong>C：</strong>Collection接口是List接口和Set接口的父接口，通常情况下不被直接使用</li>
<li><strong>D：</strong>ArrayList线程安全的，允许存放重复对象</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：ABD</span></span>

<p><strong>解析：</strong></p>
<p><strong>注意：常见并非全部</strong></p>
<p><strong>线程安全(Thread-safe)的集合对象：</strong></p>
<ul>
<li>Vector 线程安全：</li>
<li>HashTable 线程安全：</li>
<li>StringBuffer 线程安全：</li>
</ul>
<p><strong>非线程安全的集合对象：</strong></p>
<ul>
<li>ArrayList ：</li>
<li>LinkedList：</li>
<li>HashMap：</li>
<li>HashSet：</li>
<li>TreeMap：</li>
<li>TreeSet：</li>
<li>StringBulider：</li>
</ul>
</blockquote>
<h4 id="57"><a href="#57" class="headerlink" title="57"></a>57</h4><p><strong>list是一个ArrayList的对象，哪个选项的代码填到//todo delete处，可以在Iterator遍历的过程中正确并安全的删除一个list中保存的对象？（）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = list.iterator();</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">    Object obj = it.next();</span><br><span class="line">    <span class="keyword">if</span> (needDelete(obj))  <span class="comment">//needDelete返回boolean，决定是否要删除</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//todo delete</span></span><br><span class="line">    &#125;</span><br><span class="line">    index ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>it.remove();</li>
<li><strong>B：</strong>list.remove(obj);</li>
<li><strong>C：</strong>list.remove(index);</li>
<li><strong>D：</strong>list.remove(obj,index);</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：A</span></span>

<p><strong>解析：</strong></p>
<p>源码是这么描述的：<strong>ArrayList</strong> 继承了 <strong>AbstractList，</strong> 其中<strong>AbstractList</strong> 中有个<strong>modCount</strong> 代表了集合修改的次数。在<strong>ArrayList的iterator方法中会判断</strong> <strong>expectedModCount与</strong> <strong>modCount是否相等，如果相等继续执行，不相等报错，只有iterator的remove方在调用自身的remove之后让</strong> <strong>expectedModCount与modCount再相等，所以是安全的。</strong></p>
</blockquote>
<h4 id="58"><a href="#58" class="headerlink" title="58"></a>58</h4><p><strong>（多选）Hashtable 和 HashMap 的区别是：</strong></p>
<ul>
<li><strong>A：</strong>Hashtable 是一个哈希表，该类继承了 AbstractMap，实现了 Map 接口</li>
<li><strong>B：</strong>HashMap 是内部基于哈希表实现，该类继承AbstractMap，实现Map接口</li>
<li><strong>C：</strong>Hashtable 线程安全的，而 HashMap 是线程不安全的</li>
<li><strong>D：</strong>Properties 类 继承了 Hashtable 类，而 Hashtable 类则继承Dictionary 类</li>
<li><strong>E：</strong>HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：BCDE</span></span>

<p><strong>解析：</strong></p>
<p><strong>Hashtable</strong>：</p>
<p>（1）Hashtable 是一个散列表，它存储的内容是键值对(key-value)映射。</p>
<p>（2）Hashtable 的函数都是同步的，这意味着它是<strong>线程安全</strong>的。它的key、value都不可以为null。</p>
<p>（3）HashTable直接使用对象的hashCode。</p>
<p><strong>HashMap：</strong></p>
<p>（1）由<strong>数组+链表</strong>(jdk1.8以前)组成的，基于<strong>哈希表的Map</strong>实现，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</p>
<p>（2）不是线程安全的，HashMap可以接受为null的键(key)和值(value)。</p>
<p>（3）HashMap重新计算hash值</p>
<p><strong>Hashtable,HashMap,Properties</strong>继承关系如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Properties</span> <span class="keyword">extends</span> <span class="title">Hashtable</span>&lt;<span class="title">Object</span>,<span class="title">Object</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Objecct</span><br><span class="line">java.util.Dictionary&lt;K,V&gt;</span><br><span class="line"> java.util.Hashtable&lt;Object,Object&gt;</span><br><span class="line">   java.util.Properties </span><br></pre></td></tr></table></figure>

</blockquote>
<h4 id="59"><a href="#59" class="headerlink" title="59"></a>59</h4><p><strong>(多选)对</strong> <strong>Map</strong> <strong>的用法，正确的有：</strong></p>
<ul>
<li><strong>A：</strong>new java.util.Map().put(“key” , “value”) ;</li>
<li><strong>B：</strong>new java.util.SortedMap().put(“key” , “value”) ;</li>
<li><strong>C：</strong>new java.util.HashMap().put( null , null ) ;</li>
<li><strong>D：</strong>new java.util.TreeMap().put( 0 , null ) ;</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：CD</span></span>

<p><strong>解析：</strong></p>
<p>选C、D。考察的是<strong>Map接口</strong>实现类的<strong>创建对象</strong>以及对象类型包含的<strong>方法</strong>。</p>
<p>A选项<strong>Map属于接口类型</strong>，不可以new的方式创建对象。所以A错误。</p>
<p>B选项<strong>SortedMap属于接口类型</strong>，不可以new的方式创建对象。所以B错误。</p>
<p>C选项<strong>HashMap</strong>基于哈希表实现Map接口的类，<strong>并允许null的值和null键</strong>。</p>
<p>D选项<strong>TreeMap</strong>通过红黑树实现Map接口的类，key不可以为null，会报<strong>NullPointerException</strong>异常,value可以为null。</p>
</blockquote>
<h4 id="60"><a href="#60" class="headerlink" title="60"></a>60</h4><p><strong>（多选）以下哪些继承自 Collection 接口（）</strong></p>
<ul>
<li><strong>A：</strong>List</li>
<li><strong>B：</strong>Set</li>
<li><strong>C：</strong>Map</li>
<li><strong>D：</strong>Array</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：AB</span></span>

<p><strong>解析：</strong></p>
<p>├List</p>
<p>​    │├LinkedList</p>
<p>​    │├ArrayList</p>
<p>​    │└Vector</p>
<p>​        │└Stack</p>
<p>└Set</p>
<p>Map</p>
<p>​    ├Hashtable</p>
<p>​    ├HashMap</p>
<p>​    └WeakHashMap</p>
</blockquote>
<h4 id="61"><a href="#61" class="headerlink" title="61"></a>61</h4><p><strong>（多选）下面哪些类实现或继承了 Collection 接口？</strong></p>
<ul>
<li>A：HashMap</li>
<li>B：ArrayList</li>
<li>C：Vector</li>
<li>D：Iterator</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：BC</span></span>

<p><strong>解析：</strong></p>
<p><img src="https://image.cclblog.cn/blog/20200623094232.png" alt=""></p>
</blockquote>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h4 id="62"><a href="#62" class="headerlink" title="62"></a>62</h4><p><strong>（多选）下列哪些操作会使线程释放锁资源？</strong></p>
<ul>
<li><strong>A：</strong>sleep()</li>
<li><strong>B：</strong>wait()</li>
<li><strong>C：</strong>join()</li>
<li><strong>D：</strong>yield()</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：BC</span></span>

<p><strong>解析：</strong></p>
<p>所谓的释放锁资源实际是通知对象内置的monitor对象进行释放，而只有所有对象都有内置的monitor对象才能实现任何对象的锁资源都可以释放。又因为所有类都继承自Object，所以wait(）就成了Object方法，也就是通过wait()来通知对象内置的monitor对象释放，而且事实上因为这涉及对硬件底层的操作，所以wait()方法是native方法，底层是用C写的。</p>
<p>其他都是Thread所有，所以其他3个是没有资格释放资源的</p>
<p>而join()有资格释放资源其实是通过调用wait()来实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码如下： </span></span><br><span class="line">wait()方法   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// join()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay); </span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="63"><a href="#63" class="headerlink" title="63"></a>63</h4><p><strong>（多选）在Java线程状态转换时，下列转换不可能发生的有（）？</strong></p>
<ul>
<li><strong>A：</strong>初始态-&gt;运行态</li>
<li><strong>B：</strong>就绪态-&gt;运行态</li>
<li><strong>C：</strong>阻塞态-&gt;运行态</li>
<li><strong>D：</strong>运行态-&gt;就绪态</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：AC</span></span>

<p><strong>解析：</strong></p>
<p><img src="https://image.cclblog.cn/blog/20200624171403.jpg" alt=""></p>
</blockquote>
<h4 id="64"><a href="#64" class="headerlink" title="64"></a>64</h4><p><strong>（多选）Java.Thread的方法resume()负责重新开始被以下哪个方法中断的线程的执行（）。</strong></p>
<ul>
<li><strong>A：</strong>stop</li>
<li><strong>B：</strong>sleep</li>
<li><strong>C：</strong>wait</li>
<li><strong>D：</strong>suspend</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：D</span></span>

<p><strong>解析：</strong></p>
<p>resume与suspended一起使用<br>wait与notify/notifyAll一起使用<br>sleep会让线程暂时不执行</p>
<p><strong>Thread类的suspend（）和resume（）方法都已经被声明已废弃了</strong></p>
</blockquote>
<h4 id="65"><a href="#65" class="headerlink" title="65"></a>65</h4><p><strong>下列程序的运行结果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            pong();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.run();</span><br><span class="line">    System.out.print(<span class="string">"ping"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"pong"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A：</strong>pingpong</li>
<li><strong>B：</strong>pongping</li>
<li><strong>C：</strong>pingpong和pongping都有可能</li>
<li><strong>D：</strong>都不输出</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：B</span></span>

<p><strong>解析：</strong></p>
<p>这里需要注意Thread的start和run方法</p>
<p>用start方法才能真正启动线程，此时线程会处于就绪状态，一旦得到时间片，则会调用线程的run方法进入运行状态。</p>
<p>而run方法只是普通方法，如果直接调用run方法，程序只会按照顺序执行主线程这一个线程。</p>
</blockquote>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h4 id="66"><a href="#66" class="headerlink" title="66"></a>66</h4><p><strong>BufferedReader的父类是以下哪个？</strong></p>
<ul>
<li><strong>A：</strong>FilterReader</li>
<li><strong>B：</strong>InputStreamReader</li>
<li><strong>C：</strong>PipedReader</li>
<li><strong>D：</strong>Reader</li>
</ul>
<blockquote>
<span class="hide-inline"><a class="hide-button button--primary button--animated" style="">查看答案
  </a><span class="hide-content">答案：D</span></span>

<p><strong>解析：</strong></p>
<p><img src="https://image.cclblog.cn/blog/20200625205640.png" alt=""></p>
</blockquote>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">琦玉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.cclblog.cn/2020/10/10/java/question/1/">https://www.cclblog.cn/2020/10/10/java/question/1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.cclblog.cn" target="_blank">琦玉</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/%E9%A2%98%E9%9B%86/">题集</a></div><div class="post_share"><div class="social-share" data-image="https://image.cclblog.cn/mmexport1614520121844.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/10/18/java/designMode/BridgePattern/"><img class="prev_cover" src="[&quot;https://image.cclblog.cn/a3bd9cb49cbd3ffa4c9e178577b6dffe.jpg&quot;]" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">桥接模式</div></div></a></div><div class="next-post pull_right"><a href="/2020/10/03/java/theme/design_mode/"><img class="next_cover" src="https://image.cclblog.cn/blog/20200628163855.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">设计模式</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/10/24/java/question/2/" title="题集（第二周）"><img class="relatedPosts_cover" src="https://image.cclblog.cn/a3bd9cb49cbd3ffa4c9e178577b6dffe.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-10-24</div><div class="relatedPosts_title">题集（第二周）</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/04/java/theme/question/" title="Java基础习题整理"><img class="relatedPosts_cover" src="https://image.cclblog.cn/blog/20200622085700.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-04</div><div class="relatedPosts_title">Java基础习题整理</div></div></a></div><div class="relatedPosts_item"><a href="/2020/11/14/java/designMode/DecoratorPattern/" title="装饰者模式"><img class="relatedPosts_cover" src="https://image.cclblog.cn/a3bd9cb49cbd3ffa4c9e178577b6dffe.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-11-14</div><div class="relatedPosts_title">装饰者模式</div></div></a></div><div class="relatedPosts_item"><a href="/2020/12/12/java/designMode/SingletonPattern/" title="单例模式"><img class="relatedPosts_cover" src="https://image.cclblog.cn/a3bd9cb49cbd3ffa4c9e178577b6dffe.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-12-12</div><div class="relatedPosts_title">单例模式</div></div></a></div><div class="relatedPosts_item"><a href="/2020/12/26/java/designMode/TemplateMethodPattern/" title="模板方法模式"><img class="relatedPosts_cover" src="https://image.cclblog.cn/a3bd9cb49cbd3ffa4c9e178577b6dffe.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-12-26</div><div class="relatedPosts_title">模板方法模式</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/25/java/javase/1/" title="重载与重写规则"><img class="relatedPosts_cover" src="https://image.cclblog.cn/a3bd9cb49cbd3ffa4c9e178577b6dffe.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-25</div><div class="relatedPosts_title">重载与重写规则</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 琦玉</div><div class="footer_custom_text"><a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank" rel="noopener"><img style="width:60px;" src="/img/logo.png" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>冀ICP备19034261号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode far fa-sun" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="/js/third-party/click_heart.js"></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>